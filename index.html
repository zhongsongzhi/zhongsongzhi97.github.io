<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/MQ%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/MQ%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">MQ小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-10 20:50:39 / Modified: 20:51:07" itemprop="dateCreated datePublished" datetime="2022-02-10T20:50:39+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><ol>
<li>队列模型</li>
<li>发布-订阅模型：消息的发送者，消息的接受者，服务端存放消息的容器(Topic)。发布者将消息发送到主题中，订阅者在接收消息前需要先订阅”Topic“，每份订阅，订阅者可以收到主题的所有消息。</li>
</ol>
<p>区别：发布-订阅模型中，一个消息可以被多次消费。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>使用”请求-确认“机制确保消息不会丢失</p>
<ol>
<li><p>生成端：</p>
<p>生产者先将消息发送给服务端(Broker)，Broker收到消息后将消息写入Topic后再给生产者发送确认响应。如果没有收到响应则会重复发送消息。</p>
</li>
<li><p>消费端：</p>
<p>消费者在收到消息并完成消费业务逻辑后，也会向服务端发送消费成功的确认。（注：应该在完成消费业务逻辑以后再进行确认）</p>
</li>
<li><p>存储阶段：</p>
<p>如果Broker是多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点在回复确认。</p>
</li>
</ol>
<p>由于”请求-确认“机制，为了确保消息的有序性，一条消息被成功消费前，下一条消息是不能被消费的。所有扩容Consumer时需要扩容Consumer Queue</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>解决 -&gt; 在分布式系统中保持一致性</p>
<p>成员：协调者，参与者</p>
<ol>
<li>投票阶段：协调者向参与者询问是否可以指向操作，参与者执行完(agreement/abort)并且记录redo/undo日志。当所有参与者都执行完进行提交阶段。</li>
<li>提交阶段：如果都同意，则协调者发送commit，否则rollback。参与者完成操作后返回消息，如果协调者收到所有的返回消息则结束事务，否则回滚。</li>
</ol>
<p>EG：</p>
<p>订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车删除（使用消息队列异步清理购物车）。需要保证本地事务和发消息这两步要么都成功，要么都失败。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8phzrxhaj32g70u0q7b.jpg" alt="img"></p>
<ol>
<li>订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</li>
<li>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</li>
</ol>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>RocketMQ的存储以Broker为单位，Broker(ConsumerLog消息文件&amp;N*ConsumerQueue索引文件)，</p>
<ol>
<li>写入消息：Broker上所有Topic，队列的消息都按照自然顺序追加写入到同一个消息文件中</li>
<li>查找消息：根据队列的消息序号，计算索引的全局位置(索引序号 x 索引固定长度20)，直接读取这条索引，然后根据索引查找到消息的位置</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">序列化和反序列化小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-10 16:40:37 / Modified: 17:22:07" itemprop="dateCreated datePublished" datetime="2022-02-10T16:40:37+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">序列化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序列化和反序列化小结"><a href="#序列化和反序列化小结" class="headerlink" title="序列化和反序列化小结"></a>序列化和反序列化小结</h1><p>序列化是指把数据结构或对象转化为可存储或可传输的结构，这种结构可以用于重建数据结构或对象。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Json</td>
<td>文本</td>
<td>1. 人可读 2. 属性顺序对序列化反序列化无影响</td>
<td>1. 丢弃了类型信息，eg: “num”:100，这里对于num的类型信息是不可知的，解析存在二义性 2. 不支持二进制数据类型</td>
</tr>
<tr>
<td>Protobuf</td>
<td>二进制</td>
<td>性能高</td>
<td>1. 不宜读 2. 向后兼容有约定限制</td>
</tr>
</tbody></table>
<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>JSON建构于两种结构：</p>
<ul>
<li>“Key/Value”对的集合，在不同语言中，可以作为对象，字典，结构体等</li>
<li>值的有序列表。通常可以理解为数组。</li>
</ul>
<p>以上两种结构在大多数语言中都存在，所以在不同语言中使用JSON进行交流非常自然。</p>
<p>形式：</p>
<ol>
<li>对象是一个无序的’key/value’对集合。一个对象以”{“开始，”}”结束。键值对”key:value”表示。键值对之间使用”,”分隔</li>
<li>值的有序集合：一个数组以”[“开始,”]”结束，值之间使用”,”分隔</li>
<li>值value:可以为string-&gt;”abc”，number-&gt;1,Bool-&gt;true/false,null,对象或数组，同时结构可以嵌套</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>传输数据量较小，且实时性要求比较低的服务</li>
<li>JSON的前后兼容性比较强，对于接口经常变化，对可调性要求高的场景比较适合，比如移动端和服务端通讯</li>
<li>JSON的典型场景： JSON+HTTP</li>
</ol>
<p>JSON的性能和序列化的额外空间开销比较大，对于大数据量服务或持久化来说，会有巨大的开销。同时JSON本身没有使用IDL约束参与方，尽管在大多数语言中它的形式都可以兼容，但是还是会存在问题，需要通过文档方式进行约束，对调试会带来不便。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>protobuf有许多作为优秀的序列化协议的众多优点：</p>
<ol>
<li>使用了标志的IDL</li>
<li>序列化数据紧凑，空间开销小</li>
<li>序列化反序列化速度很快</li>
</ol>
<p>protobuf产生与Google，其支持多种语言，支持的数据类型相对较少，常见与一下rpc框架中使用。</p>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><p>protobuf的空间开销小，加上解析性能高，使用与RPC调用的场景。protobuf提供了标志的IDL，IDL对于各方都有比较强的约束。此外对于应用层对象持久化来说，也比较适合。</p>
<p>缺点在于调试比较麻烦</p>
<h2 id="使用ANTLR设计自己的序列化协议-TODO"><a href="#使用ANTLR设计自己的序列化协议-TODO" class="headerlink" title="使用ANTLR设计自己的序列化协议 TODO"></a>使用ANTLR设计自己的序列化协议 TODO</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MySQL - 查询优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 17:16:04 / Modified: 18:19:14" itemprop="dateCreated datePublished" datetime="2022-01-29T17:16:04+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><ol>
<li>确认程序是否在检索大量超过需要的数据</li>
<li>确认Mysql服务器是否在分析大量超过需要的数据行</li>
</ol>
<h3 id="请求了不需要的数据"><a href="#请求了不需要的数据" class="headerlink" title="请求了不需要的数据"></a>请求了不需要的数据</h3><ol>
<li>查询不需要的记录：Mysql总是先返回全部结果集再计算，最好的办法是在查询后面加上LIMIT</li>
<li>多表关联时返回全部列：只取需要的列</li>
<li>使用select *</li>
<li>重复查询相同的数据：使用缓存将数据缓存下来</li>
</ol>
<h3 id="是否在扫描额外的记录"><a href="#是否在扫描额外的记录" class="headerlink" title="是否在扫描额外的记录"></a>是否在扫描额外的记录</h3><p>衡量标准：1. 响应时间 2. 扫描的行数 3. 返回的行数 -&gt; 查询慢日志获得指标 4. 扫描的行数和访问类型 -&gt; 通过EXPLAIN语句中的type列可以获取访问类型。</p>
<p>优化思路：</p>
<ol>
<li>使用索引覆盖扫描</li>
<li>改变库表结构</li>
<li>重写复杂查询，让优化器能够以更优化的方式去执行查询</li>
</ol>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ol>
<li><p>将一个复杂查询分解为多个简单查询</p>
</li>
<li><p>切分查询：将一个重的事务分解为多个小的事务（eg：删除过期数据）</p>
</li>
<li><p>分解关联查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag JOIN tag_post WHERE tag_post.id=tag.id JOIN post ON tag_post.id=post.id </span><br><span class="line">WHERE tag.tag=&#x27;mysql&#x27;</span><br><span class="line"></span><br><span class="line">//将关联查询分解为多个单表查询，然后在业务程序再进行关联</span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456)</span><br></pre></td></tr></table></figure></li>
<li><p>Mysql客户端和服务端的通信协议: 半双工-&gt; 导致Mysql查询，需要所有的数据都接收到以后才能是否查询占用的资源。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">如何实现一个远程调用框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-27 14:45:00 / Modified: 17:09:32" itemprop="dateCreated datePublished" datetime="2022-01-27T14:45:00+08:00">2022-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何实现一个远程调用框架"><a href="#如何实现一个远程调用框架" class="headerlink" title="如何实现一个远程调用框架"></a>如何实现一个远程调用框架</h1><p>RPC框架会涉及到的内容，线程模型，通信协议设计，同步/异步调用，负载均衡等。</p>
<h2 id="RPC框架架构设计"><a href="#RPC框架架构设计" class="headerlink" title="RPC框架架构设计"></a>RPC框架架构设计</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys9sub3prj31940msabj.jpg" alt="Lark20210101-221749.png"></p>
<p>大概有三个部分的组件，1. 客户端 2. 注册中心 3. 服务端</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>使用注册中心来实现服务注册和发现的功能。</p>
<p>服务端节点上线以后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点数据移除。</p>
<p>客户端向服务端发起调用时，自己从注册中心获取到服务端的服务列表，然后通过负载均衡算法选择其中一个服务节点进行调用。</p>
<p><strong>问题</strong>：服务端节点下线时如何移除节点数据，尤其是异常下线的情况。</p>
<p>方式：主动通知+心跳检测</p>
<p>当服务端下线时会主动通知注册节点下线移除数据，同时注册中心会对服务节点进行探活。</p>
<h2 id="通信协议与序列化："><a href="#通信协议与序列化：" class="headerlink" title="通信协议与序列化："></a>通信协议与序列化：</h2><p>因为RPC框架对于性能要求较高，所以通信协议越简单越好。</p>
<p>主流的是TPC,HTTP，gRPC使用的HTTP2。需要稳定可靠的协议。</p>
<p>数据和序列化：如果是一般的框架会选用通用且高效的序列化方式，比如Json,Protocbuf等待，如果是特定场景下使用的话，可以使用特定的序列化方式，这样会更加高效。</p>
<h2 id="RPC的调用方式："><a href="#RPC的调用方式：" class="headerlink" title="RPC的调用方式："></a>RPC的调用方式：</h2><p>一般支持的调用方式：</p>
<ol>
<li>同步Sync：客户端发起RPC调用后，当前线程会一直阻塞，指定服务端返回结果或者超时。</li>
<li>异步Future：客户端发起调用以后不会阻塞等待，而是拿到RPC框架的Future对象，调用结果会被服务端缓存，客户端自行决定何时拿到返回结果，主动获取结果的过程是阻塞等待的。</li>
<li>回调Callback：客户端发起调用时，将Callback对象传递给RPC框架，无需同步等待，直接返回。当获取到服务端响应结果或者超时，再执行用户注册的Callback回调。这种Callback接口一般包含了onResponse和onException两个方法</li>
<li>单向Oneway：客户端发起请求后直接返回，忽略结果</li>
</ol>
<h2 id="线程模型："><a href="#线程模型：" class="headerlink" title="线程模型："></a>线程模型：</h2><p>使用主从Reactor线程模型，其中Boss和Worker线程池可以看做IO线程，IO线程用于处理网络数据，比如事件轮询，编解码，数据传输等。业务逻辑使用业务线程执行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gysaijfmhoj317q0onn2d.jpg" alt="Lark20210101-221822.png"></p>
<h2 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h2><p>常见的负载均衡的策略：</p>
<p><strong>Round-Robin 轮询</strong>。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</p>
<p><strong>Weighted Round-Robin 权重轮询</strong>。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</p>
<p><strong>Least Connections 最少连接数</strong>。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</p>
<p><strong>Consistent Hash 一致性 Hash</strong>。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</p>
<h2 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h2><p>RPC框架如果要做到像调用本地接口一样调用远端服务，需要创建代理对象，在代理对象中完成数据报文编码，然后发起调用数据给服务方，以此来屏蔽RPC框架的调用细节。可以通过动态代理的方式生成桩类（代理类），gRPC则是通过定义好的DSL，使用DSL来生成桩类和代理方法。</p>
<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc-facade # HelloFacade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-provider # HelloFacadeImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloFacade.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFacadeImpl</span> <span class="keyword">implements</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-consumer # HelloController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务方"><a href="#服务方" class="headerlink" title="服务方"></a>服务方</h3><ol>
<li>服务提供者启动服务，并暴露服务端口；</li>
<li>启动时扫描需要对外发布的服务，并将服务元数据信息发布到注册中心；</li>
<li>接收 RPC 请求，解码后得到请求消息；</li>
<li>提交请求至自定义线程池进行处理，并将处理结果写回客户端。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">基于线程和事件驱动的响应模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-24 20:33:09 / Modified: 21:02:52" itemprop="dateCreated datePublished" datetime="2022-01-24T20:33:09+08:00">2022-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Reactor-Pattern"><a href="#Reactor-Pattern" class="headerlink" title="Reactor Pattern"></a>Reactor Pattern</h1><p>Reactor pattern的理念:</p>
<ol>
<li>连接和线程总是存在一对一的关系。Unfortunately, there is always a one-to-one relationship between connections and threads</li>
<li>事件驱动的方法可以将线程与连接分开，它只对特定回调/处理程序的事件使用线程。Event-driven approach can separate threads from connections, which only uses threads for events on specific callbacks/handlers.</li>
<li>一个事件驱动的架构由事件的创建者和事件的消费者组成。创建者，也就是事件的源头，只知道事件发生了。消费者是需要知道事件已经发生的实体。消费者可能参与到事件处理中去，也可能只是受到事件的影响。An event-driven architecture consists of event creators and event consumers. The creator, which is the source of the event, only knows that the event has occurred. Consumers are entities that need to know the event has occurred. They may be involved in processing the event or they may simply be affected by the event.</li>
<li>反应器模式时事件驱动架构的一种实现，简单来说，它是由一个单线程的事件循环对发出事件的资源进行了阻塞并且将其分配给对应的处理程序或者回调。The reactor pattern is one implementation technique of the event-driven architecture. <strong>In simple words, it uses a single threaded event loop blocking on resources emitting events and dispatches them to corresponding handlers/callbacks.</strong></li>
<li>只有注册了处理程序和回调，就没必要阻塞IO了。事件就行传入的一个新的连接，已经可以读，可以写了<strong>There is no need to block on I/O, as long as handlers/callbacks for events are registered to take care of them.</strong> Events are like incoming a new connection, ready for read, ready for write, etc.</li>
<li>This pattern decouples modular application-level code from reusable reactor implementation.这种模式可以解耦模块化的应用级代码和可重复使用的反应器实现。</li>
<li>The purpose of the Reactor design pattern is to avoid the common problem of creating a thread for each message/request/connection.Avoid this problem is to avoid the famous and known problem C10K.反应器模式的目的是为了避免为每个消息/请求/连接创建一个线程的问题。也是为了解决C10K问题。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">MySQL高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-18 02:01:29" itemprop="dateCreated datePublished" datetime="2022-01-18T02:01:29+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-28 17:46:56" itemprop="dateModified" datetime="2022-01-28T17:46:56+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL高可用"><a href="#MySQL高可用" class="headerlink" title="MySQL高可用"></a>MySQL高可用</h1><h2 id="主备一致是如何保证的"><a href="#主备一致是如何保证的" class="headerlink" title="主备一致是如何保证的"></a>主备一致是如何保证的</h2><p>主库同步到从库的过程：</p>
<ol>
<li>主库接收到写请求以后，执行内部事务的更新逻辑，同时写binlog</li>
<li>从库和主库直接维持了一个长连接，主库A内部有一个线程，专门用于服务备库B的长连接。</li>
<li>事务日志同步：从库和主库建立好长连接后，会收到主库的binlog，存储到本地为relaylog，会有一个线程读取relaylog，解析日志里的sql命令，然后执行</li>
</ol>
<p>binlog的三种格式：</p>
<ol>
<li><p>statement</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf1oqf7jj31ga05xdhk.jpg" alt="img"></p>
<p>statement格式存储的是原始的SQL语句。</p>
<p>存在的问题：主库和从库执行同一条sql语句，可能存在结果不一致的情况。</p>
</li>
<li><p>row</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf2ifijgj31hc0et411.jpg" alt="img"></p>
<p>row格式里存储的是: Table_map, Delete_rows，row格式记录了真实删除行的主键id，也就是主库和备库最终结果是一致的</p>
</li>
<li><p>mixed</p>
<p>mixed是以上两种混合使用的结果</p>
<p>statement格式的binlog可能会造成主备不一致</p>
<p>row格式的话，会很占用空间 - 比如delete删除10万行，row格式要记录10w个记录，statement只记录一句sql</p>
<p>Mixed: 主动判断SQL语句是否可能造成主备不一致，可能就用row，否则stament</p>
</li>
<li><p>实践：设置为mixed，如果需要恢复数据的场景，则设置为row</p>
</li>
</ol>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytgdcxmwcj31hc0ig0y2.jpg" alt="img"></p>
<p>row格式中记录的信息中，bin_row_image的默认设置会存储行的所有字段的值，上面设置为只记录必要信息，只有id=4这个信息</p>
<p>所以在row格式中，可以记录所有的行的信息。</p>
<ol>
<li>delete：执行的delete语句，在row格式的binlog中，被删除的每一行的信息都会保存，既可以将删除的数据insert回去。</li>
<li>insert: insert语句，row格式的binlog会记录所有字段信息，可以用于定义刚刚插入的一行，使用delete删除即可</li>
<li>update: update语句，row格式的binlog会记录修改前的整行数据和修改后的整行数据，只需要对调前后，执行update即可</li>
</ol>
<h2 id="双主结构和循环复制"><a href="#双主结构和循环复制" class="headerlink" title="双主结构和循环复制"></a>双主结构和循环复制</h2><p>当两个库都作为主库时，会有2个长连接来保持相互同步，但是如何保证不会循环复制。这里使用serverid来做区分。</p>
<h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>数据同步的节点：</p>
<ol>
<li>主库A执行完成一个事务，写入binlog T1</li>
<li>binlog传给备库B，备库接收完这个binlog T2</li>
<li>备库B执行完成事务 T3</li>
</ol>
<p>主备延迟 = T3 - T1</p>
<p>T2 - T1 = 网络传输的时间，比较短</p>
<p>T3 - T2 = 接收完binlog并执行事务的时间（长）</p>
<p>主备延迟 约等于 T3-T2 接收完binlog，执行relaylog的速度差</p>
<p><strong>主备延迟的来源</strong>：</p>
<ol>
<li>主库机器被备库好</li>
<li>备库压力大</li>
<li>大事务 - 因为主库必须等事务执行完以后才会写入binlog，如果大事务执行时间为t1则延迟为t1</li>
<li>备库的并行复制</li>
</ol>
<h3 id="针对主备延迟带来的主备切换策略："><a href="#针对主备延迟带来的主备切换策略：" class="headerlink" title="针对主备延迟带来的主备切换策略："></a>针对主备延迟带来的主备切换策略：</h3><ol>
<li>可靠性优先策略：</li>
<li>可用性优先策略：</li>
</ol>
<h3 id="小时级的主备延迟-备库并行复制"><a href="#小时级的主备延迟-备库并行复制" class="headerlink" title="小时级的主备延迟 - 备库并行复制"></a>小时级的主备延迟 - 备库并行复制</h3><p>在备库执行日志的速度持续低于主库生成日志的速度情况下，主备延迟有可能变成小时级别。</p>
<p>为什么要多线程并行复制 - 客户端事务是可以并发的，如果备库处理relaylog是单线程的，则会导致备库执行日志速度持续低于主库生成日志，造成较长时间的主备延迟。</p>
<p>协调器 - 多工作线程的模式（同时需要保证 不能更新覆盖，不能拆同一个事务）</p>
<h3 id="一主多从的结构"><a href="#一主多从的结构" class="headerlink" title="一主多从的结构"></a>一主多从的结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytifl1yznj30vq0ns0u1.jpg" alt="img"></p>
<p>具体结构：A与A1是互为主从，B，C，D是执行A的从库，主库为WR，从库为readonly</p>
<ol>
<li><p>主库故障后的主从切换：</p>
<p>当A出错后，A1会作为新的主库，对于从库B来说需要执行change master命令，需要建立到新主库的连接并且将日志位点对齐新主库</p>
<p><strong>重点问题：日志位点很难对齐</strong></p>
<p>对于相同的日志，A和A1的位点是不同的，所以从库首先需要对齐位点</p>
<p>通用的做法是使用GTID来对齐位点：</p>
<p>GTID(Global Transaction Identifier) 是全局事务ID，是一个事务在提交时生成的</p>
<p>在开启了GTID以后，日志位点就可以自动对齐了</p>
<p><strong>流程：</strong></p>
<ol>
<li>从库B指定主库A1，基于主备协议建立连接</li>
<li>从库B把自己的GTID集合set_b发给新主库A1</li>
<li>主库A1把set_b和自己的GTID集合set_a比较，获取差集，然后看自己是否包含所有的差集</li>
<li>主库A1在binlog中找到第一个差集中的事务，然后向后顺序取binlog给B</li>
</ol>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Redis小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-13 17:59:13" itemprop="dateCreated datePublished" datetime="2022-01-13T17:59:13+08:00">2022-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-14 02:22:24" itemprop="dateModified" datetime="2022-01-14T02:22:24+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis学习小结"><a href="#Redis学习小结" class="headerlink" title="Redis学习小结"></a>Redis学习小结</h1><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7med1wej30uy0u0djk.jpg" alt="screenshot-20220113-181317" style="zoom:150%;" />

<h2 id="Redis的设计与实现"><a href="#Redis的设计与实现" class="headerlink" title="Redis的设计与实现"></a>Redis的设计与实现</h2><p>核心点：</p>
<ol>
<li>Redis的五种数据类型是由什么数据结构实现？</li>
<li>Redis的字符串类型即可以存储字符串，又可以存储整数和浮点数，甚至二进制位，Redis内部如何存储这些不同的值？</li>
<li>Redis 的一部分命令只能对特定数据类型执行（比如 APPEND 只能对字符串执行， HSET 只能对哈希表执行）， 而另一部分命令却可以对所有数据类型执行（比如 DEL 、 TYPE 和 EXPIRE ）， 不同的命令在执行时是如何进行类型检查的？ Redis 在内部是否实现了一个类型系统？</li>
<li>Redis 的数据库是怎样储存各种不同数据类型的键值对的？ 数据库里面的过期键又是怎样实现自动删除的？</li>
<li>Redis 还拥有发布与订阅、脚本、事务等特性， 这些特性又是如何实现的？</li>
<li>怎么处理客户端的命令请求？</li>
</ol>
<p>整体结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc81jn065j31hb0u0wj0.jpg" alt="img"></p>
<h2 id="K-V如何组织"><a href="#K-V如何组织" class="headerlink" title="K-V如何组织"></a>K-V如何组织</h2><p>使用的是Hash表的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8wiczbwj30lf08zgm8.jpg" alt="img"></p>
<p>问题：</p>
<ol>
<li><p>Hash冲突？ -&gt;链式解决</p>
</li>
<li><p>Rehash(分配更大的空间，减少冲突): </p>
<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 为了避免copy 过程阻塞用户请求，Redis 采用了渐进式 rehash，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，<strong>顺带着</strong>将这个索引位置上的所有 entries 拷贝到哈希表 2 中。PS：跟redis 通过用户请求顺带清理 过期数据是一样的。</li>
<li>释放哈希表 1 的空间。</li>
</ol>
</li>
<li><p>RedisObject: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount;   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;  <span class="comment">// 指向实际值的指针，可以指向不同的数据类型</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>由于Redis的数据类型很多，所以是用了一个RedisObject来做封装</p>
</li>
</ol>
<h2 id="K-V底层数据结构"><a href="#K-V底层数据结构" class="headerlink" title="K-V底层数据结构"></a>K-V底层数据结构</h2><p>Key只能为string类型，value可以为复杂类型</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8tm64v5j32t00u0jyx.jpg" alt="img"></p>
<p>压缩列表：</p>
<p>由于压缩列表节约内存，所以hash,list,sortedSet的底层实现在数据量小的时候都采用压缩列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                         ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>图中各个域的作用如下：</p>
<table>
<thead>
<tr>
<th align="left">域</th>
<th align="left">长度/类型</th>
<th align="left">域的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">到达 ziplist 表尾节点的偏移量。 通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left">ziplist 中节点的数量。 当这个值小于 <code>UINT16_MAX</code> （<code>65535</code>）时，这个值就是 ziplist 中节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left"><code>?</code></td>
<td align="left">ziplist 所保存的节点，各个节点的长度根据内容而定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>255</code> 的二进制值 <code>1111 1111</code> （<code>UINT8_MAX</code>） ，用于标记 ziplist 的末端。</td>
</tr>
</tbody></table>
<p>Entry的构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">            +------------------+----------+--------+---------+</span><br><span class="line">component   | pre_entry_length | encoding | length | content |</span><br><span class="line">            +------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis客户端与服务端使用了RESP(Redis Serialization Protocol)的二进制安全文本协议进行通信，通过TCP连接实现数据交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure>

<p>对于特定场景，使用自定义的通信协议，性能会好于通用的通信协议</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7x6r5umj30sf0fvmyj.jpg" alt="img"></p>
<h2 id="单线程的原因"><a href="#单线程的原因" class="headerlink" title="单线程的原因"></a>单线程的原因</h2><ol>
<li>只是对读写使用了单线程，底层使用了IO多路复用机制</li>
<li>单线程使用简单，并且这里主要的瓶颈不是单线程而是共享资源</li>
</ol>
<h2 id="持久化（单机高可用）"><a href="#持久化（单机高可用）" class="headerlink" title="持久化（单机高可用）"></a>持久化（单机高可用）</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7lzkw1yj31fn0u0wju.jpg" alt="screenshot-20220113-181342" style="zoom:150%;" />

<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h3><p>MySQL使用的是写前日志（WAL）。但是AOF日志是写后日志，需要Redis先执行命令，写入内存后，再记录日志。</p>
<p>优点：记录每一条命令但是不需要检查语法。AOF也不会阻塞当前命令</p>
<p>缺点：存在执行完命令没有记录日志丢失数据的风险。AOF会阻塞下一个命令执行，如果后续磁盘写压力大会导致变慢。</p>
<p>解决问题：</p>
<ol>
<li><p>丢失数据风险：提供三种配置, Always(同步写回)，EverySec(每秒写回),NO(只写到内存，有操作系统写入磁盘)</p>
</li>
<li><p>日志文件变大：使用AOF重写机制</p>
<p>AOF重写机制：</p>
<ol>
<li>执行重写是，主线程fork一个子线程，内存会拷贝一份，如何对同一键值对的反复修改的命令只保留其值即可。主线程未阻塞，仍然可以处理新来的操作。如果有写操作，除了正在写的AOF 日志，还会再写一份AOF 重写日志。等到bgrewriteaof 拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，此时，就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycbr21z07j31s40u0436.jpg" alt="img"></p>
<h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>记录某一时刻的内存中的数据，以文件的形式写到磁盘。即快照。</p>
<p>提供了两个命令生成RDB：</p>
<ol>
<li>Save: 主线程执行，会阻塞</li>
<li>Bgsave: 创建一个子进程，专门写入RDB文件，避免了主线程的阻塞，但是这样做确需要暂停写操作，可以使用Copy-On-Write，即会复制一份值用于写。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyccaxy4m4j31hc0u0ad2.jpg" alt="img"></p>
<p>快照频率使用上，频率搞了消耗大，低了数据容易丢</p>
<p>更好的应用场景：快照不频繁使用，AOF记录两次快照之间的操作。</p>
<p>因为RDB和AOF都会使用fork，<strong>fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长</strong>（所以使用RDB时，单个实例的redis 内存不宜过大）</p>
<p>同时，Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 swap 的影响，而导致性能变慢。</p>
<h2 id="主从同步（多机高可用）"><a href="#主从同步（多机高可用）" class="headerlink" title="主从同步（多机高可用）"></a>主从同步（多机高可用）</h2><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjk9u4c0j31nk0q4gru.jpg" alt="screenshot-20220114-010708"></p>
<p>Redis提供了主从库模式，主从库同步是如何完成的呢？</p>
<ol>
<li><p>第一次同步：启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，然后使用RDB进行数据同步</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjmznewtj31ve0u0q8l.jpg" alt="img"></p>
</li>
<li><p>主从级联模式：从库很多，如果都要和主库进行全量复制，就会导致主库压力大，通过“主-从-从”的模式就可以解决</p>
</li>
<li><p>主从库端口：通过增量复制的方式继续同步。主从库断连后，主库会将写操作持续写入一个buffer（注：环状）</p>
</li>
</ol>
<p>主库挂了怎么办？</p>
<p>通过哨兵机制解决：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjsvqhk5j31qs0me78h.jpg" alt="screenshot-20220114-011539"></p>
<p>哨兵是一个特殊模式下的Redis进程，主要用于：监控，选主，通知</p>
<ol>
<li>监控。周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>选主。筛选+打分，在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉（在线状态、断连次数）。然后，我们再按照一定的规则，给剩下的从库逐个打分（从库优先级、从库复制进度= master_repl_offset-slave_repl_offset 以及从库 ID 号），将得分最高的从库选为新主库。</li>
<li>通知。哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</li>
</ol>
<p>单哨兵也可能会出问题，所以可以使用哨兵集群：</p>
<h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjydb0w0j31ho0u00yi.jpg" alt="screenshot-20220114-012052"></p>
<p>当数据量变大以后，就需要扩展，如果只是单纯的扩大单个Redis的内存，会导致fork时间变长，Redis性能变差。此时需要纵向扩展。通过切片集群解决，这里即对一个K-V,先通过K找到需要保存到那个redis示例，在通过K找到在redis的hash表的存放位置。对于第一步来说，还需要考虑负载均衡的问题。</p>
<p>实际：Redis Cluster是通过Hash Slot实现的，一个环状的hash槽（16384个），通过hash算法（hash(key)%N）找到slot位置。在部署时，Redis会自动将这些槽平均到集群实例上。</p>
<p>如何知道哈希槽分布在哪个实例上？Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>当出现增删节点和负载均衡情况等变化的情况，通过重定向机制处理，即原本的实例存放了变更的位置，会通过重定向将请求发给变更的位置</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区是Redis中用于，当客户端和服务端进行通信时，暂存客户端命令或服务端结果的。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckdibgooj31880u0adf.jpg" alt="img"></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ol>
<li>对于缓存来说，淘汰策略很重要，通过时间局部性和空间局部性来保证缓存的作用</li>
<li>单范围淘汰，即对设置了过期时间的数据进行淘汰</li>
<li>全范围淘汰，按照淘汰算法对所有数据进行</li>
</ol>
<p>LRU（Redis）实现：在RedisObject中有个lru字段，保存一个数据访问的时间戳，因为数据量很大，Redis也只是抽取一定数量的数据，然后对齐按照lru的大小进行淘汰</p>
<p>LFU（Redis）实现:  也是使用RedisObject中lru字段，总共24bit，拆为16bit（时间戳）,counter(8bit)访问值（最大255）。Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。这样可以保证访问次数很大也可以进行比较，但是这样本身存在一定误差，数据量大的时候其counter值才置信。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckrc17jwj318m0hawhk.jpg" alt="screenshot-20220114-014847"></p>
<p>Redis的事务，一致性和隔离性可以保证，持久性和原子性不行。</p>
<h2 id="缓存异常问题"><a href="#缓存异常问题" class="headerlink" title="缓存异常问题"></a>缓存异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>问题：应用请求无法在Redis处理，大量的被传导到数据库了</p>
<ol>
<li>大量数据同时到期 -&gt; a. 微调时间，给业务数据加上一个小的随机数 b. 服务降级，只保证核心内容服务</li>
<li>Redis实例宕机导致 -&gt; a.进行服务熔断和请求限流 b. 建立高可靠的集群</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>问题：对于某个热点数据的访问很频繁，但是此时该数据刚好过期，导致大量请求到了数据库。</p>
<p>解决办法：对于热点数据，不设置过期时间</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>问题：要访问的数据即不在Redis缓存也不在数据库，通常由于业务层误操作或者恶意攻击导致</p>
<p>解决办法：</p>
<ol>
<li>缓存空值</li>
<li>使用Bloom Filer（一个初值全为0的数组和N个hash函数组成，对于某个值，如果存在，则使用N个hash将它的位置置为1）快速判断数据是否存在。（存在一定通过Bloom Filter，不存在大部分通不过Bloom Filter）</li>
<li>对请求进行合法校验，避免恶意请求</li>
</ol>
<h3 id="缓存与数据库数据不一致问题"><a href="#缓存与数据库数据不一致问题" class="headerlink" title="缓存与数据库数据不一致问题"></a>缓存与数据库数据不一致问题</h3><p>核心：需要保证缓存中有数据，缓存的数据必须和数据库中相同。没有数据，则数据库中必须为最新值。</p>
<p>解决办法：</p>
<p>读写缓存：同步写回</p>
<p>只读缓存：</p>
<ol>
<li>先删缓存再更新数据库：无并发，重试机制（使用消息队列保证操作成功） 并发：延迟双删（先删除缓存，再更新数据库，休眠一秒，再次删除缓存）</li>
<li>先更新数据库再删缓存（更好）：无并发，重试机制   并发：在客户端暂存并发请求</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-11 16:44:02" itemprop="dateCreated datePublished" datetime="2022-01-11T16:44:02+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-14 11:03:51" itemprop="dateModified" datetime="2022-01-14T11:03:51+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><p>在业务实现时，通常需要保证一批SQL同时具备ACID特性。</p>
<p>ACID:</p>
<ol>
<li>原子性（Atomicity）：事务内SQL要么同时成功要么同时失败 ，基于UndoLog实现。</li>
<li>一致性（Consistency）：系统从一个正确态转移到另一个正确态，由应用通过AID来保证，并非数据库的责任。</li>
<li>隔离性（Isolation）：控制事务并发执行时数据的可见性，当多个应用并发访问数据库系统时，提供了一种隔离方法，防止彼此的操作相互干扰，基于锁和MVCC实现。</li>
<li>持久性（Durability）：提交后一定存储成功不会丢失，基于RedoLog实现。</li>
</ol>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><img src="/Users/bytedance/Documents/screenshot-20220111-180509.png" alt="screenshot-20220111-180509"></p>
<p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</p>
<p>实现<strong>原子性</strong>：通过日志将所有对数据的更新操作都写入日志。如果事务一部分操作已完成又无法全部完成，则通过undolog将执行成功的操作撤销</p>
<p>实现<strong>持久性</strong>：在事务提交之前，redo log已经持久化了，对于已经执行成功未写入磁盘的操作，会通过redo log写入磁盘</p>
<p>最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重新执行所有已经执行成功，但尚未写入到磁盘的操作，保证持久性），再对所有崩溃时尚未成功提交的事务进行进行undo（撤销所有执行一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<p>Todo:</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2G_2ZYAbQIblVJY7pmrhKg">Redo Log</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427911093">Undo Log</a></p>
<h2 id="锁与MVCC"><a href="#锁与MVCC" class="headerlink" title="锁与MVCC"></a>锁与MVCC</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9w6wgo1vj313a0gwdik.jpg" alt="screenshot-20220111-180737"></p>
<p>隔离性: 数据库允许多个并发事务同时对数据进⾏读写和修改的能⼒，且互相不影响，看起来像串⾏执⾏⼀样， 并不会出现由于事务交叉执⾏⽽导致的数据不⼀致</p>
<p>如何判断一个事务调度是正确的：⼀个并发事务的调度执⾏结果能和多种串⾏执⾏的其中⼀个结果相等，我们认为这是⼀个正确的调度， 称之为serializable schedule</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybvcdykimj31t40p8dlc.jpg" alt="screenshot-20220113-110918"></p>
<p>应该满足A+B = 2120</p>
<p>隔离级别：</p>
<p><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</p>
<p><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read 不可重复读是读取了其他事务更改的数据，<strong>针对update操作</strong>）；</p>
<p><code>REPEATABLE READ</code>：加记录锁和间隙锁。多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（读取了其他事务新增的数据，<strong>针对insert和delete操作</strong>）；</p>
<p><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</p>
<p>并发产⽣的异象，本质上是出现了冲突：</p>
<ul>
<li>W-W冲突：两个事务先后修改了同⼀个数据库的相同object </li>
<li> W-R冲突：⼀个事务T1修改某个object后(未提交)，另⼀个事务T2对改object进⾏了读操作 </li>
<li> R-W冲突：⼀个事务T1读取了某个object或者某个range后，另⼀个事务T2对object或者range进⾏了修改</li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybw8bsdt3j31gs0i475x.jpg" alt="screenshot-20220113-113925"></p>
<ol>
<li><p>2PL - 读写锁</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwb7pt63j30k60riq50.jpg" alt="screenshot-20220113-114256" style="zoom: 50%;" />

<p>可能发生死锁。需要进行死锁检测或死锁预防</p>
</li>
<li><p>T/O - T/O的核⼼思想就是利⽤时间戳来决定事务之间的等价执⾏顺序：如果TS(Ti) &lt; TS(Tj)，那么数据库必须保证实际的 schedule先执⾏Ti，后执⾏Tj的结果等价。</p>
</li>
<li><p>OCC - todo</p>
</li>
<li><p>MV2PL:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwip4vkwj31rc0u045v.jpg" alt="screenshot-20220113-114917"></p>
</li>
<li><p>MVTO - todo</p>
</li>
<li><p>MVOCC - todo</p>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>为了提⾼数据库的并发性能，⼈们提出了MVCC(Multi-Version Concurrency Control)来实现读写互不阻塞，从⽽提⾼数据 库的并发性能</p>
<p>MySQL实现的是多版本的两阶段锁协议(Multiversion 2PL)将MVCC和2PL结合。每一个版本的数据行都有一个唯一的时间戳。</p>
<p>读事务：从多个（可见（时间戳早于当前事务））版本的数据项中返回具有最大时间戳的</p>
<p>更新操作：读取最新版本（可见）的数据计算更新的结果，然后创建一个新版本的数据，新数据的时间戳为当前数据行的最大版本+1</p>
<p>删除操作：MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">锁与MVCC</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">系统监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-11 00:26:10 / Modified: 00:35:15" itemprop="dateCreated datePublished" datetime="2022-01-11T00:26:10+08:00">2022-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go系统监控的设计和实现原理"><a href="#Go系统监控的设计和实现原理" class="headerlink" title="Go系统监控的设计和实现原理"></a>Go系统监控的设计和实现原理</h1><p>守护进程：后台运行的计算机程序，有操作系统启动，会在整个系统的生命周期存在，随着系统的启动而启动，系统的结束而结束。</p>
<p>Go的系统监控，会在内部启动一个不会中止的循环，循环内部进行网络轮询，抢占长期运行或者处于系统调用的Goroutine以及触发垃圾回收</p>
<h2 id="监控循环"><a href="#监控循环" class="headerlink" title="监控循环"></a>监控循环</h2><p>启动时机：main函数进入时会通过系统调用创建一个新线程并启动系统监控（sysmon）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead() <span class="comment">//检查是否存在死锁</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//监控循环</span></span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123;</span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123;</span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123;</span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay) <span class="comment">//挂起当前线程</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序稳定后，系统监控会每10ms触发一次，完成如下工作:</p>
<ul>
<li><p>运行计时器 — 获取下一个需要被触发的计时器；</p>
</li>
<li><p>轮询网络 — 获取需要处理的到期文件描述符；</p>
</li>
<li><p>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</p>
</li>
<li><p>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</p>
</li>
</ul>
<h3 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h3><h3 id="轮询网络"><a href="#轮询网络" class="headerlink" title="轮询网络"></a>轮询网络</h3><h3 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/" class="post-title-link" itemprop="url">网络轮询器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-10 00:37:38 / Modified: 02:30:20" itemprop="dateCreated datePublished" datetime="2022-01-10T00:37:38+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO与网络轮询器"><a href="#IO与网络轮询器" class="headerlink" title="IO与网络轮询器"></a>IO与网络轮询器</h1><p>如今的大部分服务都是I/O密集型的，应用会花费大量的时间等待I/O操作完成。Go使用了网络轮询器用于处理I/O操作，底层使用了操作系统的多路复用机制epoll</p>
<p>通常的IO多路模型是通过回调机制进行控制的，Go的话将其隐藏在了runtime中了，Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以“block I/O”的方式对待socket处理即可。</p>
<h2 id="原理和前言"><a href="#原理和前言" class="headerlink" title="原理和前言"></a>原理和前言</h2><p>作用：监控网络I/O，文件I/O</p>
<p>I/O模型“</p>
<h3 id="阻塞I-O模型："><a href="#阻塞I-O模型：" class="headerlink" title="阻塞I/O模型："></a>阻塞I/O模型：</h3><h3 id="非阻塞I-O模型："><a href="#非阻塞I-O模型：" class="headerlink" title="非阻塞I/O模型："></a>非阻塞I/O模型：</h3><h3 id="I-O多路复用："><a href="#I-O多路复用：" class="headerlink" title="I/O多路复用："></a>I/O多路复用：</h3><h2 id="网络轮询器："><a href="#网络轮询器：" class="headerlink" title="网络轮询器："></a>网络轮询器：</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#662-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">网络轮询器</a></p>
<ol>
<li>多路复用依赖于epoll 机制</li>
<li>epoll 机制包含两个fd:epfd 和 待读写数据的fd（比如socket）。先创建efpd，然后向epfd 注册fd事件， 之后触发epoll_wait 轮询注册在epfd 的fd 事件发生了没有。</li>
<li>netpoller 负责将 操作系统 提供的nio 转换为 goroutine 支持的blocking io。为屏蔽linux、windows 等底层nio 接口的差异，netpoller 定义一个虚拟接口来封装底层接口。</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span> //单例，初始化轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span> //监听<span class="title">FD</span>的事件，创建事件并加入监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="keyword">int64</span>)</span> <span class="title">gList</span> //轮询网络并返回一组已经准备就绪的<span class="title">Goroutine</span> &lt;0 无限期等待 =0 非阻塞轮询 &gt;0 阻塞特定时间轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span> //中断轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">bool</span> //判断<span class="title">FD</span>是否被轮询器使用</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7xf9y6qzj30xj08caae.jpg" alt="poll-desc-list"></p>
<p>pollCache是一个运行时包的全局变量，包含一个互斥锁和一个链表（pollDesc链表),pollDesc是对fd的封装</p>
<p>初始化和释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">alloc</span><span class="params">()</span> *<span class="title">pollDesc</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123; <span class="comment">//初次初始化时，会进行批量初始化以增加吞吐量</span></span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			pd.link = c.first</span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pd := c.first <span class="comment">//返回的是链表头的没有使用过的pollDesc</span></span><br><span class="line">	c.first = pd.link</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经用过的pollDesc会在运行时调用free释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">free</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	pd.link = c.first <span class="comment">//释放时将其出队</span></span><br><span class="line">	c.first = pd</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="网络轮询器的初始化"><a href="#网络轮询器的初始化" class="headerlink" title="网络轮询器的初始化"></a>网络轮询器的初始化</h4><p>调用 <code>internal/poll.pollDesc.init</code> 初始化文件描述符时不止会初始化网络轮询器，会通过 <code>runtime.poll_runtime_pollOpen</code> 函数重置轮询信息 <code>runtime.pollDesc</code> 并调用 <code>runtime.netpollopen</code> 初始化轮询事件。<code>runtime.netpollopen</code> 会调用 epollctl 向全局的轮询文件描述符 epfd 中加入新的轮询事件监听文件描述符的可读和可写状态</p>
<h4 id="如何向网络轮询器加入待监控的任务"><a href="#如何向网络轮询器加入待监控的任务" class="headerlink" title="如何向网络轮询器加入待监控的任务"></a>如何向网络轮询器加入待监控的任务</h4><h4 id="如何从网络轮询器获取触发的事件"><a href="#如何从网络轮询器获取触发的事件" class="headerlink" title="如何从网络轮询器获取触发的事件"></a>如何从网络轮询器获取触发的事件</h4><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ol>
<li><p>等待事件：在fd执行读写操作，如果fd不可读或者不可写，当前Goroutine会执行pollWait让出线程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg <span class="comment">//检查pollDesc状态</span></span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123; </span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>) <span class="comment">//让出当前线程，Goroutine转换到休眠状态并等待运行时唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>轮询等待</p>
<p>Go的runtime会在调度或系统监控中调用netpoll轮询网络</p>
<p>步骤：</p>
<ul>
<li>根据传入的delay计算epoll系统调用需要等待的时间</li>
<li>调用epollwait等待可读或可写事件</li>
<li>在循环中依次处理epollevent事件</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms) <span class="comment">//等待fd可读或可写</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123; <span class="comment">//epoll返回负值，返回空gList或者重试</span></span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//如果大于0，则在循环中处理事件</span></span><br><span class="line"><span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">    <span class="comment">//netpollBreak的事件，中断网络轮询器</span></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的读写事件，通过netpollready进行处理</span></span><br><span class="line">		<span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.everr = <span class="literal">false</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>) <span class="comment">//将pd中的读写信号转换为pdReady，并返回pd的Goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg) <span class="comment">//加入待执行列表，Goroutine列表会被加入到处理器或者全局运行队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="截止日期"><a href="#截止日期" class="headerlink" title="截止日期"></a>截止日期</h4><p>计时器依赖于网络轮询器唤醒，文件和网络I/O的截止日期也由其负责处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于设置截止日期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="keyword">int64</span>, mode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">	<span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">		d += nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">	pd.rd = d <span class="comment">//先使用截止日期计算过期的时间点</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> pd.rt.f == <span class="literal">nil</span> &#123; <span class="comment">//如果没有设置执行的函数</span></span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">			pd.rt.f = netpollReadDeadline  <span class="comment">//设置计时器到期执行的函数</span></span><br><span class="line">			pd.rt.arg = pd</span><br><span class="line">			pd.rt.seq = pd.rseq</span><br><span class="line">			resettimer(&amp;pd.rt, pd.rd) <span class="comment">//重置计时器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 &#123; <span class="comment">//如果截止日期已改变</span></span><br><span class="line">		pd.rseq++</span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123; <span class="comment">//新截止日期 &gt; 0 ，修改计时器</span></span><br><span class="line">			modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//新日期 &lt; 0 ，删除计时器, 并会在后面直接唤醒对应的Goroutine</span></span><br><span class="line">			deltimer(&amp;pd.rt)</span><br><span class="line">			pd.rt.f = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行时会在计时器到期时调用netpolldeadlineimpl,直接使用netpollgoready唤醒对应的Goroutine，Goroutine被唤醒后，会意识到当前I/O操作已经超时，选择重试或者终止调用</p>
<h2 id="IO前后的GPM"><a href="#IO前后的GPM" class="headerlink" title="IO前后的GPM"></a>IO前后的GPM</h2><ol>
<li>G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zf09e2xj30h508vmxk.jpg" alt="img"></p>
<ol start="2">
<li><p>G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zgho21oj313f0krmyp.jpg" alt="img"></p>
</li>
<li><p>异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环/eventloop。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zh0rzj3j30if09kt94.jpg" alt="img"></p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>网络轮询器并不是一个独立运行的，调度器和系统调用都会通过netpoll与网络循环器交换信息，获取待执行的GoRoutine列表，并将待执行的Goroutine加入运行队列等待处理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/zhongsongzhi97.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
