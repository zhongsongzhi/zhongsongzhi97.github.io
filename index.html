<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Redis小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-13 17:59:13" itemprop="dateCreated datePublished" datetime="2022-01-13T17:59:13+08:00">2022-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-14 02:22:24" itemprop="dateModified" datetime="2022-01-14T02:22:24+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis学习小结"><a href="#Redis学习小结" class="headerlink" title="Redis学习小结"></a>Redis学习小结</h1><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7med1wej30uy0u0djk.jpg" alt="screenshot-20220113-181317" style="zoom:150%;" />

<h2 id="Redis的设计与实现"><a href="#Redis的设计与实现" class="headerlink" title="Redis的设计与实现"></a>Redis的设计与实现</h2><p>核心点：</p>
<ol>
<li>Redis的五种数据类型是由什么数据结构实现？</li>
<li>Redis的字符串类型即可以存储字符串，又可以存储整数和浮点数，甚至二进制位，Redis内部如何存储这些不同的值？</li>
<li>Redis 的一部分命令只能对特定数据类型执行（比如 APPEND 只能对字符串执行， HSET 只能对哈希表执行）， 而另一部分命令却可以对所有数据类型执行（比如 DEL 、 TYPE 和 EXPIRE ）， 不同的命令在执行时是如何进行类型检查的？ Redis 在内部是否实现了一个类型系统？</li>
<li>Redis 的数据库是怎样储存各种不同数据类型的键值对的？ 数据库里面的过期键又是怎样实现自动删除的？</li>
<li>Redis 还拥有发布与订阅、脚本、事务等特性， 这些特性又是如何实现的？</li>
<li>怎么处理客户端的命令请求？</li>
</ol>
<p>整体结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc81jn065j31hb0u0wj0.jpg" alt="img"></p>
<h2 id="K-V如何组织"><a href="#K-V如何组织" class="headerlink" title="K-V如何组织"></a>K-V如何组织</h2><p>使用的是Hash表的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8wiczbwj30lf08zgm8.jpg" alt="img"></p>
<p>问题：</p>
<ol>
<li><p>Hash冲突？ -&gt;链式解决</p>
</li>
<li><p>Rehash(分配更大的空间，减少冲突): </p>
<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 为了避免copy 过程阻塞用户请求，Redis 采用了渐进式 rehash，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，<strong>顺带着</strong>将这个索引位置上的所有 entries 拷贝到哈希表 2 中。PS：跟redis 通过用户请求顺带清理 过期数据是一样的。</li>
<li>释放哈希表 1 的空间。</li>
</ol>
</li>
<li><p>RedisObject: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount;   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;  <span class="comment">// 指向实际值的指针，可以指向不同的数据类型</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>由于Redis的数据类型很多，所以是用了一个RedisObject来做封装</p>
</li>
</ol>
<h2 id="K-V底层数据结构"><a href="#K-V底层数据结构" class="headerlink" title="K-V底层数据结构"></a>K-V底层数据结构</h2><p>Key只能为string类型，value可以为复杂类型</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8tm64v5j32t00u0jyx.jpg" alt="img"></p>
<p>压缩列表：</p>
<p>由于压缩列表节约内存，所以hash,list,sortedSet的底层实现在数据量小的时候都采用压缩列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                         ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>图中各个域的作用如下：</p>
<table>
<thead>
<tr>
<th align="left">域</th>
<th align="left">长度/类型</th>
<th align="left">域的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">到达 ziplist 表尾节点的偏移量。 通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left">ziplist 中节点的数量。 当这个值小于 <code>UINT16_MAX</code> （<code>65535</code>）时，这个值就是 ziplist 中节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left"><code>?</code></td>
<td align="left">ziplist 所保存的节点，各个节点的长度根据内容而定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>255</code> 的二进制值 <code>1111 1111</code> （<code>UINT8_MAX</code>） ，用于标记 ziplist 的末端。</td>
</tr>
</tbody></table>
<p>Entry的构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">            +------------------+----------+--------+---------+</span><br><span class="line">component   | pre_entry_length | encoding | length | content |</span><br><span class="line">            +------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis客户端与服务端使用了RESP(Redis Serialization Protocol)的二进制安全文本协议进行通信，通过TCP连接实现数据交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure>

<p>对于特定场景，使用自定义的通信协议，性能会好于通用的通信协议</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7x6r5umj30sf0fvmyj.jpg" alt="img"></p>
<h2 id="单线程的原因"><a href="#单线程的原因" class="headerlink" title="单线程的原因"></a>单线程的原因</h2><ol>
<li>只是对读写使用了单线程，底层使用了IO多路复用机制</li>
<li>单线程使用简单，并且这里主要的瓶颈不是单线程而是共享资源</li>
</ol>
<h2 id="持久化（单机高可用）"><a href="#持久化（单机高可用）" class="headerlink" title="持久化（单机高可用）"></a>持久化（单机高可用）</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7lzkw1yj31fn0u0wju.jpg" alt="screenshot-20220113-181342" style="zoom:150%;" />

<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h3><p>MySQL使用的是写前日志（WAL）。但是AOF日志是写后日志，需要Redis先执行命令，写入内存后，再记录日志。</p>
<p>优点：记录每一条命令但是不需要检查语法。AOF也不会阻塞当前命令</p>
<p>缺点：存在执行完命令没有记录日志丢失数据的风险。AOF会阻塞下一个命令执行，如果后续磁盘写压力大会导致变慢。</p>
<p>解决问题：</p>
<ol>
<li><p>丢失数据风险：提供三种配置, Always(同步写回)，EverySec(每秒写回),NO(只写到内存，有操作系统写入磁盘)</p>
</li>
<li><p>日志文件变大：使用AOF重写机制</p>
<p>AOF重写机制：</p>
<ol>
<li>执行重写是，主线程fork一个子线程，内存会拷贝一份，如何对同一键值对的反复修改的命令只保留其值即可。主线程未阻塞，仍然可以处理新来的操作。如果有写操作，除了正在写的AOF 日志，还会再写一份AOF 重写日志。等到bgrewriteaof 拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，此时，就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycbr21z07j31s40u0436.jpg" alt="img"></p>
<h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>记录某一时刻的内存中的数据，以文件的形式写到磁盘。即快照。</p>
<p>提供了两个命令生成RDB：</p>
<ol>
<li>Save: 主线程执行，会阻塞</li>
<li>Bgsave: 创建一个子进程，专门写入RDB文件，避免了主线程的阻塞，但是这样做确需要暂停写操作，可以使用Copy-On-Write，即会复制一份值用于写。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyccaxy4m4j31hc0u0ad2.jpg" alt="img"></p>
<p>快照频率使用上，频率搞了消耗大，低了数据容易丢</p>
<p>更好的应用场景：快照不频繁使用，AOF记录两次快照之间的操作。</p>
<p>因为RDB和AOF都会使用fork，<strong>fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长</strong>（所以使用RDB时，单个实例的redis 内存不宜过大）</p>
<p>同时，Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 swap 的影响，而导致性能变慢。</p>
<h2 id="主从同步（多机高可用）"><a href="#主从同步（多机高可用）" class="headerlink" title="主从同步（多机高可用）"></a>主从同步（多机高可用）</h2><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjk9u4c0j31nk0q4gru.jpg" alt="screenshot-20220114-010708"></p>
<p>Redis提供了主从库模式，主从库同步是如何完成的呢？</p>
<ol>
<li><p>第一次同步：启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，然后使用RDB进行数据同步</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjmznewtj31ve0u0q8l.jpg" alt="img"></p>
</li>
<li><p>主从级联模式：从库很多，如果都要和主库进行全量复制，就会导致主库压力大，通过“主-从-从”的模式就可以解决</p>
</li>
<li><p>主从库端口：通过增量复制的方式继续同步。主从库断连后，主库会将写操作持续写入一个buffer（注：环状）</p>
</li>
</ol>
<p>主库挂了怎么办？</p>
<p>通过哨兵机制解决：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjsvqhk5j31qs0me78h.jpg" alt="screenshot-20220114-011539"></p>
<p>哨兵是一个特殊模式下的Redis进程，主要用于：监控，选主，通知</p>
<ol>
<li>监控。周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>选主。筛选+打分，在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉（在线状态、断连次数）。然后，我们再按照一定的规则，给剩下的从库逐个打分（从库优先级、从库复制进度= master_repl_offset-slave_repl_offset 以及从库 ID 号），将得分最高的从库选为新主库。</li>
<li>通知。哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</li>
</ol>
<p>单哨兵也可能会出问题，所以可以使用哨兵集群：</p>
<h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjydb0w0j31ho0u00yi.jpg" alt="screenshot-20220114-012052"></p>
<p>当数据量变大以后，就需要扩展，如果只是单纯的扩大单个Redis的内存，会导致fork时间变长，Redis性能变差。此时需要纵向扩展。通过切片集群解决，这里即对一个K-V,先通过K找到需要保存到那个redis示例，在通过K找到在redis的hash表的存放位置。对于第一步来说，还需要考虑负载均衡的问题。</p>
<p>实际：Redis Cluster是通过Hash Slot实现的，一个环状的hash槽（16384个），通过hash算法（hash(key)%N）找到slot位置。在部署时，Redis会自动将这些槽平均到集群实例上。</p>
<p>如何知道哈希槽分布在哪个实例上？Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>当出现增删节点和负载均衡情况等变化的情况，通过重定向机制处理，即原本的实例存放了变更的位置，会通过重定向将请求发给变更的位置</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区是Redis中用于，当客户端和服务端进行通信时，暂存客户端命令或服务端结果的。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckdibgooj31880u0adf.jpg" alt="img"></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ol>
<li>对于缓存来说，淘汰策略很重要，通过时间局部性和空间局部性来保证缓存的作用</li>
<li>单范围淘汰，即对设置了过期时间的数据进行淘汰</li>
<li>全范围淘汰，按照淘汰算法对所有数据进行</li>
</ol>
<p>LRU（Redis）实现：在RedisObject中有个lru字段，保存一个数据访问的时间戳，因为数据量很大，Redis也只是抽取一定数量的数据，然后对齐按照lru的大小进行淘汰</p>
<p>LFU（Redis）实现:  也是使用RedisObject中lru字段，总共24bit，拆为16bit（时间戳）,counter(8bit)访问值（最大255）。Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。这样可以保证访问次数很大也可以进行比较，但是这样本身存在一定误差，数据量大的时候其counter值才置信。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckrc17jwj318m0hawhk.jpg" alt="screenshot-20220114-014847"></p>
<p>Redis的事务，一致性和隔离性可以保证，持久性和原子性不行。</p>
<h2 id="缓存异常问题"><a href="#缓存异常问题" class="headerlink" title="缓存异常问题"></a>缓存异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>问题：应用请求无法在Redis处理，大量的被传导到数据库了</p>
<ol>
<li>大量数据同时到期 -&gt; a. 微调时间，给业务数据加上一个小的随机数 b. 服务降级，只保证核心内容服务</li>
<li>Redis实例宕机导致 -&gt; a.进行服务熔断和请求限流 b. 建立高可靠的集群</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>问题：对于某个热点数据的访问很频繁，但是此时该数据刚好过期，导致大量请求到了数据库。</p>
<p>解决办法：对于热点数据，不设置过期时间</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>问题：要访问的数据即不在Redis缓存也不在数据库，通常由于业务层误操作或者恶意攻击导致</p>
<p>解决办法：</p>
<ol>
<li>缓存空值</li>
<li>使用Bloom Filer（一个初值全为0的数组和N个hash函数组成，对于某个值，如果存在，则使用N个hash将它的位置置为1）快速判断数据是否存在。（存在一定通过Bloom Filter，不存在大部分通不过Bloom Filter）</li>
<li>对请求进行合法校验，避免恶意请求</li>
</ol>
<h3 id="缓存与数据库数据不一致问题"><a href="#缓存与数据库数据不一致问题" class="headerlink" title="缓存与数据库数据不一致问题"></a>缓存与数据库数据不一致问题</h3><p>核心：需要保证缓存中有数据，缓存的数据必须和数据库中相同。没有数据，则数据库中必须为最新值。</p>
<p>解决办法：</p>
<p>读写缓存：同步写回</p>
<p>只读缓存：</p>
<ol>
<li>先删缓存再更新数据库：无并发，重试机制（使用消息队列保证操作成功） 并发：延迟双删（先删除缓存，再更新数据库，休眠一秒，再次删除缓存）</li>
<li>先更新数据库再删缓存（更好）：无并发，重试机制   并发：在客户端暂存并发请求</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-11 16:44:02" itemprop="dateCreated datePublished" datetime="2022-01-11T16:44:02+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-14 11:03:51" itemprop="dateModified" datetime="2022-01-14T11:03:51+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><p>在业务实现时，通常需要保证一批SQL同时具备ACID特性。</p>
<p>ACID:</p>
<ol>
<li>原子性（Atomicity）：事务内SQL要么同时成功要么同时失败 ，基于UndoLog实现。</li>
<li>一致性（Consistency）：系统从一个正确态转移到另一个正确态，由应用通过AID来保证，并非数据库的责任。</li>
<li>隔离性（Isolation）：控制事务并发执行时数据的可见性，当多个应用并发访问数据库系统时，提供了一种隔离方法，防止彼此的操作相互干扰，基于锁和MVCC实现。</li>
<li>持久性（Durability）：提交后一定存储成功不会丢失，基于RedoLog实现。</li>
</ol>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><img src="/Users/bytedance/Documents/screenshot-20220111-180509.png" alt="screenshot-20220111-180509"></p>
<p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</p>
<p>实现<strong>原子性</strong>：通过日志将所有对数据的更新操作都写入日志。如果事务一部分操作已完成又无法全部完成，则通过undolog将执行成功的操作撤销</p>
<p>实现<strong>持久性</strong>：在事务提交之前，redo log已经持久化了，对于已经执行成功未写入磁盘的操作，会通过redo log写入磁盘</p>
<p>最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重新执行所有已经执行成功，但尚未写入到磁盘的操作，保证持久性），再对所有崩溃时尚未成功提交的事务进行进行undo（撤销所有执行一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<p>Todo:</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2G_2ZYAbQIblVJY7pmrhKg">Redo Log</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427911093">Undo Log</a></p>
<h2 id="锁与MVCC"><a href="#锁与MVCC" class="headerlink" title="锁与MVCC"></a>锁与MVCC</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9w6wgo1vj313a0gwdik.jpg" alt="screenshot-20220111-180737"></p>
<p>隔离性: 数据库允许多个并发事务同时对数据进⾏读写和修改的能⼒，且互相不影响，看起来像串⾏执⾏⼀样， 并不会出现由于事务交叉执⾏⽽导致的数据不⼀致</p>
<p>如何判断一个事务调度是正确的：⼀个并发事务的调度执⾏结果能和多种串⾏执⾏的其中⼀个结果相等，我们认为这是⼀个正确的调度， 称之为serializable schedule</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybvcdykimj31t40p8dlc.jpg" alt="screenshot-20220113-110918"></p>
<p>应该满足A+B = 2120</p>
<p>隔离级别：</p>
<p><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</p>
<p><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read 不可重复读是读取了其他事务更改的数据，<strong>针对update操作</strong>）；</p>
<p><code>REPEATABLE READ</code>：加记录锁和间隙锁。多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（读取了其他事务新增的数据，<strong>针对insert和delete操作</strong>）；</p>
<p><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</p>
<p>并发产⽣的异象，本质上是出现了冲突：</p>
<ul>
<li>W-W冲突：两个事务先后修改了同⼀个数据库的相同object </li>
<li> W-R冲突：⼀个事务T1修改某个object后(未提交)，另⼀个事务T2对改object进⾏了读操作 </li>
<li> R-W冲突：⼀个事务T1读取了某个object或者某个range后，另⼀个事务T2对object或者range进⾏了修改</li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybw8bsdt3j31gs0i475x.jpg" alt="screenshot-20220113-113925"></p>
<ol>
<li><p>2PL - 读写锁</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwb7pt63j30k60riq50.jpg" alt="screenshot-20220113-114256" style="zoom: 50%;" />

<p>可能发生死锁。需要进行死锁检测或死锁预防</p>
</li>
<li><p>T/O - T/O的核⼼思想就是利⽤时间戳来决定事务之间的等价执⾏顺序：如果TS(Ti) &lt; TS(Tj)，那么数据库必须保证实际的 schedule先执⾏Ti，后执⾏Tj的结果等价。</p>
</li>
<li><p>OCC - todo</p>
</li>
<li><p>MV2PL:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwip4vkwj31rc0u045v.jpg" alt="screenshot-20220113-114917"></p>
</li>
<li><p>MVTO - todo</p>
</li>
<li><p>MVOCC - todo</p>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>为了提⾼数据库的并发性能，⼈们提出了MVCC(Multi-Version Concurrency Control)来实现读写互不阻塞，从⽽提⾼数据 库的并发性能</p>
<p>MySQL实现的是多版本的两阶段锁协议(Multiversion 2PL)将MVCC和2PL结合。每一个版本的数据行都有一个唯一的时间戳。</p>
<p>读事务：从多个（可见（时间戳早于当前事务））版本的数据项中返回具有最大时间戳的</p>
<p>更新操作：读取最新版本（可见）的数据计算更新的结果，然后创建一个新版本的数据，新数据的时间戳为当前数据行的最大版本+1</p>
<p>删除操作：MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">锁与MVCC</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">系统监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-11 00:26:10 / Modified: 00:35:15" itemprop="dateCreated datePublished" datetime="2022-01-11T00:26:10+08:00">2022-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go系统监控的设计和实现原理"><a href="#Go系统监控的设计和实现原理" class="headerlink" title="Go系统监控的设计和实现原理"></a>Go系统监控的设计和实现原理</h1><p>守护进程：后台运行的计算机程序，有操作系统启动，会在整个系统的生命周期存在，随着系统的启动而启动，系统的结束而结束。</p>
<p>Go的系统监控，会在内部启动一个不会中止的循环，循环内部进行网络轮询，抢占长期运行或者处于系统调用的Goroutine以及触发垃圾回收</p>
<h2 id="监控循环"><a href="#监控循环" class="headerlink" title="监控循环"></a>监控循环</h2><p>启动时机：main函数进入时会通过系统调用创建一个新线程并启动系统监控（sysmon）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead() <span class="comment">//检查是否存在死锁</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//监控循环</span></span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123;</span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123;</span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123;</span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay) <span class="comment">//挂起当前线程</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序稳定后，系统监控会每10ms触发一次，完成如下工作:</p>
<ul>
<li><p>运行计时器 — 获取下一个需要被触发的计时器；</p>
</li>
<li><p>轮询网络 — 获取需要处理的到期文件描述符；</p>
</li>
<li><p>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</p>
</li>
<li><p>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</p>
</li>
</ul>
<h3 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h3><h3 id="轮询网络"><a href="#轮询网络" class="headerlink" title="轮询网络"></a>轮询网络</h3><h3 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/" class="post-title-link" itemprop="url">网络轮询器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-10 00:37:38 / Modified: 02:30:20" itemprop="dateCreated datePublished" datetime="2022-01-10T00:37:38+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO与网络轮询器"><a href="#IO与网络轮询器" class="headerlink" title="IO与网络轮询器"></a>IO与网络轮询器</h1><p>如今的大部分服务都是I/O密集型的，应用会花费大量的时间等待I/O操作完成。Go使用了网络轮询器用于处理I/O操作，底层使用了操作系统的多路复用机制epoll</p>
<p>通常的IO多路模型是通过回调机制进行控制的，Go的话将其隐藏在了runtime中了，Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以“block I/O”的方式对待socket处理即可。</p>
<h2 id="原理和前言"><a href="#原理和前言" class="headerlink" title="原理和前言"></a>原理和前言</h2><p>作用：监控网络I/O，文件I/O</p>
<p>I/O模型“</p>
<h3 id="阻塞I-O模型："><a href="#阻塞I-O模型：" class="headerlink" title="阻塞I/O模型："></a>阻塞I/O模型：</h3><h3 id="非阻塞I-O模型："><a href="#非阻塞I-O模型：" class="headerlink" title="非阻塞I/O模型："></a>非阻塞I/O模型：</h3><h3 id="I-O多路复用："><a href="#I-O多路复用：" class="headerlink" title="I/O多路复用："></a>I/O多路复用：</h3><h2 id="网络轮询器："><a href="#网络轮询器：" class="headerlink" title="网络轮询器："></a>网络轮询器：</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#662-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">网络轮询器</a></p>
<ol>
<li>多路复用依赖于epoll 机制</li>
<li>epoll 机制包含两个fd:epfd 和 待读写数据的fd（比如socket）。先创建efpd，然后向epfd 注册fd事件， 之后触发epoll_wait 轮询注册在epfd 的fd 事件发生了没有。</li>
<li>netpoller 负责将 操作系统 提供的nio 转换为 goroutine 支持的blocking io。为屏蔽linux、windows 等底层nio 接口的差异，netpoller 定义一个虚拟接口来封装底层接口。</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span> //单例，初始化轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span> //监听<span class="title">FD</span>的事件，创建事件并加入监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="keyword">int64</span>)</span> <span class="title">gList</span> //轮询网络并返回一组已经准备就绪的<span class="title">Goroutine</span> &lt;0 无限期等待 =0 非阻塞轮询 &gt;0 阻塞特定时间轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span> //中断轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">bool</span> //判断<span class="title">FD</span>是否被轮询器使用</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7xf9y6qzj30xj08caae.jpg" alt="poll-desc-list"></p>
<p>pollCache是一个运行时包的全局变量，包含一个互斥锁和一个链表（pollDesc链表),pollDesc是对fd的封装</p>
<p>初始化和释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">alloc</span><span class="params">()</span> *<span class="title">pollDesc</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123; <span class="comment">//初次初始化时，会进行批量初始化以增加吞吐量</span></span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			pd.link = c.first</span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pd := c.first <span class="comment">//返回的是链表头的没有使用过的pollDesc</span></span><br><span class="line">	c.first = pd.link</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经用过的pollDesc会在运行时调用free释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">free</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	pd.link = c.first <span class="comment">//释放时将其出队</span></span><br><span class="line">	c.first = pd</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="网络轮询器的初始化"><a href="#网络轮询器的初始化" class="headerlink" title="网络轮询器的初始化"></a>网络轮询器的初始化</h4><p>调用 <code>internal/poll.pollDesc.init</code> 初始化文件描述符时不止会初始化网络轮询器，会通过 <code>runtime.poll_runtime_pollOpen</code> 函数重置轮询信息 <code>runtime.pollDesc</code> 并调用 <code>runtime.netpollopen</code> 初始化轮询事件。<code>runtime.netpollopen</code> 会调用 epollctl 向全局的轮询文件描述符 epfd 中加入新的轮询事件监听文件描述符的可读和可写状态</p>
<h4 id="如何向网络轮询器加入待监控的任务"><a href="#如何向网络轮询器加入待监控的任务" class="headerlink" title="如何向网络轮询器加入待监控的任务"></a>如何向网络轮询器加入待监控的任务</h4><h4 id="如何从网络轮询器获取触发的事件"><a href="#如何从网络轮询器获取触发的事件" class="headerlink" title="如何从网络轮询器获取触发的事件"></a>如何从网络轮询器获取触发的事件</h4><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ol>
<li><p>等待事件：在fd执行读写操作，如果fd不可读或者不可写，当前Goroutine会执行pollWait让出线程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg <span class="comment">//检查pollDesc状态</span></span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123; </span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>) <span class="comment">//让出当前线程，Goroutine转换到休眠状态并等待运行时唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>轮询等待</p>
<p>Go的runtime会在调度或系统监控中调用netpoll轮询网络</p>
<p>步骤：</p>
<ul>
<li>根据传入的delay计算epoll系统调用需要等待的时间</li>
<li>调用epollwait等待可读或可写事件</li>
<li>在循环中依次处理epollevent事件</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms) <span class="comment">//等待fd可读或可写</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123; <span class="comment">//epoll返回负值，返回空gList或者重试</span></span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//如果大于0，则在循环中处理事件</span></span><br><span class="line"><span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">    <span class="comment">//netpollBreak的事件，中断网络轮询器</span></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的读写事件，通过netpollready进行处理</span></span><br><span class="line">		<span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.everr = <span class="literal">false</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>) <span class="comment">//将pd中的读写信号转换为pdReady，并返回pd的Goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg) <span class="comment">//加入待执行列表，Goroutine列表会被加入到处理器或者全局运行队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="截止日期"><a href="#截止日期" class="headerlink" title="截止日期"></a>截止日期</h4><p>计时器依赖于网络轮询器唤醒，文件和网络I/O的截止日期也由其负责处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于设置截止日期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="keyword">int64</span>, mode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">	<span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">		d += nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">	pd.rd = d <span class="comment">//先使用截止日期计算过期的时间点</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> pd.rt.f == <span class="literal">nil</span> &#123; <span class="comment">//如果没有设置执行的函数</span></span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">			pd.rt.f = netpollReadDeadline  <span class="comment">//设置计时器到期执行的函数</span></span><br><span class="line">			pd.rt.arg = pd</span><br><span class="line">			pd.rt.seq = pd.rseq</span><br><span class="line">			resettimer(&amp;pd.rt, pd.rd) <span class="comment">//重置计时器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 &#123; <span class="comment">//如果截止日期已改变</span></span><br><span class="line">		pd.rseq++</span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123; <span class="comment">//新截止日期 &gt; 0 ，修改计时器</span></span><br><span class="line">			modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//新日期 &lt; 0 ，删除计时器, 并会在后面直接唤醒对应的Goroutine</span></span><br><span class="line">			deltimer(&amp;pd.rt)</span><br><span class="line">			pd.rt.f = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行时会在计时器到期时调用netpolldeadlineimpl,直接使用netpollgoready唤醒对应的Goroutine，Goroutine被唤醒后，会意识到当前I/O操作已经超时，选择重试或者终止调用</p>
<h2 id="IO前后的GPM"><a href="#IO前后的GPM" class="headerlink" title="IO前后的GPM"></a>IO前后的GPM</h2><ol>
<li>G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zf09e2xj30h508vmxk.jpg" alt="img"></p>
<ol start="2">
<li><p>G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zgho21oj313f0krmyp.jpg" alt="img"></p>
</li>
<li><p>异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环/eventloop。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zh0rzj3j30if09kt94.jpg" alt="img"></p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>网络轮询器并不是一个独立运行的，调度器和系统调用都会通过netpoll与网络循环器交换信息，获取待执行的GoRoutine列表，并将待执行的Goroutine加入运行队列等待处理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/10/MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/10/MQ/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-10 00:37:10" itemprop="dateCreated datePublished" datetime="2022-01-10T00:37:10+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><ol>
<li>队列模型</li>
<li>发布-订阅模型：消息的发送者，消息的接受者，服务端存放消息的容器(Topic)。发布者将消息发送到主题中，订阅者在接收消息前需要先订阅”Topic“，每份订阅，订阅者可以收到主题的所有消息。</li>
</ol>
<p>区别：发布-订阅模型中，一个消息可以被多次消费。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>使用”请求-确认“机制确保消息不会丢失</p>
<ol>
<li><p>生成端：</p>
<p>生产者先将消息发送给服务端(Broker)，Broker收到消息后将消息写入Topic后再给生产者发送确认响应。如果没有收到响应则会重复发送消息。</p>
</li>
<li><p>消费端：</p>
<p>消费者在收到消息并完成消费业务逻辑后，也会向服务端发送消费成功的确认。（注：应该在完成消费业务逻辑以后再进行确认）</p>
</li>
<li><p>存储阶段：</p>
<p>如果Broker是多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点在回复确认。</p>
</li>
</ol>
<p>由于”请求-确认“机制，为了确保消息的有序性，一条消息被成功消费前，下一条消息是不能被消费的。所有扩容Consumer时需要扩容Consumer Queue</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>解决 -&gt; 在分布式系统中保持一致性</p>
<p>成员：协调者，参与者</p>
<ol>
<li>投票阶段：协调者向参与者询问是否可以指向操作，参与者执行完(agreement/abort)并且记录redo/undo日志。当所有参与者都执行完进行提交阶段。</li>
<li>提交阶段：如果都同意，则协调者发送commit，否则rollback。参与者完成操作后返回消息，如果协调者收到所有的返回消息则结束事务，否则回滚。</li>
</ol>
<p>EG：</p>
<p>订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车删除（使用消息队列异步清理购物车）。需要保证本地事务和发消息这两步要么都成功，要么都失败。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy49h2qvl7j32g70u0n1j.jpg" alt="img"></p>
<ol>
<li>订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</li>
<li>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</li>
</ol>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>RocketMQ的存储以Broker为单位，Broker(ConsumerLog消息文件&amp;N*ConsumerQueue索引文件)，</p>
<ol>
<li>写入消息：Broker上所有Topic，队列的消息都按照自然顺序追加写入到同一个消息文件中</li>
<li>查找消息：根据队列的消息序号，计算索引的全局位置(索引序号 x 索引固定长度20)，直接读取这条索引，然后根据索引查找到消息的位置</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/07/%E6%89%8B%E6%92%B8DSL%E5%92%8CgRPC%E8%A7%A3%E6%9E%90-proto%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/07/%E6%89%8B%E6%92%B8DSL%E5%92%8CgRPC%E8%A7%A3%E6%9E%90-proto%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">手撸DSL和gRPC解析.proto分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-07 11:27:36" itemprop="dateCreated datePublished" datetime="2022-01-07T11:27:36+08:00">2022-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-10 15:05:14" itemprop="dateModified" datetime="2022-01-10T15:05:14+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DSL和gRPC-protoc-gen-go"><a href="#DSL和gRPC-protoc-gen-go" class="headerlink" title="DSL和gRPC protoc-gen-go"></a>DSL和gRPC protoc-gen-go</h1><h2 id="DSL介绍"><a href="#DSL介绍" class="headerlink" title="DSL介绍"></a>DSL介绍</h2><p>定义：DSL(Domain Specific Language)为领域特定语言，GPL(General Purpose Language)通用编程语言(图灵完备)，比如C，C++，Python，C#等</p>
<p>常见的DSL：1. Regex,HTML,CSS,CocoaPods,Grandle,SQL</p>
<p>Regex: 正则表达式，指定了字符串的模型，会判断当前字符串跟正则表达式是否匹配</p>
<p>SQL: 用于操作数据库，数据库会从SQL语句读取信息，然后返回使用者期望的结果</p>
<p>CocoaPods|Grandle: 设定了具体的规则，用于管理第三方库和工程配置 </p>
<h2 id="如何手撸DSL"><a href="#如何手撸DSL" class="headerlink" title="如何手撸DSL"></a>如何手撸DSL</h2><h3 id="构建DSL"><a href="#构建DSL" class="headerlink" title="构建DSL"></a>构建DSL</h3><ol>
<li>设计语法和语义，定义DSL中的元素（token）是什么样的，元素（token）代表什么意思</li>
<li>实现parser，对DSL进行解析，生成并处理抽象树(AST)，DSL最终通过解释器来执行</li>
</ol>
<h3 id="内部DSL和外部DSL"><a href="#内部DSL和外部DSL" class="headerlink" title="内部DSL和外部DSL"></a>内部DSL和外部DSL</h3><p>外部DSL：语法语义，语法解析器和抽象树的处理都需要自己完成。</p>
<p>内部DSL：内部DSL嵌入一些编程语言中的，比如iOS的CocoaPods(Ruby)和Android的Gradle(Groovy)。</p>
<p>内部DSL使用了宿主的能力，不需要实现语法分析器(Parser)，通常会使用宿主语言的特性进行创造。</p>
<h3 id="CocoaPods分析："><a href="#CocoaPods分析：" class="headerlink" title="CocoaPods分析："></a>CocoaPods分析：</h3><ol>
<li><p>为什么基于Ruby:</p>
<ol>
<li>ruby一切皆对象，减少了语言中的元素，不存在基本类型，操作符</li>
<li>ruby方法传入代码块很方便</li>
<li>作为解释执行的语言，eval可以将字符串作为代码执行</li>
<li>代码格式不受限</li>
</ol>
</li>
<li><p>Podfile:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span> </span><br><span class="line">source <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>   </span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;testTTAcount&#x27;</span> <span class="keyword">do</span></span><br><span class="line">   pod <span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Source: 依赖的源地址</p>
<p>Target: 要添加依赖的工程的名字</p>
<p>Pod: 表示依赖，gRPC-Swift为依赖库，后面为版本号</p>
<p>将上面的部分以更符合代码形式则表示为:</p>
<p>在执行时会作为Ruby代码来执行</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source(<span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span>)</span><br><span class="line">source(<span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&#x27;testTTAcount&#x27;</span>) <span class="keyword">do</span></span><br><span class="line">  pod (<span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何使用Ruby实现一个简单的内部DSL</p>
<ol>
<li>创建一些Podfile中”代码“执行的上下文，即一些方法。</li>
<li>读取Podfile中的内容到脚本中。</li>
<li>使用eval在上下文中执行Podfile的”代码“</li>
</ol>
</li>
<li><p>实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span> </span><br><span class="line">source <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;10.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;testTTAcount&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里的source, platform, target,pod都是方法，所以需要构建包含这些方法的上下文</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval_pod.rb</span></span><br><span class="line"><span class="variable">$hash_value</span> = &#123;&#125; /<span class="regexp">/存储指定的依赖</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def source(url)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def target(target)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def platform(platform, version)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def pod(pod)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">content = File.read &#x27;./</span>Podfile<span class="string">&#x27;//从一个podfile中读取</span></span><br><span class="line"><span class="string">eval content //使用eval执行，读取的内容（作为ruby代码执行）</span></span><br><span class="line"><span class="string">p $hash_value //打印指定的依赖</span></span><br></pre></td></tr></table></figure>

<p>简单实现一下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;source&#x27;</span>] = url</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line">    targets = <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>]</span><br><span class="line">    targets = [] <span class="keyword">if</span> targets == <span class="literal">nil</span></span><br><span class="line">    targets &lt;&lt; target</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>] = targets</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line">    pods = <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>]</span><br><span class="line">    pods = [] <span class="keyword">if</span> pods == <span class="literal">nil</span></span><br><span class="line">    pods &lt;&lt; pod</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>] = pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br><span class="line">&#123;<span class="string">&quot;source&quot;</span>=&gt;[<span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span>,<span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>], <span class="string">&quot;targets&quot;</span>=&gt;[<span class="string">&quot;testTTAcount&quot;</span>], <span class="string">&quot;pods&quot;</span>=&gt;[<span class="string">&quot;gRPC-Swift&quot;</span>, <span class="string">&quot;SDWebImage&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理:"></a>编译原理:</h3><p>编译的过程：</p>
<ol>
<li><p>预处理:</p>
<ul>
<li>头文件替换</li>
<li>宏展开</li>
<li>注释清除</li>
<li>预编译指令处理</li>
<li>条件编译</li>
<li>…</li>
</ul>
</li>
<li><p>词法分析:</p>
<p>简单的说就是想读英文文章一样，先一个一个的读出单词，获取到单词的意思。</p>
<p>这里将“词法记号”，即token。词法分析的过程叫做分词，可以将语句切割成多个token</p>
<ol>
<li>通过正则文法读取</li>
<li>通过有限自动机</li>
</ol>
</li>
<li><p>语法分析：</p>
<p>在词法分析的基础上识别程序的语法结构，生成一个树状结构，即抽象语法树(AST Abstract Syntax Tree)</p>
<p>Eg: 1+2*3</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gy5597m3jmj30ni0i6t9i.jpg" alt="img" style="zoom:50%;" /></li>
<li><p>语义分析：</p>
<p>基于AST，编译器会进行语义分析。语义分析会标注在抽象语法树的节点上。</p>
<p>Eg: </p>
<ol>
<li>某个表达式的结果是什么类型？不一样能否自动转换</li>
<li>一个代码块内部和外部有相同名称的变量，执行时应该用哪一个</li>
</ol>
</li>
<li><p>中间代码生成：</p>
<p>一般来说，编译器会有一个抽象于机器平台的中间语言（IR）以便后续的机器无关的优化</p>
</li>
<li><p>代码优化：</p>
<p>机器无关的优化。函数内联，for循环展开</p>
</li>
<li><p>目标代码生成：</p>
<p>生成目标平台的代码，如果是编译型的语言，往往是产生.o文件。这里编译器的工作已经结束了。</p>
</li>
</ol>
<p>词法分析，语法分析，语义分析为编译器前端内容</p>
<p>中间代码生成，代码优化，目标代码生成为编译器后端内容</p>
<h3 id="ANTLR"><a href="#ANTLR" class="headerlink" title="ANTLR:"></a>ANTLR:</h3><p>教程文档:<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/antlr4-short-course/content/">https://wizardforcel.gitbooks.io/antlr4-short-course/content/</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.antlr.org/support.html">https://www.antlr.org/support.html</a></p>
<p>介绍:</p>
<p>ANTLR v4是一款功能强大的语法分析器生成器，可以用来读取、处理、执行和转换结构化文本或二进制文件。它被广泛应用于学术界和工业界构建各种语言、工具和框架。</p>
<p>从称为文法的一种形式化的语言描述中，ANTLR生成该语言的语法分析器。生成的语法分析器可以自动构建语法分析树——表示文法如何匹配输入的数据结构。ANTLR还可以自动生成树遍历器，你可以用它来访问那些树的节点，以执行特定的代码。</p>
<p>原理：</p>
<p><a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~yuzhang/compiler/2019f/lectures/allstar.pdf">ANTLR原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/">ANTLR-Go</a></p>
<h3 id="算法表达式示例"><a href="#算法表达式示例" class="headerlink" title="算法表达式示例"></a>算法表达式示例</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy58m7uqwkj312y0oytbm.jpg" alt="飞书20220107-172941"></p>
<ol>
<li><p>词法定义：</p>
<p>词法规则类似与正则表达式，这里即关注数字和加减乘除，忽略空白符</p>
</li>
<li><p>文法规则：</p>
<p>start为文法的入口； expresion定义了具体的计算表达式。</p>
<p>表达式：表达式可以是一个数字，数字的加减乘除，表达式的加减乘除，或者通过括号包裹表达式组合。</p>
</li>
<li><p>规则名称：</p>
<p>antlr会将.g4定义的规则生成一个解析器的代码框架，能自动解析并生成AST。业务层拿到抽象语法树以后，还需要根据AST来处理业务逻辑以及业务需求</p>
</li>
<li><p>上下文标记：</p>
<p>为文法规则分配上下文标记，该标记可用再业务代码处理AST时，更加明确区分当前上下文的规则。</p>
<p>比如在：AdditionOrSubstraction这行，左右表达式都是expressin，这里通过上下文标记，left=,right=的方式为左右expresion添加了上下文标记，这样业务代码也就可用区分左右表达式了</p>
</li>
<li><p>生成解析器（Visitor模式|Listener模式）</p>
<p>Visitor模式：</p>
<p>执行对于语言的命令后，会生成对应语言下的代码：</p>
<p>其中calcLexer是词法分析器，calcParser是语法分析器，calcVisitor是遍历AST的访问器的interface，业务代码需要实现该interface实现具体的业务需求逻辑</p>
</li>
</ol>
<p>生成的结构：</p>
<p>根据名字大概可以看出各个文件的作用，calc_lexer为词法分析器，作用是生成tokens流。calc_parser是语法分析器，用于生成AST。calcVisitor是用于遍历AST的访问器的接口，业务代码通过实现该接口来实现具体的业务逻辑。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8eni3fvlj30b60a4glz.jpg" alt="飞书20220110-111501" align='left' style="zoom: 67%;" />

<p>在calc_visitor这个接口中，定义了一系列以visit为前缀的函数，这些函数对应了.g4中的每一个规则名称。</p>
<p>eg: visitNumber对应了.g4里的#Number规则</p>
<p>这些访问函数，都接收一个上下文参数，不同的规则，上下文参数会有差异，最主要就是会有不同的上下文标记可用使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CalcVisitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	antlr.ParseTreeVisitor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#start.</span></span><br><span class="line">	VisitStart(ctx *StartContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Number.</span></span><br><span class="line">	VisitNumber(ctx *NumberContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#MultiplicationOrDivision.</span></span><br><span class="line">	VisitMultiplicationOrDivision(ctx *MultiplicationOrDivisionContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#AdditionOrSubstraction.</span></span><br><span class="line">	VisitAdditionOrSubstraction(ctx *AdditionOrSubstractionContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Parentheses.</span></span><br><span class="line">	VisitParentheses(ctx *ParenthesesContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Power.</span></span><br><span class="line">	VisitPower(ctx *PowerContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键函数.visit：这个函数是遍历AST的核心函数，这个函数内部会根据visit的具体规则，进入到visitXXX函数，在具体的visitXXX函数，又通过业务代码调用.visit来实现深度优先遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;Calc/parser&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/antlr/antlr4/runtime/Go/antlr&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">opt</span><span class="params">(opr <span class="keyword">string</span>,a,b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span>  &#123; <span class="comment">//处理算术运行逻辑</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;_opt&quot;</span>,opr,a,b)</span><br><span class="line">	a1,b1 := a.(<span class="keyword">int</span>),b.(<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">switch</span> opr[<span class="number">0</span>] &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> a1+b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> a1-b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> a1*b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> a1/b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a1),<span class="keyword">float64</span>(b1)))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;_opt err&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyCalVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	parser.BaseCalcVisitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">Visit</span><span class="params">(tree antlr.ParseTree)</span> <span class="title">interface</span></span>&#123;&#125;  &#123;<span class="comment">//目前Go的实现为返回nil，需要自己处理一下</span></span><br><span class="line">	<span class="keyword">switch</span> val := tree.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *parser.NumberContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitNumber(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.MultiplicationOrDivisionContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitMultiplicationOrDivision(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.AdditionOrSubstractionContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitAdditionOrSubstraction(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.ParenthesesContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitParentheses(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.PowerContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitPower(val)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitStart</span><span class="params">(ctx *parser.StartContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">//入口，为一个表达式</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitStart&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> v.Visit(ctx.Expression())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitNumber</span><span class="params">(ctx *parser.NumberContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">//解析token为一个数字</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitNumber&quot;</span>)</span><br><span class="line">	num,_ := strconv.Atoi(ctx.NUMBER().GetText())</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitMultiplicationOrDivision</span><span class="params">(ctx *parser.MultiplicationOrDivisionContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="comment">//乘除算术运算</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitMultiplicationOrDivision&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitAdditionOrSubstraction</span><span class="params">(ctx *parser.AdditionOrSubstractionContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="comment">//加减算术运算</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitAdditionOrSubstraction&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitParentheses</span><span class="params">(ctx *parser.ParenthesesContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">//括号</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitParentheses&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> v.Visit(ctx.GetInner())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitPower</span><span class="params">(ctx *parser.PowerContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">//阶乘</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitPower&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="protoc-gen"><a href="#protoc-gen" class="headerlink" title="protoc-gen"></a>protoc-gen</h2><h5 id="generator-GenerateAllFiles"><a href="#generator-GenerateAllFiles" class="headerlink" title="generator.GenerateAllFiles()"></a>generator.GenerateAllFiles()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成所有.proto文件对应的go源代码，这里只是将源代码内容存储到g.Response中，</span></span><br><span class="line"><span class="comment">// 并没有直接创建源代码文件，插件将Response传递给protoc进程后由protoc进程来负</span></span><br><span class="line"><span class="comment">// 责创建源代码文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">GenerateAllFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the plugins</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> plugins &#123;</span><br><span class="line">        p.Init(g)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Generate the output. The generator runs for every file, even the files</span></span><br><span class="line">    <span class="comment">// that we don&#x27;t generate output for, so that we can collate the full list</span></span><br><span class="line">    <span class="comment">// of exported symbols to support public imports.</span></span><br><span class="line">    genFileMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*FileDescriptor]<span class="keyword">bool</span>, <span class="built_in">len</span>(g.genFiles))</span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> g.genFiles &#123;</span><br><span class="line">        genFileMap[file] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> g.allFiles &#123;</span><br><span class="line">        g.Reset()</span><br><span class="line">        g.writeOutput = genFileMap[file]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用generator的generate(...)方法来生成该proto文件的</span></span><br><span class="line">        <span class="comment">// FileDescriptorProto描述对应的go源代码</span></span><br><span class="line">        g.generate(file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.Response.File = <span class="built_in">append</span>(g.Response.File, &amp;plugin.CodeGeneratorResponse_File&#123;</span><br><span class="line">            Name:    proto.String(file.goFileName()),</span><br><span class="line">            Content: proto.String(g.String()),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator .generate()方法如何实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对.proto文件（由FileDescriptor表示）生成对应的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">generate</span><span class="params">(file *FileDescriptor)</span></span> &#123;</span><br><span class="line">    g.file = g.FileOf(file.FileDescriptorProto)</span><br><span class="line">    g.usedPackages = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要生成源代码的首个proto文件对应的go源代码，这部分代码顶部插入版权信息</span></span><br><span class="line">    <span class="keyword">if</span> g.file.index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// For one file in the package, assert version compatibility.</span></span><br><span class="line">        g.P(<span class="string">&quot;// This is a compile-time assertion to ensure that this generated file&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// is compatible with the proto package it is being compiled against.&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// A compilation error at this line likely means your copy of the&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// proto package needs to be updated.&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;const _ = &quot;</span>, g.Pkg[<span class="string">&quot;proto&quot;</span>], <span class="string">&quot;.ProtoPackageIsVersion&quot;</span>, generatedCodeVersion, <span class="string">&quot; // please upgrade the proto package&quot;</span>)</span><br><span class="line">        g.P()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成import语句</span></span><br><span class="line">    <span class="keyword">for</span> _, td := <span class="keyword">range</span> g.file.imp &#123;</span><br><span class="line">        g.generateImported(td)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成enum类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, enum := <span class="keyword">range</span> g.file.enum &#123;</span><br><span class="line">        g.generateEnum(enum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成message类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, desc := <span class="keyword">range</span> g.file.desc &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t generate virtual messages for maps.</span></span><br><span class="line">        <span class="keyword">if</span> desc.GetOptions().GetMapEntry() &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.generateMessage(desc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成extension类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, ext := <span class="keyword">range</span> g.file.ext &#123;</span><br><span class="line">        g.generateExtension(ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成初始化函数语句</span></span><br><span class="line">    g.generateInitFunction()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面生成enum、message、extension等的方式都基本类似，后面我们只给出一个</span></span><br><span class="line">    <span class="comment">// 生成枚举类型方法的说明，生成message、extension的实现方法可以执行查看</span></span><br><span class="line">    <span class="comment">// generator.go中的实现。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 需要注意的是，前面的各个生成源代码的方法不能处理service服务定义的rpc接</span></span><br><span class="line">    <span class="comment">// 口代码，这部分rpc代码的生成需要借助于grpc子插件来完成，即下面的g.runPlugins(...)</span></span><br><span class="line">    g.runPlugins(file)</span><br><span class="line"></span><br><span class="line">    g.generateFileDescriptor(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待输出的源代码需要知道哪些package是需要import的，哪些不需要，因此先运行</span></span><br><span class="line">    <span class="comment">// 插件生成go代码中除import之外的其他部分代码，然后知道了哪些package需要</span></span><br><span class="line">    <span class="comment">// import，再插入具体的import语句。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 最后在go源代码中插入header、import</span></span><br><span class="line">    rem := g.Buffer</span><br><span class="line">    g.Buffer = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    g.generateHeader()</span><br><span class="line">    g.generateImports()</span><br><span class="line">    <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    g.Write(rem.Bytes())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新格式化生成的go源代码（gofmt）</span></span><br><span class="line">    fset := token.NewFileSet()</span><br><span class="line">    raw := g.Bytes()</span><br><span class="line">    ast, err := parser.ParseFile(fset, <span class="string">&quot;&quot;</span>, g, parser.ParseComments)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Print out the bad code with line numbers.</span></span><br><span class="line">        <span class="comment">// This should never happen in practice, but it can while changing generated code,</span></span><br><span class="line">        <span class="comment">// so consider this a debugging aid.</span></span><br><span class="line">        <span class="keyword">var</span> src bytes.Buffer</span><br><span class="line">        s := bufio.NewScanner(bytes.NewReader(raw))</span><br><span class="line">        <span class="keyword">for</span> line := <span class="number">1</span>; s.Scan(); line++ &#123;</span><br><span class="line">            fmt.Fprintf(&amp;src, <span class="string">&quot;%5d\t%s\n&quot;</span>, line, s.Bytes())</span><br><span class="line">        &#125;</span><br><span class="line">        g.Fail(<span class="string">&quot;bad Go source code was generated:&quot;</span>, err.Error(), <span class="string">&quot;\n&quot;</span>+src.String())</span><br><span class="line">    &#125;</span><br><span class="line">    g.Reset()</span><br><span class="line">    err = (&amp;printer.Config&#123;Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: <span class="number">8</span>&#125;).Fprint(g, fset, ast)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        g.Fail(<span class="string">&quot;generated Go source code could not be reformatted:&quot;</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何生成enum"><a href="#如何生成enum" class="headerlink" title="如何生成enum"></a>如何生成enum</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成指定enum类型的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">generateEnum</span><span class="params">(enum *EnumDescriptor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// enum类型的完整类型名</span></span><br><span class="line">    typeName := enum.TypeName()</span><br><span class="line">    <span class="comment">// CamelCased之后的完整类型名</span></span><br><span class="line">    ccTypeName := CamelCaseSlice(typeName)</span><br><span class="line">    ccPrefix := enum.prefix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印enum类型定义之前的leading comments</span></span><br><span class="line">    <span class="comment">// - 提取源代码信息SourceCodeInfo都是通过Location path来获取的；</span></span><br><span class="line">    <span class="comment">// - 提取注释信息也不例外，下面我们会介绍PrintComments(path)如何通过</span></span><br><span class="line">    <span class="comment">//   Location path来生成注释信息；</span></span><br><span class="line">    g.PrintComments(enum.path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成枚举类型的定义起始部分：type 枚举类型名 int32</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, ccTypeName, <span class="string">&quot; int32&quot;</span>)</span><br><span class="line">    g.file.addExport(enum, enumSymbol&#123;ccTypeName, enum.proto3()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类型里面的各个枚举值都作为const int32常量来定义</span></span><br><span class="line">    g.P(<span class="string">&quot;const (&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值定义之前缩进一下</span></span><br><span class="line">    g.In()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对枚举类型里面的所有枚举值进行源代码生成</span></span><br><span class="line">    <span class="keyword">for</span> i, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        <span class="comment">// 生成枚举值前面的leading comments</span></span><br><span class="line">        g.PrintComments(fmt.Sprintf(<span class="string">&quot;%s,%d,%d&quot;</span>, enum.path, enumValuePath, i))</span><br><span class="line">        <span class="comment">// 生成枚举值的name = value形式的go源代码</span></span><br><span class="line">        name := ccPrefix + *e.Name</span><br><span class="line">        g.P(name, <span class="string">&quot; &quot;</span>, ccTypeName, <span class="string">&quot; = &quot;</span>, e.Number)</span><br><span class="line">        g.file.addExport(enum, constOrVarSymbol&#123;name, <span class="string">&quot;const&quot;</span>, ccTypeName&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值定义完之后取消缩进</span></span><br><span class="line">    g.Out()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印最后的结束信息</span></span><br><span class="line">    g.P(<span class="string">&quot;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成枚举类型相关的两个map</span></span><br><span class="line">    <span class="comment">// - 其中一个是枚举值到枚举名的映射；</span></span><br><span class="line">    <span class="comment">// - 另一个是枚举名到枚举值的映射；</span></span><br><span class="line">    g.P(<span class="string">&quot;var &quot;</span>, ccTypeName, <span class="string">&quot;_name = map[int32]string&#123;&quot;</span>)</span><br><span class="line">    g.In()</span><br><span class="line">    <span class="comment">// 第一个map</span></span><br><span class="line">    generated := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">bool</span>) <span class="comment">// avoid duplicate values</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        duplicate := <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> _, present := generated[*e.Number]; present &#123;</span><br><span class="line">            duplicate = <span class="string">&quot;// Duplicate value: &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.P(duplicate, e.Number, <span class="string">&quot;: &quot;</span>, strconv.Quote(*e.Name), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        generated[*e.Number] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    g.Out()</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    <span class="comment">// 第二个map</span></span><br><span class="line">    g.P(<span class="string">&quot;var &quot;</span>, ccTypeName, <span class="string">&quot;_value = map[string]int32&#123;&quot;</span>)</span><br><span class="line">    g.In()</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        g.P(strconv.Quote(*e.Name), <span class="string">&quot;: &quot;</span>, e.Number, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    g.Out()</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他处理动作，也会生成部分源代码，这里可以忽略不计了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrintComments如何通过Location path来提前并打印关联的注释信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印.proto文件中对该location path关联的leading comments注释信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">PrintComments</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在protoc进程解析.proto文件的时候就已经将各个类型、字段的comments信息维</span></span><br><span class="line">    <span class="comment">// 护起来了，k就是location的path，通过path就能获取到对应的location，每个</span></span><br><span class="line">    <span class="comment">// location中保存了这个位置的源代码的leading comments、trailing comments信</span></span><br><span class="line">    <span class="comment">// 息，这里只打印leading comments</span></span><br><span class="line">    <span class="keyword">if</span> loc, ok := g.file.comments[path]; ok &#123;</span><br><span class="line">        text := strings.TrimSuffix(loc.GetLeadingComments(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(text, <span class="string">&quot;\n&quot;</span>) &#123;</span><br><span class="line">            g.P(<span class="string">&quot;// &quot;</span>, strings.TrimPrefix(line, <span class="string">&quot; &quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何生成service服务的rpc接口源代码"><a href="#如何生成service服务的rpc接口源代码" class="headerlink" title="如何生成service服务的rpc接口源代码"></a>如何生成service服务的rpc接口源代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run all the plugins associated with the file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">runPlugins</span><span class="params">(file *FileDescriptor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在上述generator处理的基础上，继续运行generator中注册的插件，依次运行插件</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> plugins &#123;</span><br><span class="line">        p.Generate(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成.proto文件中service定义的rpc接口的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *grpc)</span> <span class="title">Generate</span><span class="params">(file *generator.FileDescriptor)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有定义service服务直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(file.FileDescriptorProto.Service) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相关变量定义</span></span><br><span class="line">    g.P(<span class="string">&quot;// Reference imports to suppress errors if they are not otherwise used.&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;var _ &quot;</span>, contextPkg, <span class="string">&quot;.Context&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;var _ &quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言，检查版本兼容性</span></span><br><span class="line">    g.P(<span class="string">&quot;// This is a compile-time assertion to ensure that this generated file&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;// is compatible with the grpc package it is being compiled against.&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;const _ = &quot;</span>, grpcPkg, <span class="string">&quot;.SupportPackageIsVersion&quot;</span>, generatedCodeVersion)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对所有的service定义生成相关的service的go源代码</span></span><br><span class="line">    <span class="keyword">for</span> i, service := <span class="keyword">range</span> file.FileDescriptorProto.Service &#123;</span><br><span class="line">        g.generateService(file, service, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc中对generateService的实现，生成service相关的go源代码</span></span><br><span class="line"><span class="comment">// @param .proto解析后的各种DescriptorProto的wrapping类，通过它可以方便地访问.proto中定义的东西 </span></span><br><span class="line"><span class="comment">// @param .proto中的某个service解析后对应的ServiceDescriptorProto</span></span><br><span class="line"><span class="comment">// @param .proto中可能定义了多个service，当前这个service对应的索引值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *grpc)</span> <span class="title">generateService</span><span class="params">(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构建当前service对应的path!</span></span><br><span class="line">    path := fmt.Sprintf(<span class="string">&quot;6,%d&quot;</span>, index) <span class="comment">// 6 means service.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取service名称</span></span><br><span class="line">    origServName := service.GetName()</span><br><span class="line">    fullServName := origServName</span><br><span class="line">    <span class="keyword">if</span> pkg := file.GetPackage(); pkg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fullServName = pkg + <span class="string">&quot;.&quot;</span> + fullServName</span><br><span class="line">    &#125;</span><br><span class="line">    servName := generator.CamelCase(origServName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备生成client相关的go源代码</span></span><br><span class="line">    g.P()</span><br><span class="line">    g.P(<span class="string">&quot;// Client API for &quot;</span>, servName, <span class="string">&quot; service&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务用户端go源代码生成</span></span><br><span class="line">    <span class="comment">// - type 服务名+Client interface</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, servName, <span class="string">&quot;Client interface &#123;&quot;</span>)</span><br><span class="line">    <span class="comment">// - 服务用户端定义的各个接口方法</span></span><br><span class="line">    <span class="keyword">for</span> i, method := <span class="keyword">range</span> service.Method &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接口的leading comments</span></span><br><span class="line">        g.gen.PrintComments(fmt.Sprintf(<span class="string">&quot;%s,2,%d&quot;</span>, path, i)) <span class="comment">// 2 means method in a service.</span></span><br><span class="line">        <span class="comment">// 生成接口的签名</span></span><br><span class="line">        g.P(g.generateClientSignature(servName, method))</span><br><span class="line">    &#125;</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务的用户端struct，其中包括了一个cc *grpc.ClientConn，后面会在该struct</span></span><br><span class="line">    <span class="comment">// 上实现上述服务接口</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, unexport(servName), <span class="string">&quot;Client struct &#123;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;cc *&quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewClient工厂 </span></span><br><span class="line">    g.P(<span class="string">&quot;func New&quot;</span>, servName, <span class="string">&quot;Client (cc *&quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn) &quot;</span>, servName, <span class="string">&quot;Client &#123;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;return &amp;&quot;</span>, unexport(servName), <span class="string">&quot;Client&#123;cc&#125;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> methodIndex, streamIndex <span class="keyword">int</span></span><br><span class="line">    serviceDescVar := <span class="string">&quot;_&quot;</span> + servName + <span class="string">&quot;_serviceDesc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务用户端的接口方法实现</span></span><br><span class="line">    <span class="keyword">for</span> _, method := <span class="keyword">range</span> service.Method &#123;</span><br><span class="line">        <span class="keyword">var</span> descExpr <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> !method.GetServerStreaming() &amp;&amp; !method.GetClientStreaming() &#123;</span><br><span class="line">            <span class="comment">// Unary RPC method</span></span><br><span class="line">            descExpr = fmt.Sprintf(<span class="string">&quot;&amp;%s.Methods[%d]&quot;</span>, serviceDescVar, methodIndex)</span><br><span class="line">            methodIndex++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Streaming RPC method</span></span><br><span class="line">            descExpr = fmt.Sprintf(<span class="string">&quot;&amp;%s.Streams[%d]&quot;</span>, serviceDescVar, streamIndex)</span><br><span class="line">            streamIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        g.generateClientMethod(servName, fullServName, serviceDescVar, method, descExpr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.P(<span class="string">&quot;// Server API for &quot;</span>, servName, <span class="string">&quot; service&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端接口go源代码生成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator生成service以为的代码，grpc生成service相关的go代码</p>
<p>参考:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/dsl/">https://draveness.me/dsl/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hitzhangjie.pro/blog/2017-05-23-protoc%E5%8F%8A%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%B2%BE%E5%8D%8E%E7%89%88/#242-%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8Bcodegeneratorrequest--codegeneratorresponse%E7%9A%84%E5%AE%9A%E4%B9%89">https://www.hitzhangjie.pro/blog/2017-05-23-protoc%E5%8F%8A%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%B2%BE%E5%8D%8E%E7%89%88/#242-%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8Bcodegeneratorrequest--codegeneratorresponse%E7%9A%84%E5%AE%9A%E4%B9%89</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/06/MySQL-%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/06/MySQL-%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">MySQL - 索引和调优小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-06 21:28:07" itemprop="dateCreated datePublished" datetime="2022-01-06T21:28:07+08:00">2022-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-11 11:46:03" itemprop="dateModified" datetime="2022-01-11T11:46:03+08:00">2022-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL索引和SQL调优"><a href="#MySQL索引和SQL调优" class="headerlink" title="MySQL索引和SQL调优"></a>MySQL索引和SQL调优</h1><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>MySQL支持多种引擎，各种引擎对所有的支持不同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。其中只有为BTree索引。</p>
<h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><p>目的：提高查询效率（读，写），数据库的查询情况复杂，包括等值查询，范围查询，模糊查询，并集查询，多值匹配等。需要每次查找数据时，磁盘IO次数较少，高度可控的多路搜索树就是很好的选择。</p>
<p>索引结构：B+树</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树的重要性质：</p>
<ol>
<li><p>索引字段越小，数据项的数目越多，树的高度越低 - 所以B+树的索引字段要尽量小</p>
</li>
<li><p>最左匹配：当B+树的数据项是复合的数据结构，比如(name, age, sex)的时候，b+树是按照从左到右的顺序来构建搜索树的。比如(张三，24，F)进行检索时，会优先比较name来确定下一个搜索方向，name相同再依次比较age，sex，最后得到检索的数据。</p>
<p>但是当(24,F)这样的没有name的数据来的时候，B+数不知道下一步该查哪一个节点</p>
<p>当（张三，F）进行检索，先根据name进行搜索，由于age缺失，只能把所有满足张三的都找到，然后再匹配性别为F的数据</p>
</li>
</ol>
<p>B+树在磁盘存储中表现的特性</p>
<ol>
<li>为了节省内存，是把B+树存储到硬盘中的，对于每一个节点的访问都对应了一次磁盘IO操作 -&gt; 树的高度 == 查询时的磁盘IO次数</li>
<li>一个m叉树，m越大高度越低。但是操作系统是按页（4KB）来读取磁盘或内存中的数据的。如果读取的数据量超过4KB，则会触发多次IO操作。所以在选择m的大小时，尽量让每个节点的大小等于一个页的大小。这样一个节点只需要一次IO。（总的次数：(向上取整)(节点大小)/4KB  * 树的高度）</li>
<li>数据的增加删除修改都会导致B+树结构调整，自增字段会减少消耗</li>
</ol>
<h2 id="MySQL索引的实现"><a href="#MySQL索引的实现" class="headerlink" title="MySQL索引的实现"></a>MySQL索引的实现</h2><p>主要为MyISAM和InnoDB</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6r6in5akj30hs0ebjs2.jpg" alt="图片"></p>
<p>使用B+树，叶子节点存放的是数据的地址。</p>
<p>在MyISAM中，主索引和辅助索引在结构上都是一样的，只是主索引要求key是唯一的</p>
<p>上图使用的是Col1作为Primary Key,如果使用Col2作为辅助索引如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6racejzaj30hs0ebaaq.jpg" alt="图片"></p>
<p>所以，对于MyISAM来说，索引检索为首先按照B+树的方式搜索索引，找到key以后读取地址值，再根据地址值读取相应的数据（非聚集的索引）</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>使用B+树，但是InnoDB的数据文件本身就是索引文件，表数据文件本身是按照B+树组织的一个索引结构，叶节点保存了完整的数据，索引key是数据表的主键。这种叫做聚集索引。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6rfassnzj30f306pdg3.jpg" alt="图片"></p>
<p>由于InnoDB的数据文件本身需要根据主键组织，所以InnoDB要求必须有主键（MyISAM可以没有）</p>
<p>如果没有显示指定，则MySQL会自动旋转一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则会自动生成一个隐含字段作为主键（自增，6字节的长整形）</p>
<p>由于InnoDB的表数据文件按照B+数组织，所以对于InnoDB的辅助索引来说，辅助索引的叶子节点需要保存的是主键的值而不是地址</p>
<p><strong>造成的不同</strong>：聚集索引的方式会使得按照主键（主索引）搜索的方式变得高效，但是对于辅助索引来说，需要进行两次检索（使用辅助索引检索到主键，然后在主索引通过主键找到记录）</p>
<p>重要特性：</p>
<ol>
<li>InnoDB的索引形式，导致其使用过长的字段作为主键，它的所有辅助索引都会因此变得过大</li>
<li>使用非单调的字段作为主键，在InnoDB中不是好事，因为InnoDB本身是B+树，非单调的主键会在插入新数据时，B+树频繁的分裂调整，所以使用自增字段作为主键是一个很好的选择</li>
</ol>
<h2 id="建立索引的原理"><a href="#建立索引的原理" class="headerlink" title="建立索引的原理"></a>建立索引的原理</h2><p>联合索引：</p>
<p>MySQL的索引可以按照一定的顺序引用多个列，这种索引叫做联合索引</p>
<p>一个联合索引是一个有序元祖。</p>
<p>索引匹配的最左原则：</p>
<p>假如索引列分别为A，B，C，顺序也是A，B，C</p>
<ol>
<li>如果查询[A],[A,B],[A,B,C]可以通过索引查询</li>
<li>如果使用[A,C]，则只能使用到A索引</li>
<li>如果查询的时候，是[B],[B,C],[C]，由于没有用的第一列索引，所以后面的索引也用不到</li>
<li>如果查询时范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列用不了索引</li>
</ol>
<p>索引的代价：</p>
<ol>
<li>索引本身需要空间存储</li>
<li>MySQL运行时也需要维护索引</li>
</ol>
<p>InnoDB存储引擎：没有特殊情况，使用一个与业务无关的自增主键</p>
<p>磁盘IO: MySQL的数据都是以文件形式存储在磁盘上的，数据库对数据的读取以页为基本单位单位读取，一般为4KB的整数倍。为了提升效率，会有缓冲池（时间局部性&amp;空间局部性）</p>
<p>随机读取和顺序读取：随机读取的消耗时间大约为10ms，内存中的随机读取大约1ms，顺序读写能达到一页0.1ms。所以能减少随机IO，使用顺序读取，会大大提高磁盘吞吐量。</p>
<p>过滤因子：一个 SQL 查询扫描的索引片大小其实是由过滤因子决定的，也就是满足查询条件的记录行数所占的比例。如果过滤因子比较好，则该列的重复字段的比例低。</p>
<p>匹配列和过滤列： users 表中有 name、age 和 (name, sex, age) 三个辅助索引。当where存在age=21或name=”123”时，三个索引都会成功匹配列用于选择索引树中的数据行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;draven&quot; <span class="keyword">AND</span> sex <span class="operator">=</span> &quot;male&quot; <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对于这种有等值有范围的请求，只会使用name,sex作为匹配列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>但是当其扫描到了所有的满足条件的数据行以后，会把age作为过滤列，这样可以减少去磁盘读取IO的情况</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy92m69i80j30rs099aag.jpg" alt="Match-Columns-Filter-Columns"></p>
<h3 id="建立索引的常见技巧："><a href="#建立索引的常见技巧：" class="headerlink" title="建立索引的常见技巧："></a>建立索引的常见技巧：</h3><ol>
<li><p>最终前缀匹配原则：MySQL会一直向右匹配直到遇见范围查询</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
<li><p>尽量选择区分度高的列作为索引，区分度高是指字段不重复的比例，比例越大扫描的记录数越少，唯一键的区分度为1</p>
</li>
<li><p>索引列不参与计算</p>
<p> eg:from_unixtime(create_time) = ’2014-05-29’就不能使用到索引</p>
<p>原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</p>
</li>
<li><p>尽量扩展索引而不是新建索引，比如本身已经有a索引了，需要（a，b）索引，则最好修改原来的索引a为（a，b）最好</p>
</li>
</ol>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p>概念：如果一个查询语句的索引是三星索引，那么它只需要进行<strong>一次磁盘的随机读及一个窄索引片的顺序扫描</strong>就可以得到全部的结果集</p>
<p>最简单的方式：在设计单表的索引时，首先把查询中所有的<strong>等值谓词全部取出</strong>以任意顺序放在索引最前面，在这时，如果索引中同时存在范围索引和 ORDER BY 就需要权衡利弊了，希望最小化扫描的索引片厚度时，应该将<strong>过滤因子最小的范围索引列</strong>加入索引，如果希望避免排序就选择 <strong>ORDER BY 中的全部列</strong>，在这之后就只需要将查询中<strong>剩余的全部列</strong>加入索引了，通过这种固定的方法和逻辑就可以最快地获得一个查询语句的二星或者三星索引了。</p>
<p>Todo: 数据库索引设计与优化 Book</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/31/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/31/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">计算广告小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-31 14:51:42 / Modified: 16:09:21" itemprop="dateCreated datePublished" datetime="2021-12-31T14:51:42+08:00">2021-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算广告小结"><a href="#计算广告小结" class="headerlink" title="计算广告小结"></a>计算广告小结</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxx0qu65d3j30tk1lj10k.jpg" alt="计算广告基础概念"></p>
<h2 id="广告基础："><a href="#广告基础：" class="headerlink" title="广告基础："></a>广告基础：</h2><ol>
<li><p>什么是广告？</p>
<p>广告是由已确定的出资人通过各种媒介进行的有关产品的，有组织，综合，劝服性的非人员的信息传播活动</p>
</li>
<li><p>广告的目的？</p>
<p>广告主通过媒体达到低成本的用户接触</p>
</li>
<li><p>广告的参与者：</p>
<p>需求方：广告主</p>
<p>供给方：媒体或者其他技术形态的变现平台</p>
<p>受众：普通群众，一个被动的参与方</p>
</li>
<li><p>分类：</p>
<p>大体上是按照售卖方式，分为品牌广告和效果广告。</p>
<p>如果按照广告的形式，可以有多种多样，比如开屏广告，激励视频广告，搜索广告等等。</p>
<p>品牌广告：广告主希望借助媒体达到宣传品牌形象，提升中长期购买率和利润空间的目的。</p>
<p>效果广告：广告主希望能利用广告手段马上带来大量的购买行为。</p>
</li>
</ol>
<h2 id="计算广告："><a href="#计算广告：" class="headerlink" title="计算广告："></a>计算广告：</h2><ol>
<li><p>特点：</p>
<ol>
<li>技术和计算导向</li>
<li>效果可衡量</li>
<li>创意和投放方式标准化</li>
<li>媒体概念多样化</li>
<li>数据驱动的投放决策</li>
</ol>
</li>
<li><p>基本概念：</p>
<ol>
<li>点击率CTR(Click Through Rate):广告点击与广告展现的比率</li>
<li>转化率CVR(Conversion Rate):点击广告以后，会打开广告主的落地页，落地页成功打开次数与点击次数的比率成为到达率。从落地页开始，进一步完成下单等操作，则是转化，转化次数与到达次数的比例成为转化率。</li>
<li>千次展示付费(Cost Per Mille)CPM：广告每展示千次作为单位收取广告费。</li>
<li>千次展示收入(Effective cost per maille)eCPM：每千次展示可以获得的广告收入</li>
</ol>
</li>
<li><p>常见的收费模式：</p>
<ol>
<li><p>CPM：</p>
<p>对于效果和目的不便于直接衡量的，可以使用CPM（千次展示收费）方式计费。供给方和需求方约定好千次展示的计费标准，这些展示是否能够代理相应的收益，需要由需求方类估计和控制。</p>
</li>
<li><p>CPC：</p>
<p>CPC(Cost Per Click)计费，按点击收费。通常用于效果广告。CPC计费有利于发挥供给方和需求方的长处，把点击率的估计交给供给方，点击价值的估计交给需求方。供给方通过收集大量用户数据，可以准确评估点击率，转化效果则是广告商站内的行为，需要由他们自己的数据分析体系更准确的对其进行评估。</p>
</li>
<li><p>CPS/CPA/ROI:</p>
<p>按照销售订单数，转化行为数，投入产出比来计费。这种情况下，需求方只按照最后的转化收益来结算，极大程度的规避了风险。供给方不但需要估计点击率，还需要对点击价值做出估计，才能合理决定流量分配。</p>
<p>问题：</p>
<ol>
<li>转化行为对于供给方来说很难控制，也无法进行估计和优化。</li>
<li>存在广告主故意降低转化率以低成本获取大量品牌曝光的可能。</li>
</ol>
</li>
<li><p>CPT:</p>
<p>CPT(Cost Per Time)计费，这是针对大品牌广告主特定的广告活动，将某个广告位以独占的方式交给某广告主，按独占时间段收取费用。CPT虽然有额外的品牌效果和橱窗效应，但是无法利用受众定向技术。</p>
</li>
</ol>
<h2 id="广告投放和广告竞价"><a href="#广告投放和广告竞价" class="headerlink" title="广告投放和广告竞价"></a>广告投放和广告竞价</h2></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/29/%E9%93%BE%E6%8E%A5-%E8%A3%85%E8%BD%BD%EF%BC%8C%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/29/%E9%93%BE%E6%8E%A5-%E8%A3%85%E8%BD%BD%EF%BC%8C%E5%BA%93/" class="post-title-link" itemprop="url">链接,装载，库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-29 19:13:32" itemprop="dateCreated datePublished" datetime="2021-12-29T19:13:32+08:00">2021-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-30 12:00:26" itemprop="dateModified" datetime="2021-12-30T12:00:26+08:00">2021-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链接，装载，库"><a href="#链接，装载，库" class="headerlink" title="链接，装载，库"></a>链接，装载，库</h1><h2 id="从源代码到内存的通路"><a href="#从源代码到内存的通路" class="headerlink" title="从源代码到内存的通路"></a>从源代码到内存的通路</h2><h3 id="可执行文件的组成"><a href="#可执行文件的组成" class="headerlink" title="可执行文件的组成"></a>可执行文件的组成</h3><p>在链接前，需要将源文件编译为目标文件，目标文件链接为可执行文件。可执行文件（动态链接与运行时加载）由多个段组成：</p>
<ol>
<li>文件头：文件基本信息。</li>
<li>段表：描述各段的基本信息。</li>
<li>基本的代码段和数据段。</li>
<li>链接相关的。（符号的解析和重定位）</li>
<li>装载相关。</li>
</ol>
<h3 id="可执行文件的加载："><a href="#可执行文件的加载：" class="headerlink" title="可执行文件的加载："></a>可执行文件的加载：</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxuy176e6rj30u00znmy3.jpg" alt="img"></p>
<p>源代码编译而成的目标文件一般依赖系统的运行库和其他共享对象，将它们链接成可执行的程序并加载到内存。有以下这些方式“</p>
<ol>
<li>将所有相关文件静态链接成一个完整的可执行文件，然后加载到内存</li>
<li>将目标文件作为可执行文件，载入内存时由动态链接器加载其依赖的其他文件</li>
<li>将目标文件作为可执行文件，载入内存，由程序调用”依赖函数“加载或找到已加载到内存的函数地址，继续执行。</li>
</ol>
<h3 id="文件的映射"><a href="#文件的映射" class="headerlink" title="文件的映射"></a>文件的映射</h3><p>程序并不会完整的加载到内存中，会在执行时访问数据发生缺页时再加载。其中有两个关键的映射关系：、</p>
<ol>
<li>可执行文件各段与虚拟地址空间的映射。（VMA的数据结构）</li>
<li>虚拟地址空间与物理地址空间的映射。（页表）</li>
</ol>
<h3 id="进程虚拟地址空间的分布："><a href="#进程虚拟地址空间的分布：" class="headerlink" title="进程虚拟地址空间的分布："></a>进程虚拟地址空间的分布：</h3><p>代码区：</p>
<p>数据区：</p>
<p>​    静态数据区，动态数据区（堆，栈）</p>
<h2 id="符号-amp-模块，静态链接，动态链接"><a href="#符号-amp-模块，静态链接，动态链接" class="headerlink" title="符号&amp;模块，静态链接，动态链接"></a>符号&amp;模块，静态链接，动态链接</h2><h3 id="符号-amp-模块"><a href="#符号-amp-模块" class="headerlink" title="符号&amp;模块"></a>符号&amp;模块</h3><p>符号：符号最早起源于汇编的概念，汇编最早使用机器码（数字）来描述指令，操作数，地址值，后续改进为使用符号代替机器码。后续的符号也通常用于表示地址值，对于函数地址和变量地址都以符号来表示。</p>
<p>模块：现代语言中，通常会按照功能划分为不同的模块。在C语言中，若干变量和函数组成了一个模块，存放到一个.c源码文件中，这些源代码文件按照目录结构组织。</p>
<p>大规模软件通常会有很大规模的模块，这些模块直接相互依赖又相互独立。编译器会对每一个模块单独编译，每一个模块都会生成中间文件。中间文件最后会组合为一个单一的可执行文件。</p>
<p>因为模块间存在相互依赖，表现为：1. 模块间的函数调用 2. 模块间的变量访问</p>
<p>函数访问需要知道目标函数的地址，变量访问需要知道变量的地址，即：模块间符号的引用</p>
<h3 id="静态链接："><a href="#静态链接：" class="headerlink" title="静态链接："></a>静态链接：</h3><p>主要过程：</p>
<pre><code> 1. 地址和空间分配：
 + 扫描所有的目标文件，获得它们每个节的长度，属性，位置，并将目标文件中的符号表中所有的符号定义和符合引用收集，统一放到一个全局的符号表。链接器可以获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度和位置，建立映射关系。
 2. 符号决议
 + 将每个引用于它输入的可重定位目标文件的符号表中的一个确定的符合定义关联起来。
 + 相同模块的局部符号的引用。（每个模块的每个局部符合只有一个定义）
 + 全局符号：编译器遇到一个不在当前模块中定义的符号，会假设其再其他某个模块中定义，生成一个链接器符号表条目，并将其交给链接器处理。如果链接器在它的任何输入模块都找不到被引用符号的定义，就会输出一条错误信息并终止。
 + 多个目标文件出现相同名字的全局符合：
   1. 不允许有多个同名的强符号
   2. 如果有一个强符合与多个弱符合同名，选择强符合
   3. 多个弱符号同名，则从这些弱符合中任意选择一个。
 + 一个弱符号定义在多个目标文件
   1. 多个强符号类型不同（非法）
   2. 一个强符号，多个弱符合，出现类型不一致（同强符号，如果弱符合类型大于强，则发出警告）
   3. 多个弱符合类型不一致（选择最大的类型）
 3. **重定位**：
 + 链接器已经确定所有符合的虚拟地址了。链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="keyword">int</span> shared = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = &amp;a;</span><br><span class="line">    &amp;a = &amp;b;</span><br><span class="line">    &amp;b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c中定义了2个全局符号，一个变量<strong>shared</strong>，一个函数<strong>swap</strong>. a.c中定义了一个全局符号<strong>main</strong>，a.c中引用了b.c中的2个符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c b.c</span><br></pre></td></tr></table></figure>

<p>使用gcc将这两个文件编译为中间文件以后，a的中间文件中，符号<strong>shared</strong>,<strong>swap</strong>地址的值都为0.</p>
<p>在这个过程中，每个模块会有一个relocation table保存每个模块的那些符号需要重定位，整体上有一个symbol table保存符号地址。</p>
<p>静态链接过程中，各个中间文件会把relocation table中需要重定位的符号进行重定位。</p>
<p>静态链接的问题：1. 浪费磁盘和内存空间 - 各个可执行程序中依赖的库都需要链接到可执行文件中 2. 程序的更新，部署，发布会有很多麻烦 - 每当更新程序时，都需要重新进行编译和链接</p>
<h3 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h3><p>不对组成程序的目标文件进行链接，等到程序运行时才进行链接。即链接推迟到运行时进行。</p>
<p>动态链接还分为：non-lazy binding(程序运行前就会被绑定) lazy binding(符号第一次使用时)绑定</p>
<h4 id="基本实现："><a href="#基本实现：" class="headerlink" title="基本实现："></a>基本实现：</h4><ol>
<li>动态链接会涉及到运行时的链接以及多个文件的装载，必须有操作系统的支持。</li>
<li>在Linux中，ELF动态链接文件被称为 DSO（动态共享对象 Dynamic Shared Objects）</li>
<li>Windows (DLL Dynamic Linking Library)</li>
<li>当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库，然后进行重定位。</li>
</ol>
<h4 id="动态链接程序运行时地址空间的分布"><a href="#动态链接程序运行时地址空间的分布" class="headerlink" title="动态链接程序运行时地址空间的分布"></a>动态链接程序运行时地址空间的分布</h4><ol>
<li>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射即可执行文件。对于动态链接，除了可执行文件以外，还有它所依赖的共享目标文件。</li>
<li>共享目标文件的地址分配<ol>
<li>静态共享库（地址固定）将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为哪些已知的模块预留足够的控件。这个地址对不同的应用程序都是固定的。</li>
<li>动态共享库（地址不固定）在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对所有绝对地址引用进行重定位。</li>
</ol>
</li>
<li>地址无关代码：<ol>
<li>把指令中需要修改的部分都剥离出来，和数据部分放在一起。这样指令部分就可以保持不变，而数据部分在每个进程都有一个副本。</li>
</ol>
</li>
<li>地址引用的处理<ol>
<li>模块内部的函数调用<ol>
<li>调用函数和调用者在同一模块，相对位置固定，不需要重定位</li>
</ol>
</li>
<li>模块内部的数据访问<ol>
<li>统一模块，相对位置固定</li>
</ol>
</li>
<li>模块外部的函数调用<ol>
<li>会在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table, GOT)，当需要引用该全局变量，可以通过GOT中相对应的间接引用。链接器会在装载模块时查找每个变量所在的地址，然后填充GOT中各项，确保指向地址正确。</li>
</ol>
</li>
<li>模块外部的数据访问<ol>
<li>会在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table, GOT)，当需要引用该全局变量，可以通过GOT中相对应的间接引用。链接器会在装载模块时查找每个变量所在的地址，然后填充GOT中各项，确保指向地址正确。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="其他内容："><a href="#其他内容：" class="headerlink" title="其他内容："></a>其他内容：</h2><h3 id="函数调用与栈："><a href="#函数调用与栈：" class="headerlink" title="函数调用与栈："></a>函数调用与栈：</h3><ol>
<li>为什么值传递：函数调用时，参数和返回值都是放到栈帧中的，对参数的操作访问是访问的栈帧中的内容。出栈时相关的修改部分就会丢失。</li>
<li>局部变量的生命周期：因为局部变量时存放到栈帧当中，所以局部变量的生命周期也就只有函数调用过程中。</li>
</ol>
<h3 id="构造函数和析构函数存在："><a href="#构造函数和析构函数存在：" class="headerlink" title="构造函数和析构函数存在："></a>构造函数和析构函数存在：</h3><p>可执行文件除了代码段以外，构造函数和析构函数一般存放在.init和.finit段。</p>
<p>运行库中包含由入口函数，这是进程执行的入口，它会在main之前执行.init中的代码，main执行完毕后执行.finit</p>
<p>?defer关键词是否存放到.finit</p>
<h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>应用场景1：</p>
<p>问题：APMInsight用于监控SDK本身的崩溃。对于动态库，由于可以拿到动态库的地址范围，所有很好判断。但是对于静态库SDK来说，它本身就是代码文件的一个集合，会被加入到App的compile source当中一起被编译，链接。最早的方案是通过对SDK的进行扫描，获得所有的符号集合，通过筛选符号是否在符合集合中判断堆栈里的函数是否是SDK的函数。</p>
<p>前提概念：</p>
<p>Xcode的静态库：</p>
<p>由于Xcode编译源代码文件是按照compile source里顺序编译并链接的，并且是静态链接的。当整个SDK被添加到应用里的时候，相对于起始地址存在一个偏移量m，SDK的第一个符号symbol1的地址为addr1,第二个符号的地址为addr2,symbolN的地址为addrN,所有符号直接的地址偏差是固定的，也就是SDK的符号的地址范围为addr1-&gt;addrN，这样就可以在SDK的组件前后分别加上2个.c文件，获取自己的地址，这样就可以拿到SDK所属代码区间，在APM筛选过程中判断函数地址是否在SDK的范围内，即可筛选出是否为SDK的崩溃。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/28/Go%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/28/Go%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" class="post-title-link" itemprop="url">Go常用标准库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-28 01:32:09" itemprop="dateCreated datePublished" datetime="2021-12-28T01:32:09+08:00">2021-12-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/zhongsongzhi97.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
