<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-20 14:55:14 / Modified: 21:05:32" itemprop="dateCreated datePublished" datetime="2022-02-20T14:55:14+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微服务小结"><a href="#微服务小结" class="headerlink" title="微服务小结"></a>微服务小结</h1><h2 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h2><p>发展：由单体应用进化到服务化拆分部署，后期由于容器化技术的进步，微服务开始流行。</p>
<p>定义：将复杂臃肿的单体进行细粒度化的服务化拆分，将每个拆分出来的服务各自独立打包部署，由小团队进行开发和维护。</p>
<h2 id="如何将单体应用进行服务化拆分："><a href="#如何将单体应用进行服务化拆分：" class="headerlink" title="如何将单体应用进行服务化拆分："></a>如何将单体应用进行服务化拆分：</h2><ol>
<li><p>什么时候进行服务化拆分：</p>
<p>通常单体应用只在起步阶段使用，当功能开始复杂，人数变多就需要进行服务化拆分了</p>
</li>
<li><p>怎么进行拆分</p>
<p>纵向拆分：从业务维度进行拆分，标准是按照业务的关联度来决定的。</p>
<p>横向拆分：从公共且独立的功能维度拆分，标准按照是否有公共的被多个其他服务调用，且依赖的资源独立的功能。</p>
</li>
<li><p>服务化拆分的前置条件和问题：</p>
<ul>
<li>服务如何定义：通过接口，服务之间的调用通过接口描述来约定，约定的内容包括接口名，接口参数，接口返回值。</li>
<li>服务如何发布和订阅：通过一个注册中心，能够记录每个服务提供者的地址以供服务调用者查询。</li>
<li>服务如何监控：对于一个服务来说，需要关注的性能指标通常为QPS,AvgTime,P999这些指标，需要通用的监控方案，能够覆盖业务埋点，数据收集，数据处理到数据展示的全链路</li>
<li>服务如何治理：服务的数量变多以后，如果一个服务的性能出现问题，依赖的服务都会受到影响，可以设置一个调用阈值，如果超过这个值就会直接返回</li>
<li>故障如何定位：需要将用户请求进行标记，并在多个依赖服务系统之间继续传递，以便串联所有路径，从而进行故障定位。</li>
</ul>
</li>
</ol>
<h2 id="基本框架结构"><a href="#基本框架结构" class="headerlink" title="基本框架结构"></a>基本框架结构</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzk1r35gakj216u0qe778.jpg" alt="screenshot-20220220-161551"></p>
<p>流程：服务提供者向注册中心注册服务，声明自己的服务以及服务的地址，然后消费者请求注册中心，查询要调用的服务的地址，然后发起请求，得到请求结果以后按照约定的协议解析结果。在服务调用过程中，服务的请求耗时，调用量，成功率等指标会被记录，调用链路的信息也会被记录。</p>
<p>依赖的基本组件：</p>
<ol>
<li>服务描述</li>
<li>注册中心</li>
<li>服务框架</li>
<li>服务监控</li>
<li>服务追踪</li>
<li>服务治理</li>
</ol>
<h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><p>常见的服务描述方式：1. RESTful API, XML, IDL</p>
<p>RESTful API是基于HTTP协议的服务描述，通常使用Wiki或者Swagger进行管理。</p>
<p>XML配置常用于RPC协议的服务描述，IDL通常在Thrift和gRPC这类跨语言服务调用框架中。</p>
<h3 id="注册中心："><a href="#注册中心：" class="headerlink" title="注册中心："></a>注册中心：</h3><p>注册(服务提供者-&gt;注册中心)，订阅(服务消费者-&gt;注册中心)，返回（注册中心-&gt;服务消费者），通知（注册中心-&gt;服务消费者）</p>
<h3 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h3><p>通信协议，序列化协议等</p>
<h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p>指标收集，数据处理，数据展示</p>
<h3 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h3><ol>
<li>服务消费者发起调用前，需要在本地按照一定规则生成一个requestId，发起调用以后将requestId作为请求参数的一部分传递给服务提供者</li>
<li>服务提供者收到请求后，会记录下requestid，服务提供者继续请求其他服务，会生成一个自己的本地requestid然后也添加到参数中，这样就可以通过requestid串联整个调用链路了（需要监控链路，所以每个都要签一遍）</li>
</ol>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><p>单机故障：自动摘除故障节点</p>
<p>单IDC（互联网数据中心）故障：部署多IDC，自动切换IDC</p>
<p>依赖服务不可用：当一个服务依赖了另一个服务，当一个服务出现问题后，服务治理会通过熔断机制，一段时间内停止发起调用而直接返回。</p>
<h2 id="注册中心和注册中心原理"><a href="#注册中心和注册中心原理" class="headerlink" title="注册中心和注册中心原理"></a>注册中心和注册中心原理</h2><p>角色：1. 服务提供者(RPC Server)，服务消费者(RPC Client)，服务注册中心(Registry)</p>
<p>RPC Server:在启动时，根据服务发布文件中的配置信息，向Registry注册服务，并定期发送心跳汇报存活状态</p>
<p>RPC Client:调用服务时，根据服务引用文件中的配置信息，向Registry订阅服务，将Registry返回的服务节点缓存到本地，并与RPC Server建立连接</p>
<p>Server变动：当Server节点变动时，Registry会同步变更，Client感知后会刷新本地的服务节点</p>
<p>RPC发起调用时，会从本地的服务节点中，基于负载均衡算法选择一台RPC Server发起调用</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzk3v649n7j21dw0u0wkp.jpg" alt="screenshot-20220220-172909"></p>
<p>实现的方式：</p>
<ol>
<li><p>注册中心的API：</p>
<ol>
<li>服务注册 2. 服务注销 3. 心跳汇报 4. 服务订阅 5. 服务变更查询</li>
</ol>
</li>
<li><p>集群部署:</p>
<p>集群部署加上分布式一致性协议来保证高可用和数据一致性</p>
<p>Zookeeper:Zab加上主从</p>
</li>
<li><p>目录存储：</p>
<p>Zookeepre会采用层次化的目录结构。</p>
</li>
<li><p>服务健康状态检测：Zookeeper通过客户端和服务端的长连接和会话超时控制机制来检测健康状态</p>
</li>
<li><p>服务状态变更通知：有服务提供者加入或者删除，注册中心会立刻通知所有订阅了该服务的服务消费者</p>
</li>
<li><p>白名单机制：注册中心提供一个白名单，只有添加到白名单的RPC Server才可以调用注册中心的注册接口</p>
</li>
</ol>
<p>Todo：Zookeeper</p>
<h2 id="如何监控微服务的调用："><a href="#如何监控微服务的调用：" class="headerlink" title="如何监控微服务的调用："></a>如何监控微服务的调用：</h2><ol>
<li><p>监控的对象：</p>
<p>用户端监控，接口监控，资源监控，基础监控（CPU利用率，内存使用量，I/O读写量，网卡带宽）</p>
</li>
<li><p>监控的指标：</p>
<p>请求量(QPS)，响应时间，错误率</p>
</li>
<li><p>监控的维度：</p>
<p>分机房维度，单机维度，时间维度，核心维度（核心业务和非核心业务）</p>
</li>
</ol>
<h2 id="监控系统原理"><a href="#监控系统原理" class="headerlink" title="监控系统原理"></a>监控系统原理</h2><ol>
<li><p>数据采集：</p>
<p>服务主动上报：在业务中加入数据收集代码逻辑</p>
<p>代理收集：将调用的详细信息记录到本地日志，后面通过代理去解析本地日志，在上报服务</p>
</li>
<li><p>数据传输：</p>
<p>UDP传输：</p>
<p>消息队列传输：</p>
</li>
<li><p>数据处理：</p>
<p>聚合：各种维度聚合（接口维度/机器维度）</p>
<p>存储：各类数据库</p>
</li>
<li><p>数据展示:</p>
<ol>
<li>各种图形（曲线图，饼状图，格子图）</li>
</ol>
</li>
</ol>
<h3 id="如何追踪微服务调用"><a href="#如何追踪微服务调用" class="headerlink" title="如何追踪微服务调用"></a>如何追踪微服务调用</h3><ol>
<li><p>为什么需要追踪微服务调用</p>
<p>因为在微服务的架构下，一次请求会涉及多个服务方，整个业务链路很长，需要追踪微服务调用才能找到是什么导致的失败</p>
</li>
<li><p>微服务追踪可以用来做什么</p>
<ol>
<li>优化系统瓶颈（根据链路上的耗时）</li>
<li>优化链路调用路径（减少服务依赖）</li>
<li>生成网络拓扑（用于服务监控）</li>
<li>透明传输数据（业务上可能需要将一些数据在整个微服务调用链路都带上）</li>
</ol>
</li>
<li><p>服务追踪的原理：</p>
<p>基于调用链：使用一个全局唯一的ID将分布在各个服务节点上的同一个请求串联</p>
<p>格式eg: traceid(全局id)+spanid（服务方的链路组合）+annonation（业务方埋点）</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzk93wcrvej21mc0mq767.jpg" alt="1921645360224_.pic"></p>
</li>
</ol>
<h2 id="微服务治理的手段"><a href="#微服务治理的手段" class="headerlink" title="微服务治理的手段"></a>微服务治理的手段</h2><p>可能出现的问题：</p>
<ol>
<li>注册中心：宕机，和服务消费者或者服务提供者的网络不通</li>
<li>服务提供者：节点宕机，节点性能变慢，短时间出现问题，与消费者网络不通，与注册中心网络不通</li>
<li>服务消费者：与注册中心，提供者网络不通</li>
</ol>
<p>常见的服务治理的手段：</p>
<ol>
<li><p>节点管理：</p>
<p>注册中心主动摘除：服务提供者和注册中心使用心跳机制，如果超时就会摘除并推送给消费者</p>
<p>服务消费者摘除：探活机制放在服务消费端，如果消费者调用服务提供者节点失败，就将这个节点从内存的列表中移除</p>
</li>
<li><p>负载均衡：</p>
<p>服务提供者一般是以集群的方式存在。</p>
<ol>
<li>随机算法 2.轮询算法 3. 最少活跃调用（消费方维护服务提供方的每一个节点的调用次数，按连接数倒序排）4. 一致性hash算法</li>
</ol>
</li>
<li><p>服务路由：</p>
<p>路由规则：按照一定的规则，比如条件表达式或者正则表达式来限定服务节点的选择范围</p>
<ul>
<li>业务存在灰度发布的需求：可以选择只让部分人使用变更的功能，比如按尾号进行灰度，只有符合要求的才能访问到服务节点</li>
<li>多机房就近访问的需求：通过IP端来控制访问，优先选择就近的机房</li>
</ul>
<p>如何配置路由规则：1. 静态配置（在服务消费者本地存放，但是改动就不方便） 2.动态配置（路由规则存在注册中心，消费者定期去注册中心拉新的路由规则来保持同步）</p>
</li>
<li><p>服务容错：</p>
<p>FailOver:失败自动切换，消费者调用失败或者超时以后，选择下一个节点重新发起调用。要求调用的操作时幂等的（即同一个调用返回结果相同），一般是读请求的场景</p>
<p>FailBack:失败通知，调用失败或超时以后，不会重试，而是根据失败的详细信息来决定下一步的执行策略。对于非幂等的调用，如果失败或超时，需要去查看调用是否生效。</p>
<p>FailCache:失败缓存，调用失败或超时后，不立即重试，而是隔一段时间再次尝试，也是幂等调用适合。</p>
<p>FailFast:快速失败，调用失败以后不再重试，一般对于非核心业务调用会这样使用。快速失败，只记录一个失败日志。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/13/Netty%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/13/Netty%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Netty小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-13 15:43:14 / Modified: 16:58:24" itemprop="dateCreated datePublished" datetime="2022-02-13T15:43:14+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty小结"><a href="#Netty小结" class="headerlink" title="Netty小结"></a>Netty小结</h1><h2 id="Netty的逻辑架构"><a href="#Netty的逻辑架构" class="headerlink" title="Netty的逻辑架构"></a>Netty的逻辑架构</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzbxnyxlioj30sa0o276s.jpg" alt="Drawing 1.png"></p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>主从Reactor多线程模型</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzbxm0052oj31860qw42m.jpg" alt="6.png"></p>
<p>主从多线程模型由多个Reactor线程组成，每个Reactor线程都有独立的Selector对象。</p>
<p>MainReactor只负责处理客户端连接的Accept事件，连接建立成功后会将创建好的连接对象注册到SubReactor。</p>
<p>之后由SubReactor分配线程池中的I/O线程与其连接绑定，由该I/O线程负责连接生命周期内的所有I/O事件。</p>
<p>步骤：</p>
<ol>
<li>连接注册：Channel建立后，注册到Reactor线程中的Selector选择器</li>
<li>事件轮询：轮询Selector中注册的所有Channel的I/O事件</li>
<li>事件分发：为准备就绪的I/O事件分配响应的处理线程</li>
<li>任务处理：Reactor线程还负责任务队列中的非I/O任务，每个工作线程从各自维护的任务队列中取出任务异步执行。</li>
</ol>
<h2 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzby6ykcedj30zk0k0did.jpg" alt="6.png"></p>
<ol>
<li>BossEventLoopGroup(包含一个或多个EventLoop)负责监听客户端上的Accept事件，事件触发时会将事件（即Channel）注册到WorkerEventLoopGroup(包含一个或多个EventLoop)中的某个EventLoop上。</li>
<li>EventLoop在事件轮询时读到了Channel中的数据后，会调用绑定的ChannelPipeline进行事件传播，ChannelPipeline是线程安全的。数据传入到ChannelPipeline的第一个Handler，数据处理完成后会传递给下一个ChannelHandler，整个过程是串行化执行(增加吞吐量和降低业务难度)的。</li>
</ol>
<h2 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h2><p>问题：</p>
<ul>
<li>ChannelPipeline 与 ChannelHandler 的关系是什么？它们之间是如何协同工作的？</li>
<li>ChannelHandler 的类型有哪些？有什么区别？</li>
<li>Netty 中 I/O 事件是如何传播的？</li>
</ul>
<p>ChannelPipeline概述：</p>
<p>Pipeline的意思是管道，它在Netty中的作用，就是把原始的网络字节流经过Pipeline，进一步加工包装</p>
<h2 id="易用性API接口"><a href="#易用性API接口" class="headerlink" title="易用性API接口"></a>易用性API接口</h2><h2 id="对数据协议，序列化的支持"><a href="#对数据协议，序列化的支持" class="headerlink" title="对数据协议，序列化的支持"></a>对数据协议，序列化的支持</h2><h2 id="OS层面的零拷贝"><a href="#OS层面的零拷贝" class="headerlink" title="OS层面的零拷贝"></a>OS层面的零拷贝</h2><p>传统的数据拷贝：</p>
<p>从文件中读取数据，然后将数据传输到网络上</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzbz1jzozgj31jw0tctb4.jpg" alt="Drawing 0.png"></p>
<ol>
<li>用户线程发起read()调用以后，上下文从用户态切换到内核态，从文件读取数据到内核缓冲区</li>
<li>从内核态切换到用户态，将数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户线程</li>
<li>用户线程调用send()，用户态切换到内核态，请求数据从用户态缓冲区拷贝到内核态的Socket缓冲区</li>
<li>最终send()结束，从内核态返回到用户态。发送了4次上下文切换和4次拷贝。</li>
</ol>
<p>问题：传统拷贝为何不是直接将数据传输到用户缓冲区？引入内核缓冲区可以充当缓存的作用，这样就可以实现文件数据的预读，提升 I/O 的性能</p>
<p>比较好的流程：文件读取到内核缓冲区，然后从内核缓冲区直接传输到Socket缓冲区（）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzbzcgobwbj31k60qiwgx.jpg" alt="Drawing 1.png"></p>
<p>这里进行了3次拷贝，0次上下文切换</p>
<p>还可以优化：就是不需要从内核缓冲区拷贝到Socket缓冲区，只在Socket缓冲区记录必要的信息，然后直接从内核缓冲区拷贝即可，这样就只有2次拷贝，这里就只有2次DMA拷贝，0次CPU拷贝了 -&gt; 所以是零拷贝</p>
<h2 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h2><ol>
<li>使用堆外内存 -&gt;  VM内部的数据需要拷贝到VM外部才能进行系统调用</li>
<li>CompositeByteBuf</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/" class="post-title-link" itemprop="url">内存分配器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-10 21:02:56 / Modified: 21:03:57" itemprop="dateCreated datePublished" datetime="2022-02-10T21:02:56+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv6nhr2j30u00vyae4.jpg" alt="内存分配器"></p>
<p>程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。</p>
<p>栈：函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；</p>
<p>堆：不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv57r7wj30xc0h8dgg.jpg" alt="mutator-allocator-collector"></p>
<p>分配方法：一般编程语言的内存分配器包括两种，一种是线性分配器，还有一种是空闲列表分配器。</p>
<h3 id="线性分配器"><a href="#线性分配器" class="headerlink" title="线性分配器"></a>线性分配器</h3><p>使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置</p>
<p>问题：线性分配器无法在内存被释放时重用内存。</p>
<p>因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。</p>
<p>因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv5p7g4j30xc082t8w.jpg" alt="bump-allocator"></p>
<h3 id="空闲列表分配器"><a href="#空闲列表分配器" class="headerlink" title="空闲列表分配器"></a>空闲列表分配器</h3><p>类似与早期操作系统的，使用链表管理内存的结构。</p>
<p>这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 𝑂(𝑛)。</p>
<p>选择策略上有4种:</p>
<ol>
<li>首次适应</li>
<li>循环首次适应</li>
<li>最优适应</li>
<li>隔离适应</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv6596yj30xc08wdga.jpg" alt="free-list-allocator"></p>
<h3 id="Go采用的方式-空闲列表分配器配合类似隔离适应"><a href="#Go采用的方式-空闲列表分配器配合类似隔离适应" class="headerlink" title="Go采用的方式 - 空闲列表分配器配合类似隔离适应"></a>Go采用的方式 - 空闲列表分配器配合类似隔离适应</h3><h4 id="基本数据结构："><a href="#基本数据结构：" class="headerlink" title="基本数据结构："></a>基本数据结构：</h4><p>该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，它会在上图中找到满足条件的空闲内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。即先找到合适的链表，再去找合适的内存块。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv74k4aj30xc0gedgs.jpg" alt="segregated-list"></p>
<h4 id="分级分配："><a href="#分级分配：" class="headerlink" title="分级分配："></a>分级分配：</h4><p>线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 <code>malloc</code> 还要快很多。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。</p>
<p>运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">微对象</td>
<td align="center"><code>(0, 16B)</code></td>
</tr>
<tr>
<td align="center">小对象</td>
<td align="center"><code>[16B, 32KB]</code></td>
</tr>
<tr>
<td align="center">大对象</td>
<td align="center"><code>(32KB, +∞)</code></td>
</tr>
</tbody></table>
<p><strong>表 7-1 对象的类别和大小</strong></p>
<p>因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。</p>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>内存分成不同的级别分别管理，线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv4rcpzj30xc0hs3zj.jpg" alt="multi-level-cache"></p>
<p>32KB以上的对象，内存分配器会直接分配到页堆，线程缓存不足时，会使用中心缓存进行补充</p>
<h4 id="虚拟内存布局"><a href="#虚拟内存布局" class="headerlink" title="虚拟内存布局"></a>虚拟内存布局</h4><p>稀疏内存：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv92p1nj30xj0dmaar.jpg" alt="heap-after-go-1-11"></p>
<p>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题，不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂。</p>
<p>如图所示，使用二维的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.heapArena"><code>runtime.heapArena</code></a> 数组管理所有的内存，每个单元都会管理 64MB 的内存空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">	bitmap       [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line">	spans        [pagesPerArena]*mspan</span><br><span class="line">	pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	checkmarks   *checkmarksMap</span><br><span class="line">	zeroedBase   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bitmap</code> 用于标识 <code>arena</code> 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否空闲；</p>
<p><code>arena</code> 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</p>
<p><code>zeroedBase</code> 字段指向了该结构体管理的内存的基地址。</p>
<h3 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h3><p>最重要的几种组件：runtime.mspan, runtime.mcache, runtime.mcentral, runtime.mheap</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv9hn3pj30xj0oqtaq.jpg" alt="go-memory-layout"></p>
<p>Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 用于处理微对象和小对象的分配，它们会持有内存管理单元 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>。</p>
<p>每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 持有的 134 个中心缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 中获取新的内存单元，中心缓存属于全局的堆结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a>，它会从操作系统中申请内存。</p>
<h4 id="内存管理单元runtime-mspan"><a href="#内存管理单元runtime-mspan" class="headerlink" title="内存管理单元runtime.mspan"></a>内存管理单元runtime.mspan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *mspan</span><br><span class="line">	prev *mspan</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mspan是Go语言内存管理的基本单元，它们会构成双向链表的形式，运行时使用mSpanList来使用</p>
<p>每个mspan都管理着npages个大小为8KB的页（操作系统内存页的整数倍）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	startAddr <span class="keyword">uintptr</span> <span class="comment">// 起始地址</span></span><br><span class="line">	npages    <span class="keyword">uintptr</span> <span class="comment">// 页数</span></span><br><span class="line">	freeindex <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	allocBits  *gcBits</span><br><span class="line">	gcmarkBits *gcBits</span><br><span class="line">	allocCache <span class="keyword">uint64</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 <span class="number">8</span>KB；</span><br><span class="line">freeindex — 扫描页中空闲对象的初始索引；</span><br><span class="line">allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；</span><br><span class="line">allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；</span><br></pre></td></tr></table></figure>

<p>mspan管理内存：</p>
<ol>
<li><p>当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv9ye3pj30xj0gemxn.jpg" alt="mspan-and-pages"></p>
</li>
<li><p>当用户程序或者线程向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 申请内存时，它会使用 <code>allocCache</code> 字段以对象为单位在管理的内存中快速查找待分配的空间。如果我们能在内存中找到空闲的内存单元会直接返回，当内存中不包含空闲的内存时，上一级的组件 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 会为调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.refill"><code>runtime.mcache.refill</code></a> 更新内存管理单元以满足为更多对象分配内存的需求。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv84qmlj30xj0d2mxx.jpg" alt="mspan-and-objects"></p>
</li>
</ol>
<p>每个内存管理单元的状态使用mSpanStateBox管理</p>
<p>该状态可能处于 <code>mSpanDead</code>、<code>mSpanInUse</code>、<code>mSpanManual</code> 和 <code>mSpanFree</code> 四种情况。当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 在空闲堆中，它会处于 <code>mSpanFree</code> 状态；当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 已经被分配时，它会处于 <code>mSpanInUse</code>、<code>mSpanManual</code> 状态，运行时会遵循下面的规则转换该状态：</p>
<ul>
<li>在垃圾回收的任意阶段，可能从 <code>mSpanFree</code> 转换到 <code>mSpanInUse</code> 和 <code>mSpanManual</code>；</li>
<li>在垃圾回收的清除阶段，可能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li>
<li>在垃圾回收的标记阶段，不能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	state       mSpanStateBox</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="跨度类"><a href="#跨度类" class="headerlink" title="跨度类"></a>跨度类</h5><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanClass"><code>runtime.spanClass</code></a> 是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的跨度类，它决定了内存管理单元中存储的对象大小和个数。</p>
<p>Go 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.class_to_size"><code>runtime.class_to_size</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.class_to_allocnpages"><code>runtime.class_to_allocnpages</code></a> 等变量中。</p>
<p><strong>跨度类的数据</strong></p>
<p>会有ID为0的跨度类管理超过32KB的对象</p>
<table>
<thead>
<tr>
<th align="center">class</th>
<th align="right">bytes/obj</th>
<th align="right">bytes/span</th>
<th align="right">objects</th>
<th align="center">tail waste</th>
<th align="center">max waste</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="right">8</td>
<td align="right">8192</td>
<td align="right">1024</td>
<td align="center">0</td>
<td align="center">87.50%</td>
</tr>
<tr>
<td align="center">2</td>
<td align="right">16</td>
<td align="right">8192</td>
<td align="right">512</td>
<td align="center">0</td>
<td align="center">43.75%</td>
</tr>
<tr>
<td align="center">3</td>
<td align="right">24</td>
<td align="right">8192</td>
<td align="right">341</td>
<td align="center">0</td>
<td align="center">29.24%</td>
</tr>
<tr>
<td align="center">4</td>
<td align="right">32</td>
<td align="right">8192</td>
<td align="right">256</td>
<td align="center">0</td>
<td align="center">46.88%</td>
</tr>
<tr>
<td align="center">5</td>
<td align="right">48</td>
<td align="right">8192</td>
<td align="right">170</td>
<td align="center">32</td>
<td align="center">31.52%</td>
</tr>
<tr>
<td align="center">6</td>
<td align="right">64</td>
<td align="right">8192</td>
<td align="right">128</td>
<td align="center">0</td>
<td align="center">23.44%</td>
</tr>
<tr>
<td align="center">7</td>
<td align="right">80</td>
<td align="right">8192</td>
<td align="right">102</td>
<td align="center">32</td>
<td align="center">19.07%</td>
</tr>
<tr>
<td align="center">…</td>
<td align="right">…</td>
<td align="right">…</td>
<td align="right">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">67</td>
<td align="right">32768</td>
<td align="right">32768</td>
<td align="right">1</td>
<td align="center">0</td>
<td align="center">12.50%</td>
</tr>
</tbody></table>
<h4 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>，这些内存管理单元都存储在结构体的 <code>alloc</code> 字段中，线程缓存在刚刚被初始化时是不包含 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的，只有当用户程序申请内存时才会从上一级组件获取新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 满足内存分配的需求。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv8lr0vj30xj0b4dgd.jpg" alt="mcache-and-mspans"></p>
<ol>
<li><p>初始化：在初始化处理器时，在系统栈中使用mheap的线程缓存分配器初始化，mcache</p>
</li>
<li><p>替换：<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.refill"><code>runtime.mcache.refill</code></a> 会为线程缓存获取一个指定跨度类的内存管理单元，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：</p>
</li>
<li><p>微分配器：线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门管理 16 字节以下的对象。微分配器只会用于分配非指针类型的内存，上述三个字段中 <code>tiny</code> 会指向堆中的一片内存，<code>tinyOffset</code> 是下一个空闲内存所在的偏移量，最后的 <code>local_tinyallocs</code> 会记录内存分配器中分配的对象个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">	tiny             <span class="keyword">uintptr</span></span><br><span class="line">	tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">	local_tinyallocs <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="中心缓存"><a href="#中心缓存" class="headerlink" title="中心缓存"></a>中心缓存</h4><p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanSet"><code>runtime.spanSet</code></a>，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p>
<h4 id="页堆"><a href="#页堆" class="headerlink" title="页堆"></a>页堆</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv4dp1mj30xj0aa74v.jpg" alt="mheap-and-mcentrals"></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 <code>central</code>，另一个是管理堆区内存区域的 <code>arenas</code> 以及相关字段。</p>
<p>页堆中包含一个长度为 136 的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 数组，其中 68 个为跨度类需要 <code>scan</code> 的中心缓存，另外的 68 个是 <code>noscan</code> 的中心缓存。</p>
<ol>
<li><p>内存管理单元：</p>
<p>mspan获取新的单元是通过mheap.alloc获取的</p>
<p>先调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.reclaim"><code>runtime.mheap.reclaim</code></a> 方法回收一部分内存，随后运行时通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.allocSpan"><code>runtime.mheap.allocSpan</code></a> 分配新的内存管理单元</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npages <span class="keyword">uintptr</span>, spanclass spanClass, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">			h.reclaim(npages)</span><br><span class="line">		&#125;</span><br><span class="line">		s = h.allocSpan(npages, <span class="literal">false</span>, spanclass, &amp;memstats.heap_inuse)</span><br><span class="line">	&#125;)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩容：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.grow"><code>runtime.mheap.grow</code></a> 会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：</p>
<ol>
<li>通过传入的页数获取期望分配的内存空间大小以及内存的基地址；</li>
<li>如果 <code>arena</code> 区域没有足够的空间，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.sysAlloc"><code>runtime.mheap.sysAlloc</code></a> 从操作系统中申请更多的内存；</li>
<li>扩容 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 持有的 <code>arena</code> 区域并更新页分配器的元信息；</li>
<li>在某些场景下，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.pageAlloc.scavenge"><code>runtime.pageAlloc.scavenge</code></a> 回收不再使用的空闲内存页；</li>
</ol>
</li>
</ol>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>堆上所有的对象都是通过runtime.newobject分配内存的，其会调用runtime.mallocgc分配</p>
<p>可以看到，其会按照对象大小来按不同的方式进行内存分配</p>
<p><strong>三种对象</strong></p>
<ul>
<li>微对象 <code>(0, 16B)</code> — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
<li>小对象 <code>[16B, 32KB]</code> — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
<li>大对象 <code>(32KB, +∞)</code> — 直接在堆上分配内存；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	c := gomcache()</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">			<span class="comment">// 微对象分配</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 小对象分配</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象分配</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	publicationBarrier()</span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="微对象"><a href="#微对象" class="headerlink" title="微对象"></a>微对象</h4><p>小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p>
<p>微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 <code>maxTinySize</code> 是可以调整的，在默认情况下，内存块的大小为 16 字节。<code>maxTinySize</code> 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；<code>maxTinySize</code> 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。</p>
<ul>
<li>微分配器</li>
</ul>
<h4 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h4><p>小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象，小对象的分配可以被分成以下的三个步骤：</p>
<ol>
<li>确定分配对象的大小以及跨度类 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanClass"><code>runtime.spanClass</code></a>；</li>
<li>从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memclrNoHeapPointers"><code>runtime.memclrNoHeapPointers</code></a> 清空空闲内存中的所有数据；</li>
</ol>
<h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.allocLarge"><code>runtime.mcache.allocLarge</code></a> 分配大片内存</p>
<h4 id="内存分配算法TCMalloc"><a href="#内存分配算法TCMalloc" class="headerlink" title="内存分配算法TCMalloc"></a>内存分配算法TCMalloc</h4><p>在 TCMalloc 内存管理内部分为两个部分：线程内存（thread memory)和页堆（page heap）。</p>
<ol>
<li>每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。PS, java 中叫TLAB：Thread Local Allocation Buffer。Go 中叫mcache（挂在每一个P上）</li>
<li>TCMalloc 管理的堆由一组页组成，<strong>一组连续的页面被表示为 span</strong>。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。</li>
</ol>
<p>Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象（小于 32kb）和大对象分配两种分配类型，其管理的内存单元称为 span。但与 tcmalloc 存在一定差异。 这个差异来源于 Go 语言被设计为没有显式的内存分配与释放， 完全依靠编译器与运行时的配合来自动处理，因此也就造就了内存分配器、垃圾回收器两大组件。统一管理内存会提前分配或一次性释放一大块内存， 进而减少与操作系统沟通造成的开销，进而提高程序的运行性能。 支持内存管理另一个优势就是能够更好的支持垃圾回收。</p>
<h4 id="内存分配器的核心组件："><a href="#内存分配器的核心组件：" class="headerlink" title="内存分配器的核心组件："></a>内存分配器的核心组件：</h4><ol>
<li><p>heapArena: 保留整个虚拟地址空间</p>
</li>
<li><p>mheap：分配的堆，在页大小为 8KB 的粒度上进行管理</p>
</li>
<li><p>mspan：是 mheap 上管理的一连串的页</p>
</li>
<li><p>mcentral：收集了给定大小等级的所有 span</p>
</li>
<li><p>mcache：为 per-P 的缓存。</p>
</li>
</ol>
<p><strong>go 基于上述 struct 提供了 runtime.newobject 用于goroutine 代码申请内存，由gc 负责回收</strong>。runtime.newobject 就是内存分配的核心入口</p>
<p>页是向操作系统申请内存的最小单位，目前设计为 8KB。传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8pv7mc99j337v0u0wkl.jpg" alt="img"></p>
<p>Go 内存管理的一般思想是使用不同的内存结构为不同大小的对象使用不同的内存缓存级别来分配内存。将一个从操作系统接收的连续地址的块切分到多级缓存来减少锁的使用，同时<strong>根据object的大小</strong>分配内存减少内存碎片以提高内存分配的效率和在内存释放之后加快 GC 运行的速度。mcache ==&gt; mcentral ==&gt; mheap（向堆申请一个arena） ==&gt; 堆</p>
<ol>
<li>大于 32K 的大对象直接从 mheap 分配。</li>
<li>小于 16B 的使用 mcache 的微型分配器分配</li>
<li>对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配</li>
<li>如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请</li>
<li>如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li>
<li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本。</li>
</ol>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/MQ%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/MQ%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">MQ小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-10 20:50:39" itemprop="dateCreated datePublished" datetime="2022-02-10T20:50:39+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-28 01:59:58" itemprop="dateModified" datetime="2022-02-28T01:59:58+08:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><ol>
<li>队列模型</li>
<li>发布-订阅模型：消息的发送者，消息的接受者，服务端存放消息的容器(Topic)。发布者将消息发送到主题中，订阅者在接收消息前需要先订阅”Topic“，每份订阅，订阅者可以收到主题的所有消息。</li>
</ol>
<p>区别：发布-订阅模型中，一个消息可以被多次消费。</p>
<h2 id="RocketMQ结构"><a href="#RocketMQ结构" class="headerlink" title="RocketMQ结构"></a>RocketMQ结构</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzsjyzaxx7j21pc0pgadl.jpg" alt="RocketMQ 架构图"></p>
<p>角色:</p>
<ol>
<li><p>Producer: 消息生产者，可集群部署。Producer随机与NameServer集群中的一个节点建立长连接，定期从NameServer集群中的一个节点建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master建立长连接，且定期向Master发送心跳。</p>
</li>
<li><p>Consumer: 消息消费者，可集群部署。建立连接方式和生产者一样。支持push（长轮询的拉）和pull两种消费方式。支持集群（同一个Topic的同一条消息只会被一个消费者实例消费）和广播模式（广播给所有订阅了该Topic的消费实例）的消费。</p>
</li>
<li><p>NameServer: 类似Zookeeper的作用（但是无状态节点），支持Broker的动态注册和发现（路由注册中心），为何所有的Broker和Topic的路由信息。Broker启动需要向所有的NameServer实现注册，并定期发送心跳信息。每个NameServer都维护了所有的Broker和Topic路由信息。</p>
</li>
<li><p>Broker：Broker主要负责消息的存储，投递，查询以及服务高可用。</p>
<p>Broker的部署：1. 单主 2. 多主 3. 多主多从 - 异步复制 4。 多主多从 - 同步双写</p>
</li>
</ol>
<p>执行流程：</p>
<ol>
<li>先启动NameServer（注册中心）服务，监控端口等待Broker，Producer，Consumer。</li>
<li>启动Broker跟所有的NameServer保存长连接并且定期发送心跳。</li>
<li>创建Topic并直到保存在哪些Broker</li>
<li>Producer向主Broker发送消息并且给消息打tag进行分组</li>
<li>Consumer监听所有Broker的消息</li>
</ol>
<h3 id="存储的结构："><a href="#存储的结构：" class="headerlink" title="存储的结构："></a>存储的结构：</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzskoa7lq1j20vq0owwhr.jpg" alt="RocketMQ Message Store"></p>
<ol>
<li>CommitLog:存储所有消息主体和元数据，消息顺序写入CommitLog，一个写满就新建一个。</li>
<li>ConsumeQueue: 消费队列，目的是提供消费性能。保存了指定Topic下消息队列消息在CommitLog的起始偏移量，消息大小和消息Tag的hashcode</li>
<li>IndexFile: 提供了一种可以通过key或时间区间来查询消息的方法</li>
</ol>
<p>RocketMQ的存储以Broker为单位，Broker(ConsumerLog消息文件&amp;N*ConsumerQueue索引文件)，</p>
<ol>
<li>写入消息：Broker上所有Topic，队列的消息都按照自然顺序追加写入到同一个消息文件中</li>
<li>查找消息：根据队列的消息序号，计算索引的全局位置(索引序号 x 索引固定长度20)，直接读取这条索引，然后根据索引查找到消息的位置</li>
<li>存储方式mmap: 一般的数据拷贝需要4次操作，RocketMQ使用了零拷贝技术，只需要2次</li>
<li>同步刷盘和异步刷盘：异步刷盘：当消息累计到一定量后统一磁盘写入。同步刷盘：返回写成功就写入磁盘。</li>
</ol>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>使用”请求-确认“机制确保消息不会丢失</p>
<ol>
<li><p>生成端：</p>
<p>生产者先将消息发送给服务端(Broker)，Broker收到消息后将消息写入Topic后再给生产者发送确认响应。如果没有收到响应则会重复发送消息。</p>
</li>
<li><p>消费端：</p>
<p>消费者在收到消息并完成消费业务逻辑后，也会向服务端发送消费成功的确认。（注：应该在完成消费业务逻辑以后再进行确认）</p>
</li>
<li><p>存储阶段：</p>
<p>如果Broker是多个节点组成的集群，需要将Broker集群配置成：至少将消息发送到2个以上的节点在回复确认。</p>
</li>
</ol>
<p>由于”请求-确认“机制，为了确保消息的有序性，一条消息被成功消费前，下一条消息是不能被消费的。所有扩容Consumer时需要扩容Consumer Queue</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>解决 -&gt; 在分布式系统中保持一致性</p>
<p>成员：协调者，参与者</p>
<ol>
<li>投票阶段：协调者向参与者询问是否可以指向操作，参与者执行完(agreement/abort)并且记录redo/undo日志。当所有参与者都执行完进行提交阶段。</li>
<li>提交阶段：如果都同意，则协调者发送commit，否则rollback。参与者完成操作后返回消息，如果协调者收到所有的返回消息则结束事务，否则回滚。</li>
</ol>
<p>EG：</p>
<p>订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车删除（使用消息队列异步清理购物车）。需要保证本地事务和发消息这两步要么都成功，要么都失败。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gz8phzrxhaj32g70u0q7b.jpg" alt="img"></p>
<ol>
<li>订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</li>
<li>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。</li>
</ol>
<h2 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h2><ol>
<li><p>如何保证消息不被重复消费或者保证其幂等？</p>
<p>在业务层实现，通过业务id，可以使用数据库和redis来保存当前业务id是否已经被消费</p>
</li>
<li><p>如何保证消息的可靠性？预防消息丢失</p>
<p>Producer: 使用请求-Ack机制</p>
<p>Broker: 通过同步刷盘或者异步刷盘的方式将其持久化到CommitLog</p>
<p>Consumer: 消费者为何一个MessageQueue队列，保存消费进度的Offset，失败就定时重试，成功就更新Offset</p>
</li>
<li><p>如何保证消息的顺序性?</p>
<p>全局消息：需要在生产端只保留一个读写队列，消费端只有一个消费队列。但是会降低使用性。</p>
<p>分区消息：生产者将同一订单的消息发到同一个MessageQueu，消费端保证从同一个MessageQueue取出消息并且不并发处理</p>
</li>
<li><p>如何解决消息的延时和过期失效问题？</p>
<p>当消费端宕机或者消费速度很慢导致 Broker 中消息大量积压，如有积压时长超过阈值就会被清理掉导致数据丢失。可以使用一段程序功能先将丢失的丢失的消息存储起来，等系统负载较低时将这部分消息重新发送给Broker。</p>
</li>
<li><p>消息队列满了或者堆积过多怎么办？</p>
<ol>
<li>新建Topic把积压的消息的Topic分发到新建的Topic中</li>
<li>停掉旧的消费端，将新建的Topic都启动对应的消费端实例</li>
<li>通过更强的消费能力把积压消息处理完</li>
</ol>
</li>
</ol>
<h2 id="高性能读写数据"><a href="#高性能读写数据" class="headerlink" title="高性能读写数据"></a>高性能读写数据</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzslrk5t8yj20um0c2gmx.jpg" alt="在这里插入图片描述"></p>
<p>MMAP技术: 就是进行文件映射和内存映射，把磁盘里面的文件映射到用户态的虚拟内存，还有将 PageCache 映射到用户态的虚拟内存，从而减少内核态到用户态的 CPU 拷贝</p>
<p>PageCache技术：为了优化磁盘中数据文件的读写性能，PageCache 技术对数据文件进行了缓存。“对磁盘中数据文件的顺序读写性能接近于对内存的读写性能”，其主要原因就是 PageCache 对磁盘中数据文件的读写进行了优化。</p>
<ul>
<li><strong>PageCache 对数据文件的读优化：</strong>由于读数据文件的时候会先从 PageCache 加载数据，如果 PageCache 没有数据的话，会从磁盘的数据文件中加载数据并且顺序把相邻的数据文件页面预加载到 PageCache 中，这样子如果之后读取的数据文件在 PageCache 中能找到的话就省去了去磁盘加载数据的操作相当于直接读内存。</li>
<li><strong>PageCache 对数据文件的写优化：</strong>往数据文件中写数据的时候同样先写到 PageCache 中，然后操作系统会定期刷盘把 PageCache 中的数据持久化到磁盘中。</li>
</ul>
<p>RocketMQ是怎么使用的？</p>
<ol>
<li>将磁盘中的CommitLog数据文件映射到虚拟内存中。</li>
<li>生产端将消息顺序写到PageCache中，然后OS定期进行异步刷盘，将PageCache中的数据批量持久化到磁盘</li>
<li>消费端读取CommitLog数据，由于程序的局部性，所以加载的数据基本可以在PageCache找到，就不用去磁盘读取。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzsly7z59ij20k10damy2.jpg" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">序列化和反序列化小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-10 16:40:37 / Modified: 17:22:07" itemprop="dateCreated datePublished" datetime="2022-02-10T16:40:37+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">序列化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序列化和反序列化小结"><a href="#序列化和反序列化小结" class="headerlink" title="序列化和反序列化小结"></a>序列化和反序列化小结</h1><p>序列化是指把数据结构或对象转化为可存储或可传输的结构，这种结构可以用于重建数据结构或对象。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Json</td>
<td>文本</td>
<td>1. 人可读 2. 属性顺序对序列化反序列化无影响</td>
<td>1. 丢弃了类型信息，eg: “num”:100，这里对于num的类型信息是不可知的，解析存在二义性 2. 不支持二进制数据类型</td>
</tr>
<tr>
<td>Protobuf</td>
<td>二进制</td>
<td>性能高</td>
<td>1. 不宜读 2. 向后兼容有约定限制</td>
</tr>
</tbody></table>
<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>JSON建构于两种结构：</p>
<ul>
<li>“Key/Value”对的集合，在不同语言中，可以作为对象，字典，结构体等</li>
<li>值的有序列表。通常可以理解为数组。</li>
</ul>
<p>以上两种结构在大多数语言中都存在，所以在不同语言中使用JSON进行交流非常自然。</p>
<p>形式：</p>
<ol>
<li>对象是一个无序的’key/value’对集合。一个对象以”{“开始，”}”结束。键值对”key:value”表示。键值对之间使用”,”分隔</li>
<li>值的有序集合：一个数组以”[“开始,”]”结束，值之间使用”,”分隔</li>
<li>值value:可以为string-&gt;”abc”，number-&gt;1,Bool-&gt;true/false,null,对象或数组，同时结构可以嵌套</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>传输数据量较小，且实时性要求比较低的服务</li>
<li>JSON的前后兼容性比较强，对于接口经常变化，对可调性要求高的场景比较适合，比如移动端和服务端通讯</li>
<li>JSON的典型场景： JSON+HTTP</li>
</ol>
<p>JSON的性能和序列化的额外空间开销比较大，对于大数据量服务或持久化来说，会有巨大的开销。同时JSON本身没有使用IDL约束参与方，尽管在大多数语言中它的形式都可以兼容，但是还是会存在问题，需要通过文档方式进行约束，对调试会带来不便。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>protobuf有许多作为优秀的序列化协议的众多优点：</p>
<ol>
<li>使用了标志的IDL</li>
<li>序列化数据紧凑，空间开销小</li>
<li>序列化反序列化速度很快</li>
</ol>
<p>protobuf产生与Google，其支持多种语言，支持的数据类型相对较少，常见与一下rpc框架中使用。</p>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><p>protobuf的空间开销小，加上解析性能高，使用与RPC调用的场景。protobuf提供了标志的IDL，IDL对于各方都有比较强的约束。此外对于应用层对象持久化来说，也比较适合。</p>
<p>缺点在于调试比较麻烦</p>
<h2 id="使用ANTLR设计自己的序列化协议-TODO"><a href="#使用ANTLR设计自己的序列化协议-TODO" class="headerlink" title="使用ANTLR设计自己的序列化协议 TODO"></a>使用ANTLR设计自己的序列化协议 TODO</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MySQL - 查询优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 17:16:04 / Modified: 18:19:14" itemprop="dateCreated datePublished" datetime="2022-01-29T17:16:04+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><ol>
<li>确认程序是否在检索大量超过需要的数据</li>
<li>确认Mysql服务器是否在分析大量超过需要的数据行</li>
</ol>
<h3 id="请求了不需要的数据"><a href="#请求了不需要的数据" class="headerlink" title="请求了不需要的数据"></a>请求了不需要的数据</h3><ol>
<li>查询不需要的记录：Mysql总是先返回全部结果集再计算，最好的办法是在查询后面加上LIMIT</li>
<li>多表关联时返回全部列：只取需要的列</li>
<li>使用select *</li>
<li>重复查询相同的数据：使用缓存将数据缓存下来</li>
</ol>
<h3 id="是否在扫描额外的记录"><a href="#是否在扫描额外的记录" class="headerlink" title="是否在扫描额外的记录"></a>是否在扫描额外的记录</h3><p>衡量标准：1. 响应时间 2. 扫描的行数 3. 返回的行数 -&gt; 查询慢日志获得指标 4. 扫描的行数和访问类型 -&gt; 通过EXPLAIN语句中的type列可以获取访问类型。</p>
<p>优化思路：</p>
<ol>
<li>使用索引覆盖扫描</li>
<li>改变库表结构</li>
<li>重写复杂查询，让优化器能够以更优化的方式去执行查询</li>
</ol>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ol>
<li><p>将一个复杂查询分解为多个简单查询</p>
</li>
<li><p>切分查询：将一个重的事务分解为多个小的事务（eg：删除过期数据）</p>
</li>
<li><p>分解关联查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag JOIN tag_post WHERE tag_post.id=tag.id JOIN post ON tag_post.id=post.id </span><br><span class="line">WHERE tag.tag=&#x27;mysql&#x27;</span><br><span class="line"></span><br><span class="line">//将关联查询分解为多个单表查询，然后在业务程序再进行关联</span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456)</span><br></pre></td></tr></table></figure></li>
<li><p>Mysql客户端和服务端的通信协议: 半双工-&gt; 导致Mysql查询，需要所有的数据都接收到以后才能是否查询占用的资源。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">如何实现一个远程调用框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-27 14:45:00 / Modified: 17:09:32" itemprop="dateCreated datePublished" datetime="2022-01-27T14:45:00+08:00">2022-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何实现一个远程调用框架"><a href="#如何实现一个远程调用框架" class="headerlink" title="如何实现一个远程调用框架"></a>如何实现一个远程调用框架</h1><p>RPC框架会涉及到的内容，线程模型，通信协议设计，同步/异步调用，负载均衡等。</p>
<h2 id="RPC框架架构设计"><a href="#RPC框架架构设计" class="headerlink" title="RPC框架架构设计"></a>RPC框架架构设计</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys9sub3prj31940msabj.jpg" alt="Lark20210101-221749.png"></p>
<p>大概有三个部分的组件，1. 客户端 2. 注册中心 3. 服务端</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>使用注册中心来实现服务注册和发现的功能。</p>
<p>服务端节点上线以后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点数据移除。</p>
<p>客户端向服务端发起调用时，自己从注册中心获取到服务端的服务列表，然后通过负载均衡算法选择其中一个服务节点进行调用。</p>
<p><strong>问题</strong>：服务端节点下线时如何移除节点数据，尤其是异常下线的情况。</p>
<p>方式：主动通知+心跳检测</p>
<p>当服务端下线时会主动通知注册节点下线移除数据，同时注册中心会对服务节点进行探活。</p>
<h2 id="通信协议与序列化："><a href="#通信协议与序列化：" class="headerlink" title="通信协议与序列化："></a>通信协议与序列化：</h2><p>因为RPC框架对于性能要求较高，所以通信协议越简单越好。</p>
<p>主流的是TPC,HTTP，gRPC使用的HTTP2。需要稳定可靠的协议。</p>
<p>数据和序列化：如果是一般的框架会选用通用且高效的序列化方式，比如Json,Protocbuf等待，如果是特定场景下使用的话，可以使用特定的序列化方式，这样会更加高效。</p>
<h2 id="RPC的调用方式："><a href="#RPC的调用方式：" class="headerlink" title="RPC的调用方式："></a>RPC的调用方式：</h2><p>一般支持的调用方式：</p>
<ol>
<li>同步Sync：客户端发起RPC调用后，当前线程会一直阻塞，指定服务端返回结果或者超时。</li>
<li>异步Future：客户端发起调用以后不会阻塞等待，而是拿到RPC框架的Future对象，调用结果会被服务端缓存，客户端自行决定何时拿到返回结果，主动获取结果的过程是阻塞等待的。</li>
<li>回调Callback：客户端发起调用时，将Callback对象传递给RPC框架，无需同步等待，直接返回。当获取到服务端响应结果或者超时，再执行用户注册的Callback回调。这种Callback接口一般包含了onResponse和onException两个方法</li>
<li>单向Oneway：客户端发起请求后直接返回，忽略结果</li>
</ol>
<h2 id="线程模型："><a href="#线程模型：" class="headerlink" title="线程模型："></a>线程模型：</h2><p>使用主从Reactor线程模型，其中Boss和Worker线程池可以看做IO线程，IO线程用于处理网络数据，比如事件轮询，编解码，数据传输等。业务逻辑使用业务线程执行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gysaijfmhoj317q0onn2d.jpg" alt="Lark20210101-221822.png"></p>
<h2 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h2><p>常见的负载均衡的策略：</p>
<p><strong>Round-Robin 轮询</strong>。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</p>
<p><strong>Weighted Round-Robin 权重轮询</strong>。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</p>
<p><strong>Least Connections 最少连接数</strong>。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</p>
<p><strong>Consistent Hash 一致性 Hash</strong>。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</p>
<h2 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h2><p>RPC框架如果要做到像调用本地接口一样调用远端服务，需要创建代理对象，在代理对象中完成数据报文编码，然后发起调用数据给服务方，以此来屏蔽RPC框架的调用细节。可以通过动态代理的方式生成桩类（代理类），gRPC则是通过定义好的DSL，使用DSL来生成桩类和代理方法。</p>
<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc-facade # HelloFacade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-provider # HelloFacadeImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloFacade.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFacadeImpl</span> <span class="keyword">implements</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-consumer # HelloController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务方"><a href="#服务方" class="headerlink" title="服务方"></a>服务方</h3><ol>
<li>服务提供者启动服务，并暴露服务端口；</li>
<li>启动时扫描需要对外发布的服务，并将服务元数据信息发布到注册中心；</li>
<li>接收 RPC 请求，解码后得到请求消息；</li>
<li>提交请求至自定义线程池进行处理，并将处理结果写回客户端。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">基于线程和事件驱动的响应模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-24 20:33:09 / Modified: 21:02:52" itemprop="dateCreated datePublished" datetime="2022-01-24T20:33:09+08:00">2022-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Reactor-Pattern"><a href="#Reactor-Pattern" class="headerlink" title="Reactor Pattern"></a>Reactor Pattern</h1><p>Reactor pattern的理念:</p>
<ol>
<li>连接和线程总是存在一对一的关系。Unfortunately, there is always a one-to-one relationship between connections and threads</li>
<li>事件驱动的方法可以将线程与连接分开，它只对特定回调/处理程序的事件使用线程。Event-driven approach can separate threads from connections, which only uses threads for events on specific callbacks/handlers.</li>
<li>一个事件驱动的架构由事件的创建者和事件的消费者组成。创建者，也就是事件的源头，只知道事件发生了。消费者是需要知道事件已经发生的实体。消费者可能参与到事件处理中去，也可能只是受到事件的影响。An event-driven architecture consists of event creators and event consumers. The creator, which is the source of the event, only knows that the event has occurred. Consumers are entities that need to know the event has occurred. They may be involved in processing the event or they may simply be affected by the event.</li>
<li>反应器模式时事件驱动架构的一种实现，简单来说，它是由一个单线程的事件循环对发出事件的资源进行了阻塞并且将其分配给对应的处理程序或者回调。The reactor pattern is one implementation technique of the event-driven architecture. <strong>In simple words, it uses a single threaded event loop blocking on resources emitting events and dispatches them to corresponding handlers/callbacks.</strong></li>
<li>只有注册了处理程序和回调，就没必要阻塞IO了。事件就行传入的一个新的连接，已经可以读，可以写了<strong>There is no need to block on I/O, as long as handlers/callbacks for events are registered to take care of them.</strong> Events are like incoming a new connection, ready for read, ready for write, etc.</li>
<li>This pattern decouples modular application-level code from reusable reactor implementation.这种模式可以解耦模块化的应用级代码和可重复使用的反应器实现。</li>
<li>The purpose of the Reactor design pattern is to avoid the common problem of creating a thread for each message/request/connection.Avoid this problem is to avoid the famous and known problem C10K.反应器模式的目的是为了避免为每个消息/请求/连接创建一个线程的问题。也是为了解决C10K问题。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">MySQL高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-18 02:01:29" itemprop="dateCreated datePublished" datetime="2022-01-18T02:01:29+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-28 17:46:56" itemprop="dateModified" datetime="2022-01-28T17:46:56+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL高可用"><a href="#MySQL高可用" class="headerlink" title="MySQL高可用"></a>MySQL高可用</h1><h2 id="主备一致是如何保证的"><a href="#主备一致是如何保证的" class="headerlink" title="主备一致是如何保证的"></a>主备一致是如何保证的</h2><p>主库同步到从库的过程：</p>
<ol>
<li>主库接收到写请求以后，执行内部事务的更新逻辑，同时写binlog</li>
<li>从库和主库直接维持了一个长连接，主库A内部有一个线程，专门用于服务备库B的长连接。</li>
<li>事务日志同步：从库和主库建立好长连接后，会收到主库的binlog，存储到本地为relaylog，会有一个线程读取relaylog，解析日志里的sql命令，然后执行</li>
</ol>
<p>binlog的三种格式：</p>
<ol>
<li><p>statement</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf1oqf7jj31ga05xdhk.jpg" alt="img"></p>
<p>statement格式存储的是原始的SQL语句。</p>
<p>存在的问题：主库和从库执行同一条sql语句，可能存在结果不一致的情况。</p>
</li>
<li><p>row</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf2ifijgj31hc0et411.jpg" alt="img"></p>
<p>row格式里存储的是: Table_map, Delete_rows，row格式记录了真实删除行的主键id，也就是主库和备库最终结果是一致的</p>
</li>
<li><p>mixed</p>
<p>mixed是以上两种混合使用的结果</p>
<p>statement格式的binlog可能会造成主备不一致</p>
<p>row格式的话，会很占用空间 - 比如delete删除10万行，row格式要记录10w个记录，statement只记录一句sql</p>
<p>Mixed: 主动判断SQL语句是否可能造成主备不一致，可能就用row，否则stament</p>
</li>
<li><p>实践：设置为mixed，如果需要恢复数据的场景，则设置为row</p>
</li>
</ol>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytgdcxmwcj31hc0ig0y2.jpg" alt="img"></p>
<p>row格式中记录的信息中，bin_row_image的默认设置会存储行的所有字段的值，上面设置为只记录必要信息，只有id=4这个信息</p>
<p>所以在row格式中，可以记录所有的行的信息。</p>
<ol>
<li>delete：执行的delete语句，在row格式的binlog中，被删除的每一行的信息都会保存，既可以将删除的数据insert回去。</li>
<li>insert: insert语句，row格式的binlog会记录所有字段信息，可以用于定义刚刚插入的一行，使用delete删除即可</li>
<li>update: update语句，row格式的binlog会记录修改前的整行数据和修改后的整行数据，只需要对调前后，执行update即可</li>
</ol>
<h2 id="双主结构和循环复制"><a href="#双主结构和循环复制" class="headerlink" title="双主结构和循环复制"></a>双主结构和循环复制</h2><p>当两个库都作为主库时，会有2个长连接来保持相互同步，但是如何保证不会循环复制。这里使用serverid来做区分。</p>
<h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>数据同步的节点：</p>
<ol>
<li>主库A执行完成一个事务，写入binlog T1</li>
<li>binlog传给备库B，备库接收完这个binlog T2</li>
<li>备库B执行完成事务 T3</li>
</ol>
<p>主备延迟 = T3 - T1</p>
<p>T2 - T1 = 网络传输的时间，比较短</p>
<p>T3 - T2 = 接收完binlog并执行事务的时间（长）</p>
<p>主备延迟 约等于 T3-T2 接收完binlog，执行relaylog的速度差</p>
<p><strong>主备延迟的来源</strong>：</p>
<ol>
<li>主库机器被备库好</li>
<li>备库压力大</li>
<li>大事务 - 因为主库必须等事务执行完以后才会写入binlog，如果大事务执行时间为t1则延迟为t1</li>
<li>备库的并行复制</li>
</ol>
<h3 id="针对主备延迟带来的主备切换策略："><a href="#针对主备延迟带来的主备切换策略：" class="headerlink" title="针对主备延迟带来的主备切换策略："></a>针对主备延迟带来的主备切换策略：</h3><ol>
<li>可靠性优先策略：</li>
<li>可用性优先策略：</li>
</ol>
<h3 id="小时级的主备延迟-备库并行复制"><a href="#小时级的主备延迟-备库并行复制" class="headerlink" title="小时级的主备延迟 - 备库并行复制"></a>小时级的主备延迟 - 备库并行复制</h3><p>在备库执行日志的速度持续低于主库生成日志的速度情况下，主备延迟有可能变成小时级别。</p>
<p>为什么要多线程并行复制 - 客户端事务是可以并发的，如果备库处理relaylog是单线程的，则会导致备库执行日志速度持续低于主库生成日志，造成较长时间的主备延迟。</p>
<p>协调器 - 多工作线程的模式（同时需要保证 不能更新覆盖，不能拆同一个事务）</p>
<h3 id="一主多从的结构"><a href="#一主多从的结构" class="headerlink" title="一主多从的结构"></a>一主多从的结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytifl1yznj30vq0ns0u1.jpg" alt="img"></p>
<p>具体结构：A与A1是互为主从，B，C，D是执行A的从库，主库为WR，从库为readonly</p>
<ol>
<li><p>主库故障后的主从切换：</p>
<p>当A出错后，A1会作为新的主库，对于从库B来说需要执行change master命令，需要建立到新主库的连接并且将日志位点对齐新主库</p>
<p><strong>重点问题：日志位点很难对齐</strong></p>
<p>对于相同的日志，A和A1的位点是不同的，所以从库首先需要对齐位点</p>
<p>通用的做法是使用GTID来对齐位点：</p>
<p>GTID(Global Transaction Identifier) 是全局事务ID，是一个事务在提交时生成的</p>
<p>在开启了GTID以后，日志位点就可以自动对齐了</p>
<p><strong>流程：</strong></p>
<ol>
<li>从库B指定主库A1，基于主备协议建立连接</li>
<li>从库B把自己的GTID集合set_b发给新主库A1</li>
<li>主库A1把set_b和自己的GTID集合set_a比较，获取差集，然后看自己是否包含所有的差集</li>
<li>主库A1在binlog中找到第一个差集中的事务，然后向后顺序取binlog给B</li>
</ol>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Redis小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-13 17:59:13" itemprop="dateCreated datePublished" datetime="2022-01-13T17:59:13+08:00">2022-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-13 00:34:32" itemprop="dateModified" datetime="2022-02-13T00:34:32+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis学习小结"><a href="#Redis学习小结" class="headerlink" title="Redis学习小结"></a>Redis学习小结</h1><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7med1wej30uy0u0djk.jpg" alt="screenshot-20220113-181317" style="zoom:150%;" />

<h2 id="Redis的设计与实现"><a href="#Redis的设计与实现" class="headerlink" title="Redis的设计与实现"></a>Redis的设计与实现</h2><p>核心点：</p>
<ol>
<li><p>Redis的五种数据类型是由什么数据结构实现？</p>
<p>String-&gt; 动态字符串</p>
<p>List-&gt;  压缩链表，双向链表</p>
<p>Hash-&gt; 压缩链表，hash表</p>
<p>Set-&gt;set</p>
<p>sortedSet-&gt;压缩链表，跳表</p>
</li>
<li><p>Redis的字符串类型即可以存储字符串，又可以存储整数和浮点数，甚至二进制位，Redis内部如何存储这些不同的值？</p>
<p>针对不同场景，为同一类型设置不同的数据结构实现。</p>
<p>比如字符串，数字时存为INT，长度小的时候为编码的简单字符串，长的时候就是简单动态字符串</p>
</li>
<li><p>Redis 的一部分命令只能对特定数据类型执行（比如 APPEND 只能对字符串执行， HSET 只能对哈希表执行）， 而另一部分命令却可以对所有数据类型执行（比如 DEL 、 TYPE 和 EXPIRE ）， 不同的命令在执行时是如何进行类型检查的？ Redis 在内部是否实现了一个类型系统？</p>
<p>是的Redis内部实现了一套类型系统</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb70oiqptj30se0ks0ue.jpg" alt="img"></p>
</li>
<li><p>Redis 的数据库是怎样储存各种不同数据类型的键值对的？ 数据库里面的过期键又是怎样实现自动删除的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb6ys3r6mj30sf0fvmyj.jpg" alt="img"></p>
</li>
<li><p>Redis 还拥有发布与订阅、脚本、事务等特性， 这些特性又是如何实现的？</p>
</li>
<li><p>怎么处理客户端的命令请求？</p>
<p>使用RESP协议（自定义的）进行通信</p>
</li>
</ol>
<p>整体结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc81jn065j31hb0u0wj0.jpg" alt="img"></p>
<h2 id="K-V如何组织"><a href="#K-V如何组织" class="headerlink" title="K-V如何组织"></a>K-V如何组织</h2><p>使用的是Hash表的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8wiczbwj30lf08zgm8.jpg" alt="img"></p>
<p>问题：</p>
<ol>
<li><p>Hash冲突？ -&gt;链式解决</p>
</li>
<li><p>Rehash(分配更大的空间，减少冲突): </p>
<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 为了避免copy 过程阻塞用户请求，Redis 采用了渐进式 rehash，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，<strong>顺带着</strong>将这个索引位置上的所有 entries 拷贝到哈希表 2 中。PS：跟redis 通过用户请求顺带清理 过期数据是一样的。</li>
<li>释放哈希表 1 的空间。</li>
</ol>
</li>
<li><p>RedisObject: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount;   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;  <span class="comment">// 指向实际值的指针，可以指向不同的数据类型</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>由于Redis的数据类型很多，所以是用了一个RedisObject来做封装</p>
</li>
</ol>
<h2 id="K-V底层数据结构"><a href="#K-V底层数据结构" class="headerlink" title="K-V底层数据结构"></a>K-V底层数据结构</h2><p>Key只能为string类型，value可以为复杂类型</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8tm64v5j32t00u0jyx.jpg" alt="img"></p>
<p>压缩列表：</p>
<p>由于压缩列表节约内存，所以hash,list,sortedSet的底层实现在数据量小的时候都采用压缩列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                         ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>图中各个域的作用如下：</p>
<table>
<thead>
<tr>
<th align="left">域</th>
<th align="left">长度/类型</th>
<th align="left">域的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">到达 ziplist 表尾节点的偏移量。 通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left">ziplist 中节点的数量。 当这个值小于 <code>UINT16_MAX</code> （<code>65535</code>）时，这个值就是 ziplist 中节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left"><code>?</code></td>
<td align="left">ziplist 所保存的节点，各个节点的长度根据内容而定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>255</code> 的二进制值 <code>1111 1111</code> （<code>UINT8_MAX</code>） ，用于标记 ziplist 的末端。</td>
</tr>
</tbody></table>
<p>Entry的构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">            +------------------+----------+--------+---------+</span><br><span class="line">component   | pre_entry_length | encoding | length | content |</span><br><span class="line">            +------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis客户端与服务端使用了RESP(Redis Serialization Protocol)的二进制安全文本协议进行通信，通过TCP连接实现数据交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure>

<p>对于特定场景，使用自定义的通信协议，性能会好于通用的通信协议</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7x6r5umj30sf0fvmyj.jpg" alt="img"></p>
<h2 id="单线程的原因"><a href="#单线程的原因" class="headerlink" title="单线程的原因"></a>单线程的原因</h2><ol>
<li>只是对读写使用了单线程，底层使用了IO多路复用机制</li>
<li>单线程使用简单，并且这里主要的瓶颈不是单线程而是共享资源</li>
</ol>
<h2 id="持久化（单机高可用）"><a href="#持久化（单机高可用）" class="headerlink" title="持久化（单机高可用）"></a>持久化（单机高可用）</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7lzkw1yj31fn0u0wju.jpg" alt="screenshot-20220113-181342" style="zoom:150%;" />

<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h3><p>MySQL使用的是写前日志（WAL）。但是AOF日志是写后日志，需要Redis先执行命令，写入内存后，再记录日志。</p>
<p>优点：记录每一条命令但是不需要检查语法。AOF也不会阻塞当前命令</p>
<p>缺点：存在执行完命令没有记录日志丢失数据的风险。AOF会阻塞下一个命令执行，如果后续磁盘写压力大会导致变慢。</p>
<p>解决问题：</p>
<ol>
<li><p>丢失数据风险：提供三种配置, Always(同步写回)，EverySec(每秒写回),NO(只写到内存，有操作系统写入磁盘)</p>
</li>
<li><p>日志文件变大：使用AOF重写机制</p>
<p>AOF重写机制：</p>
<ol>
<li>执行重写是，主线程fork一个子线程，内存会拷贝一份，如何对同一键值对的反复修改的命令只保留其值即可。主线程未阻塞，仍然可以处理新来的操作。如果有写操作，除了正在写的AOF 日志，还会再写一份AOF 重写日志。等到bgrewriteaof 拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，此时，就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycbr21z07j31s40u0436.jpg" alt="img"></p>
<h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>记录某一时刻的内存中的数据，以文件的形式写到磁盘。即快照。</p>
<p>提供了两个命令生成RDB：</p>
<ol>
<li>Save: 主线程执行，会阻塞</li>
<li>Bgsave: 创建一个子进程，专门写入RDB文件，避免了主线程的阻塞，但是这样做确需要暂停写操作，可以使用Copy-On-Write，即会复制一份值用于写。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyccaxy4m4j31hc0u0ad2.jpg" alt="img"></p>
<p>快照频率使用上，频率搞了消耗大，低了数据容易丢</p>
<p>更好的应用场景：快照不频繁使用，AOF记录两次快照之间的操作。</p>
<p>因为RDB和AOF都会使用fork，<strong>fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长</strong>（所以使用RDB时，单个实例的redis 内存不宜过大）</p>
<p>同时，Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 swap 的影响，而导致性能变慢。</p>
<h2 id="主从同步（多机高可用）"><a href="#主从同步（多机高可用）" class="headerlink" title="主从同步（多机高可用）"></a>主从同步（多机高可用）</h2><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjk9u4c0j31nk0q4gru.jpg" alt="screenshot-20220114-010708"></p>
<p>Redis提供了主从库模式，主从库同步是如何完成的呢？</p>
<ol>
<li><p>第一次同步：启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，然后使用RDB进行数据同步</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjmznewtj31ve0u0q8l.jpg" alt="img"></p>
</li>
<li><p>主从级联模式：从库很多，如果都要和主库进行全量复制，就会导致主库压力大，通过“主-从-从”的模式就可以解决</p>
</li>
<li><p>主从库端口：通过增量复制的方式继续同步。主从库断连后，主库会将写操作持续写入一个buffer（注：环状）</p>
</li>
</ol>
<p>主库挂了怎么办？</p>
<p>通过哨兵机制解决：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjsvqhk5j31qs0me78h.jpg" alt="screenshot-20220114-011539"></p>
<p>哨兵是一个特殊模式下的Redis进程，主要用于：监控，选主，通知</p>
<ol>
<li>监控。周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>选主。筛选+打分，在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉（在线状态、断连次数）。然后，我们再按照一定的规则，给剩下的从库逐个打分（从库优先级、从库复制进度= master_repl_offset-slave_repl_offset 以及从库 ID 号），将得分最高的从库选为新主库。</li>
<li>通知。哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</li>
</ol>
<p>单哨兵也可能会出问题，所以可以使用哨兵集群：</p>
<h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjydb0w0j31ho0u00yi.jpg" alt="screenshot-20220114-012052"></p>
<p>当数据量变大以后，就需要扩展，如果只是单纯的扩大单个Redis的内存，会导致fork时间变长，Redis性能变差。此时需要纵向扩展。通过切片集群解决，这里即对一个K-V,先通过K找到需要保存到那个redis示例，在通过K找到在redis的hash表的存放位置。对于第一步来说，还需要考虑负载均衡的问题。</p>
<p>实际：Redis Cluster是通过Hash Slot实现的，一个环状的hash槽（16384个），通过hash算法（hash(key)%N）找到slot位置。在部署时，Redis会自动将这些槽平均到集群实例上。</p>
<p>如何知道哈希槽分布在哪个实例上？Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>当出现增删节点和负载均衡情况等变化的情况，通过重定向机制处理，即原本的实例存放了变更的位置，会通过重定向将请求发给变更的位置</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区是Redis中用于，当客户端和服务端进行通信时，暂存客户端命令或服务端结果的。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckdibgooj31880u0adf.jpg" alt="img"></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ol>
<li>对于缓存来说，淘汰策略很重要，通过时间局部性和空间局部性来保证缓存的作用</li>
<li>单范围淘汰，即对设置了过期时间的数据进行淘汰</li>
<li>全范围淘汰，按照淘汰算法对所有数据进行</li>
</ol>
<p>LRU（Redis）实现：在RedisObject中有个lru字段，保存一个数据访问的时间戳，因为数据量很大，Redis也只是抽取一定数量的数据，然后对齐按照lru的大小进行淘汰</p>
<p>LFU（Redis）实现:  也是使用RedisObject中lru字段，总共24bit，拆为16bit（时间戳）,counter(8bit)访问值（最大255）。Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。这样可以保证访问次数很大也可以进行比较，但是这样本身存在一定误差，数据量大的时候其counter值才置信。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckrc17jwj318m0hawhk.jpg" alt="screenshot-20220114-014847"></p>
<p>Redis的事务，一致性和隔离性可以保证，持久性和原子性不行。</p>
<h2 id="缓存异常问题"><a href="#缓存异常问题" class="headerlink" title="缓存异常问题"></a>缓存异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>问题：应用请求无法在Redis处理，大量的被传导到数据库了</p>
<ol>
<li>大量数据同时到期 -&gt; a. 微调时间，给业务数据加上一个小的随机数 b. 服务降级，只保证核心内容服务</li>
<li>Redis实例宕机导致 -&gt; a.进行服务熔断和请求限流 b. 建立高可靠的集群</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>问题：对于某个热点数据的访问很频繁，但是此时该数据刚好过期，导致大量请求到了数据库。</p>
<p>解决办法：对于热点数据，不设置过期时间</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>问题：要访问的数据即不在Redis缓存也不在数据库，通常由于业务层误操作或者恶意攻击导致</p>
<p>解决办法：</p>
<ol>
<li>缓存空值</li>
<li>使用Bloom Filer（一个初值全为0的数组和N个hash函数组成，对于某个值，如果存在，则使用N个hash将它的位置置为1）快速判断数据是否存在。（存在一定通过Bloom Filter，不存在大部分通不过Bloom Filter）</li>
<li>对请求进行合法校验，避免恶意请求</li>
</ol>
<h3 id="缓存与数据库数据不一致问题"><a href="#缓存与数据库数据不一致问题" class="headerlink" title="缓存与数据库数据不一致问题"></a>缓存与数据库数据不一致问题</h3><p>核心：需要保证缓存中有数据，缓存的数据必须和数据库中相同。没有数据，则数据库中必须为最新值。</p>
<p>解决办法：</p>
<p>读写缓存：同步写回</p>
<p>只读缓存：</p>
<ol>
<li>先删缓存再更新数据库：无并发，重试机制（使用消息队列保证操作成功） 并发：延迟双删（先删除缓存，再更新数据库，休眠一秒，再次删除缓存）</li>
<li>先更新数据库再删缓存（更好）：无并发，重试机制   并发：在客户端暂存并发请求</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/zhongsongzhi97.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
