<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/2/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/20/gRPC%E5%BD%92%E7%BA%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/20/gRPC%E5%BD%92%E7%BA%B3/" class="post-title-link" itemprop="url">gRPC归纳</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-20 14:59:32 / Modified: 15:02:03" itemprop="dateCreated datePublished" datetime="2021-12-20T14:59:32+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RPC和gRPC"><a href="#RPC和gRPC" class="headerlink" title="RPC和gRPC"></a>RPC和gRPC</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/" class="post-title-link" itemprop="url">并发编程 - Context</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-19 14:36:52 / Modified: 15:14:22" itemprop="dateCreated datePublished" datetime="2021-12-19T14:36:52+08:00">2021-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发编程-上下文Context"><a href="#并发编程-上下文Context" class="headerlink" title="并发编程 - 上下文Context"></a>并发编程 - 上下文Context</h1><h2 id="Context的作用和使用"><a href="#Context的作用和使用" class="headerlink" title="Context的作用和使用"></a>Context的作用和使用</h2><p>上下文 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。</p>
<p>该接口有4个需要实现的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>) <span class="comment">//返回context.Context被取消的时间</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//返回一个channel，会在工作完成或context被取消后关闭，重复调用返回同一个Channel</span></span><br><span class="line">	Err() error <span class="comment">//被取消 - Canceled错误 超时 - DeadlineExceeded</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; <span class="comment">//获取键对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的最大作用。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj50vvo7hj30xc0aa0tb.jpg" alt="golang-context-usage"></p>
<p>Go 服务的每一个请求都是通过单独的 Goroutine 处理的，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务，如上图所示，对于同一个请求可能会创建多个Goroutine，需要使用Context.context在Goroutine直接同步特定数据，取消信号以及处理请求的截止日期。</p>
<p>当上层的Goroutine因为某些原因执行失败时，使用context.Context就可以在下层及时停掉无用的工作以减少额外资源的消耗</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;handle&quot;</span>,ctx.Err())</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">		fmt.Println(<span class="string">&quot;process request with&quot;</span>,duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(),<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> handle(ctx,<span class="number">500</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>,ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle处理时间为500ms</span></span><br><span class="line">process request with <span class="number">500</span>ms</span><br><span class="line">main context deadline exceeded</span><br><span class="line"><span class="comment">//handle处理时间为1500ms</span></span><br><span class="line">handle context deadline exceeded</span><br><span class="line">main context deadline exceeded</span><br></pre></td></tr></table></figure>

<p>多个Goroutine同时订阅ctx.Done()管道中的消息，一旦收到取消信号就立刻停止当前执行的工作</p>
<h2 id="默认上下文"><a href="#默认上下文" class="headerlink" title="默认上下文"></a>默认上下文</h2><p>context里最常用的方法是context.Background, context.TODO，这两个方法都会返回预先初始化好的私有变量backgroud和todo，这两个变量都是通过new(emptyCtx)初始化，即全为空实现的context.Context</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a> 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.TODO"><code>context.TODO</code></a> 应该仅在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a> 作为起始的上下文向下传递。</p>
<h2 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithCancel"><code>context.WithCancel</code></a> 函数能够从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<p>除了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithCancel"><code>context.WithCancel</code></a> 之外，<a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的另外两个函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithDeadline"><code>context.WithDeadline</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithTimeout"><code>context.WithTimeout</code></a> 也都能创建可以被取消的计时器上下文 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.timerCtx"><code>context.timerCtx</code></a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj5x724t9j30xc0aawf3.jpg" alt="golang-parent-cancel-context"></p>
<h2 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h2><p>如何使用上下文传值:<a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithValue"><code>context.WithValue</code></a> 能从父上下文中创建一个子上下文，传值的子上下文使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx"><code>context.valueCtx</code></a> 类型</p>
<p>如果 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx"><code>context.valueCtx</code></a> 中存储的键值对与 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx.Value"><code>context.valueCtx.Value</code></a> 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 <code>nil</code> 或者查找到对应的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 语言中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的主要作用还是在多个 Goroutine 组成的树中同步<strong>取消信号</strong>以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 传递请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/13/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/13/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/" class="post-title-link" itemprop="url">Go并发编程 - 调度器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-13 00:32:29" itemprop="dateCreated datePublished" datetime="2021-12-13T00:32:29+08:00">2021-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-19 15:55:13" itemprop="dateModified" datetime="2021-12-19T15:55:13+08:00">2021-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><h2 id="调度器的由来"><a href="#调度器的由来" class="headerlink" title="调度器的由来"></a>调度器的由来</h2><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存。</p>
<p>后来发现，线程可以分为 “内核态 “线程和” 用户态 “线程。一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”。</p>
<h3 id="协程与线程的映射关系"><a href="#协程与线程的映射关系" class="headerlink" title="协程与线程的映射关系"></a>协程与线程的映射关系</h3><p>N:1 -&gt; 一个进程的所有协程都绑定到一个线程了</p>
<p>1:1 -&gt; 协程的管理由CPU完成，成本过高</p>
<p>M:N: 比较合适</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbl2jjhosj31020u0gop.jpg" alt="img"></p>
<h2 id="调度器发展"><a href="#调度器发展" class="headerlink" title="调度器发展"></a>调度器发展</h2><h3 id="单线程调度器"><a href="#单线程调度器" class="headerlink" title="单线程调度器"></a>单线程调度器</h3><p>只包含G，M</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	G* gp;</span><br><span class="line">	lock(&amp;sched);<span class="comment">//获取调度器的全局锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(gosave(&amp;m-&gt;sched))&#123; <span class="comment">//gosave保存栈寄存器和程序计数器</span></span><br><span class="line">		lock(&amp;sched);</span><br><span class="line">		gp = m-&gt;curg;</span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;</span><br><span class="line">		<span class="keyword">case</span> Grunnable:</span><br><span class="line">		<span class="keyword">case</span> Grunning:</span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">		notewakeup(&amp;gp-&gt;stopped);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp = nextgandunlock(); <span class="comment">//获取下一个需要运行的Goroutine并解锁调度器</span></span><br><span class="line">	noteclear(&amp;gp-&gt;stopped);</span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp; <span class="comment">//修改全局线程上要执行的Goroutine为gp</span></span><br><span class="line">	g = gp;</span><br><span class="line">	gogo(&amp;gp-&gt;sched);<span class="comment">//调用gogo运行最新的Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程调度器"><a href="#多线程调度器" class="headerlink" title="多线程调度器"></a>多线程调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(G *gp)</span> </span>&#123;</span><br><span class="line">	schedlock();</span><br><span class="line">	<span class="keyword">if</span>(gp != nil) &#123;</span><br><span class="line">		gp-&gt;m = nil;</span><br><span class="line">		uint32 v = runtime·xadd(&amp;runtime·sched.atomic, <span class="number">-1</span>&lt;&lt;mcpuShift);</span><br><span class="line">		<span class="keyword">if</span>(atomic_mcpu(v) &gt; maxgomaxprocs)</span><br><span class="line">			runtime·<span class="keyword">throw</span>(<span class="string">&quot;negative mcpu in scheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;</span><br><span class="line">		<span class="keyword">case</span> Grunning:</span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ...:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	gp = nextgandunlock();</span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp;</span><br><span class="line">	gp-&gt;m = m;</span><br><span class="line">	runtime·gogo(&amp;gp-&gt;sched, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务窃取调度器"><a href="#任务窃取调度器" class="headerlink" title="任务窃取调度器"></a>任务窃取调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    G *gp;</span><br><span class="line"> top:</span><br><span class="line">    <span class="keyword">if</span>(runtime·gcwaiting) &#123;<span class="comment">//如果当前运行时在等待垃圾回收，则调用gcstopm</span></span><br><span class="line">        gcstopm();</span><br><span class="line">        <span class="keyword">goto</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//调用runqget和findrunnable从本地或全局的运行队列获取待执行的Goroutine</span></span><br><span class="line">    gp = runqget(m-&gt;p);<span class="comment">//本地</span></span><br><span class="line">    <span class="keyword">if</span>(gp == nil)</span><br><span class="line">        gp = findrunnable();<span class="comment">//全局获取，会触发工作窃取，从其他处理器的队列中随机获取Goroutine</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    execute(gp);<span class="comment">//调用execute在当前线程M上运行Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在G-M模型基础上引入了P</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> P &#123;</span><br><span class="line">	Lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32</span>	status;</span><br><span class="line">	P*	link;</span><br><span class="line">	<span class="keyword">uint32</span>	tick;</span><br><span class="line">	M*	m;</span><br><span class="line">	MCache*	mcache;</span><br><span class="line"></span><br><span class="line">	G**	runq;</span><br><span class="line">	<span class="keyword">int32</span>	runqhead;</span><br><span class="line">	<span class="keyword">int32</span>	runqtail;</span><br><span class="line">	<span class="keyword">int32</span>	runqsize;</span><br><span class="line"></span><br><span class="line">	G*	gfree;</span><br><span class="line">	<span class="keyword">int32</span>	gfreecnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj6qv3mq0j30xc0bemxg.jpg" alt="golang-gmp"></p>
<p>处理器持有一个由可运行的 Goroutine 组成的运行队列 <code>runq</code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。</p>
<h3 id="抢占式调度器"><a href="#抢占式调度器" class="headerlink" title="抢占式调度器"></a>抢占式调度器</h3><p>对于非抢占式的调度器饥饿问题很严重</p>
<h4 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h4><p>存在无法被抢占的边缘情况</p>
<p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。</p>
<p><strong>原理：</strong></p>
<ol>
<li>编译器会在调用函数前插入 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a>；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li>
<li>当发生函数调用时，可能会执行编译器插入的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a> 函数，它调用的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.newstack</code></a> 会检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li>
<li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li>
</ol>
<h4 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h4><ol>
<li>程序启动时，在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L494"><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</li>
<li>在触发垃圾回收的栈扫描时会调用<code>runtime.suspendG</code>挂起 Goroutine，该函数会执行下面的逻辑：<ol>
<li>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 触发抢占；</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/8e0be05ec7c369387c0ed3c9cf37968c6d3afbbd/src/runtime/os_linux.go#L483"><code>runtime.signalM</code></a> 向线程发送信号 <code>SIGURG</code>；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a> 会修改寄存器并在程序回到用户态时执行 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a>；</li>
<li>汇编指令 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a> 会调用运行时函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a> 会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a> 会修改当前 Goroutine 的状态到 <code>_Gpreempted</code> 并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2482"><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能</p>
<h2 id="Go协程goroutine"><a href="#Go协程goroutine" class="headerlink" title="Go协程goroutine"></a>Go协程goroutine</h2><p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。</p>
<p>Goroutine 特点：</p>
<ul>
<li>占用内存更小（几 kb）</li>
<li>调度更灵活 (runtime 调度)</li>
</ul>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>符号含义： G -&gt; goroutine P -&gt; processor M-&gt;thread</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbl71yyqej30sg0lcdhh.jpg" alt="img"></p>
<ul>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<h4 id="P和M的个数问题"><a href="#P和M的个数问题" class="headerlink" title="P和M的个数问题"></a>P和M的个数问题</h4><p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p>
<p>P:</p>
<p>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行</p>
<p>M:</p>
<ul>
<li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li>
<li>一个 M 阻塞了，会创建新的 M。</li>
</ul>
<h4 id="P和M何时被创建"><a href="#P和M何时被创建" class="headerlink" title="P和M何时被创建"></a>P和M何时被创建</h4><p>1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><ol>
<li><p>复用线程：</p>
<p>work stealing 机制:当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p>
<p>hand off 机制:当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p>
</li>
<li><p>利用并行：</p>
<p>GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。</p>
</li>
<li><p>抢占：</p>
<p>在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。</p>
</li>
<li><p>全局G队列：</p>
<p>在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。</p>
</li>
</ol>
<h3 id="调度器的调度流程"><a href="#调度器的调度流程" class="headerlink" title="调度器的调度流程"></a>调度器的调度流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxblfko443j30yg0jewgb.jpg" alt="img"></p>
<p> 1、我们通过 go func () 来创建一个 goroutine；</p>
<p> 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p>
<p> 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p>
<p> 4、一个 M 调度 G 执行的过程是一个循环机制；</p>
<p> 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p>
<p> 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxblhrrhddj30c70o8gmg.jpg" alt="img"></p>
<p>M0</p>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也会经历如上图所示的过程：</p>
<p>1.runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</p>
<p>2.调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。</p>
<p>3.示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。</p>
<p>4.启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</p>
<p>5.G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</p>
<p>6.M 运行 G</p>
<p>7.G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</p>
<h3 id="GMP数据查看的工具"><a href="#GMP数据查看的工具" class="headerlink" title="GMP数据查看的工具"></a>GMP数据查看的工具</h3><ol>
<li>go tool trace</li>
<li>Debug trace</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/10/how-to-read-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/10/how-to-read-source-code/" class="post-title-link" itemprop="url">how to read source code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-10 14:31:00 / Modified: 15:20:08" itemprop="dateCreated datePublished" datetime="2021-12-10T14:31:00+08:00">2021-12-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="怎样阅读源码"><a href="#怎样阅读源码" class="headerlink" title="怎样阅读源码"></a>怎样阅读源码</h1><h2 id="怎样阅读源码-1"><a href="#怎样阅读源码-1" class="headerlink" title="怎样阅读源码"></a>怎样阅读源码</h2><p>focus on code which either does something that I want to replicate the style of in the future, or which deepens my knowledge of code I use daily</p>
<p>find a high-level abstraction as a starting point and then gradually dig deeper into the internals</p>
<p> make notes in OneNote as I study the code, describing the flow and how the code works</p>
<p>This process is less about having a reference, although that can be useful, than it is about embedding the knowledge into my memory. By describing it in writing, I find that it sticks with me much longer</p>
<p>Navigating code and forming a mental picture of the logical flow is a handy skill. If you can learn this through reading code, it’ll pay dividends when you’re next trying to fix a critical bug under pressure.</p>
<p>Once I have an overview formed the next step is to go deeper. For this, I tend to clone the repository so that I can bring it into an IDE or VS Code.</p>
<p> I like to think about how I’d have chosen to approach a problem and contrast it with the actual implementation。Is the author’s approach better or more efficient? Should I file it away for when I next face a similar requirement?</p>
<p>Often the code may use APIs that I’ve never discovered when writing code.I study the description and method signature(s) to understand their designed use. This extends my code vocabulary.</p>
<p>I find tricks and shortcuts to save time when navigating the code</p>
<h2 id="不了解源码怎么办"><a href="#不了解源码怎么办" class="headerlink" title="不了解源码怎么办"></a>不了解源码怎么办</h2><p>You want to expose yourself to new APIs or new syntax in the code which you read so that you further your own code vocabulary.</p>
<p>Try to break things down into smaller chunks to work through in your head. What is the code doing and also why has it been written that way? Has the author used an approach to solving something you had not previously considered? As you come up against language syntax or keywords you don’t understand, stop and search for the documentation. Armed with an actual use case, often the documentation will make sense in the context you are approaching it from.</p>
<p>Similarly, when you encounter framework APIs which you have never used before, visit the code documentation if there is any.</p>
<h2 id="能从源码中学到什么"><a href="#能从源码中学到什么" class="headerlink" title="能从源码中学到什么"></a>能从源码中学到什么</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/" class="post-title-link" itemprop="url">同步原语与锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-09 01:03:41" itemprop="dateCreated datePublished" datetime="2021-12-09T01:03:41+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-20 02:12:01" itemprop="dateModified" datetime="2021-12-20T02:12:01+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="同步原语与锁"><a href="#同步原语与锁" class="headerlink" title="同步原语与锁"></a>同步原语与锁</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj839w6zaj30ur0r1n0j.jpg" alt="同步原语与锁"></p>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">//互斥锁的状态</span></span><br><span class="line">	sema  <span class="keyword">uint32</span> <span class="comment">//控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjbw1caljj30xc05a0sy.jpg" alt="golang-mutex-state"></p>
<p>在默认情况下，互斥锁的所有状态位都是 0，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<p><strong>正常模式和饥饿模式</strong></p>
<ul>
<li><p>正常模式：正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』</p>
</li>
<li><p>饥饿模式：饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式</p>
</li>
<li><p>对比：正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时</p>
</li>
</ul>
<p><strong>加锁与解锁</strong>:</p>
<p><strong>前提条件:CAS操作的实现：</strong></p>
<p>通过CPU提供的原子性指令实现了CAS</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, old, <span class="built_in">new</span> <span class="keyword">uint32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line">TEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, $<span class="number">0</span><span class="number">-25</span></span><br><span class="line"> MOVQ ptr+<span class="number">0</span>(FP), BX</span><br><span class="line"> MOVQ old+<span class="number">8</span>(FP), AX</span><br><span class="line"> MOVQ <span class="built_in">new</span>+<span class="number">16</span>(FP), CX</span><br><span class="line"> LOCK  <span class="comment">//锁住总线保证多次内存操作的原子性</span></span><br><span class="line"> CMPXCHGQ CX, <span class="number">0</span>(BX) <span class="comment">//cmpxchg %cx, %bx；如果AX与BX相等，则CX送BX且ZF置1；否则BX送CX，且ZF清0</span></span><br><span class="line"> SETEQ ret+<span class="number">24</span>(FP)</span><br><span class="line"> RET</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>拿AX(old) 与 BX(共享数据ptr) 做对比。</li>
<li>相等，则修改BX(共享数据ptr)，状态码ZX设置为 1 。</li>
<li>不相等，则将CX(new)置为目前BX(共享数据ptr)的值， 状态码ZX设置为 0</li>
</ol>
</li>
</ol>
<h4 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;<span class="comment">//当锁的状态是 0 时，将 mutexLocked 位置成 1</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.lockSlow()<span class="comment">//尝试通过自旋（Spinnig）等方式等待锁的释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 判断当前 Goroutine 能否进入自旋；</span></span><br><span class="line"><span class="comment">//2. 通过自旋等待互斥锁的释放；</span></span><br><span class="line"><span class="comment">//3. 计算互斥锁的最新状态；</span></span><br><span class="line"><span class="comment">//4. 更新互斥锁的状态并获取锁；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//进入自旋会调用doSpin并执行30次PAUSE指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	MOVL	cycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$<span class="number">1</span>, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p><strong>自旋会使得当前进程一直保存CPU的占用，持续检查某个条件是否为真</strong>。在多核CPU上，自旋可以避免线程的上下文切换，在自旋时间较短的情况下会有较大收益。</p>
<p>Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li><code>runtime.sync_runtime_canSpin</code>需要返回ture<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
</li>
</ol>
<p><strong>处理了自旋相关的逻辑后，互斥锁会根据上下文计算当前互斥锁状态</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//几个不同的条件分别会更新 state 字段中存储的不同信息 — mutexLocked、mutexStarving、mutexWoken 和 mutexWaiterShift</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">	<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算了互斥锁的状态后，会使用CAS更新状态</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁</span></span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">  <span class="comment">//如果没有通过 CAS 获得锁，会调用 runtime.sync_runtime_SemacquireMutex 通过信号量保证资源不会被两个 Goroutine 获取。</span></span><br><span class="line">  <span class="comment">//runtime.sync_runtime_SemacquireMutex 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，sync.Mutex.Lock 的剩余代码也会继续执行</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先查看是否通过CAS获得了锁，没有则会通过信号量保证资源不会被多个Goroutine获取</li>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ol>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//首先尝试使用AddInt32快速解锁</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</p>
</li>
<li><p>如果该函数返回的新状态不等于 0，这段代码会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.unlockSlow"><code>sync.Mutex.unlockSlow</code></a> 开始慢速解锁：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;<span class="comment">//校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序</span></span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">        <span class="comment">//存在等待者，则会通过runtime_Semrelease唤醒等待者</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">    <span class="comment">//直接调用runtime_Semrelease将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h2 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h2><p>结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex <span class="comment">//Mutex锁</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">//写等待读</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">//读等待写</span></span><br><span class="line">	readerCount <span class="keyword">int32</span> <span class="comment">//正在执行的读操作</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span> <span class="comment">//写操作被阻塞时等待的读操作的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<ul>
<li><p>写操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code>sync.RWMutex.Lock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 方法；</p>
</li>
<li><p>读操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code>sync.RWMutex.RLock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 方法；</p>
</li>
</ul>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁:"></a>写锁:</h4><p>获取写锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.w.Lock() <span class="comment">//获取Mutex锁</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders <span class="comment">//阻塞后续的读操作，readerConnt设置为负数</span></span><br><span class="line">  <span class="comment">//仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 runtime.sync_runtime_SemacquireMutex 进入休眠状态等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放写锁:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders) <span class="comment">//将readerCount变成正数释放读锁</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;<span class="comment">//for 循环释放所有因为获取读锁而陷入等待的 Goroutine</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	rw.w.Unlock()<span class="comment">//释放Mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』</p>
<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁:"></a>读锁:</h4><p>读锁加锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 runtime.sync_runtime_SemacquireMutex 陷入休眠等待锁的释放；</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//非负数则成功返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读锁释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//减少readerCount数</span></span><br><span class="line">  <span class="comment">//返回值&gt;=0读锁解锁成功</span></span><br><span class="line">  <span class="comment">//返回值&lt;0有正在执行的写操作，执行rw.rUnlockSlow(r)</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//减少获取锁的写操作等待的读操作数 readerWait 并在所有读操作都被释放之后触发写操作的信号量 writerSem，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>读锁和写锁的关系：</p>
<ul>
<li>调用<code>sync.RWMutex.Lock</code>尝试获取写锁时；<ul>
<li>每次 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerCount</code> 其减一，当它归零时该 Goroutine 会获得写锁；</li>
<li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li>
</ul>
</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<p><strong>结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">//在编译期间检查，保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span> <span class="comment">//存储着状态和信号量 私有方法 sync.WaitGroup.state 能够帮我们从 state1 字段中取出它的状态和信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjnnwqwptj30xc08cq3d.jpg" alt="golang-waitgroup-state"></p>
<p><strong>接口：</strong></p>
<ol>
<li>Add +1</li>
<li>Wait 等待group事件完成</li>
<li>Done -1</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	w := <span class="keyword">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">//唤醒等待状态的Goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 runtime.sync_runtime_Semacquire 陷入睡眠</span></span><br><span class="line"><span class="comment">//当 sync.WaitGroup 的计数器归零时，陷入睡眠状态的 Goroutine 会被唤醒，上述方法也会立刻返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 必须在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 只是对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p> <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。通常可以用于实现单例：</p>
<p>在运行如下所示的代码时，我们会看到如下所示的运行结果:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure>

<p><strong>结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">uint32</span> <span class="comment">//标识代码块是否执行过,保证函数不会被执行第二次</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//传入的参数已经执行过了，会直接返回，没有则会调用doSlow执行传入的函数</span></span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock() <span class="comment">//获取互斥锁</span></span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>) <span class="comment">//将成员变量更新为1</span></span><br><span class="line">		f() <span class="comment">//执行传入的无入参函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>作为用于保证函数执行次数的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法<strong>传入不同的函数只会执行第一次调传入的函数</strong>；</li>
</ul>
<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><p>条件变量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a>，它可以让一组的 Goroutine 都在满足特定条件时被唤醒。每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(ch, os.Interrupt)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情</span></span><br><span class="line"><span class="comment">//10 个 Goroutine 通过 sync.Cond.Wait 等待特定条件的满足；</span></span><br><span class="line"><span class="comment">//1 个 Goroutine 会调用 sync.Cond.Broadcast 唤醒所有陷入等待的 Goroutine；</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体:"></a>结构体:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy  noCopy <span class="comment">//保证结构体不会在编译期间拷贝</span></span><br><span class="line">	L       Locker <span class="comment">//用于保护内部的 notify 字段，Locker接口类型的变量；</span></span><br><span class="line">	notify  notifyList <span class="comment">//一个 Goroutine 的链表，它是实现同步机制的核心结构</span></span><br><span class="line">	checker copyChecker <span class="comment">//用于禁止运行期间发生的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait <span class="keyword">uint32</span> <span class="comment">//正在等待的Goroutine索引</span></span><br><span class="line">	notify <span class="keyword">uint32</span> <span class="comment">//已经通知到的Goroutine索引</span></span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">	head *sudog <span class="comment">//链表头</span></span><br><span class="line">	tail *sudog <span class="comment">//链表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><ol>
<li><p>sync.Cond.Wait 将当前 Goroutine 陷入休眠状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify) <span class="comment">// 将等待加数器加一并解锁</span></span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t) <span class="comment">// 等待其他Goroutine的唤醒并加锁</span></span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)<span class="comment">//将当前的Goroutine陷入休眠</span></span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sync.Cond.Signal唤醒队列最前面的Goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从notifyList链表中找到满足条件的Goroutine并唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	t := l.notify</span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			readyWithTime(s, <span class="number">4</span>) <span class="comment">//唤醒</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sync.Cond.Broadcast唤醒队列中全部的Goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次通过readWithTime唤醒链表中的Goroutine</span></span><br><span class="line"><span class="comment">//Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的可能 Goroutine 需要等待调度器的调度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>在一般情况下，我们都会先调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 或者 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 <code>for &#123;&#125;</code> 进行忙碌等待相比，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 能够让出处理器的使用权，提高 CPU 的利用率。使用时我们也需要注意以下问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-05 21:32:34" itemprop="dateCreated datePublished" datetime="2021-12-05T21:32:34+08:00">2021-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-20 20:53:10" itemprop="dateModified" datetime="2021-12-20T20:53:10+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6k42uj67j31260pttdv.jpg" alt="垃圾回收器"></p>
<p>对于一门语言来说，除了需要负责堆内存的分配以外，还需要负责回收不再使用的对象和内存空间。</p>
<h2 id="垃圾收集器的原理"><a href="#垃圾收集器的原理" class="headerlink" title="垃圾收集器的原理"></a>垃圾收集器的原理</h2><p>通常来说管理内存的方式有两种，手动的方式和自动的方式，C,C++等是手动的方式管理的，Java，C#，Objective-C，Go是通过自动管理的，其中Objective-C是通过引用计数，半自动的方式管理的。</p>
<p>在GO语言中，用户程序是通过内存分配器在堆上申请内存，通过垃圾收集器来负责回收堆上的内存。</p>
<p>垃圾回收的基本算法：</p>
<p>GO的垃圾回收器是使用的三色标记清除算法，无分代，不整理，并发。</p>
<p>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象（新生代）上，而非频繁的检查所有的对象。但是对于Go来说，Go的编译器会通过逃逸分析将大部分的新生对象存储到栈上，只有需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h4 id="串行标记清扫："><a href="#串行标记清扫：" class="headerlink" title="串行标记清扫："></a>串行标记清扫：</h4><p>回收器开始执行的时候，会将并发的赋值器挂起（即Stop The World）。</p>
<ol>
<li>挂起赋值器，stop the world</li>
<li>从根集合（寄存器，执行栈，全局变量）开始遍历对象图，标记根对象可达的每一个对象</li>
<li>清扫回收时，会检查堆中的每一个对象，将所有未标记的对象当做垃圾进行回收</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记追踪：从根集合（寄存器、执行栈、全局变量）开始遍历对象图，标记遇到的每个对象；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mark</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist.Init()                       <span class="comment">// 初始化标记 work 列表</span></span><br><span class="line">    <span class="keyword">for</span> root := <span class="keyword">range</span> roots &#123;             <span class="comment">// 从根开始扫描</span></span><br><span class="line">        ref := *root</span><br><span class="line">        <span class="keyword">if</span> ref != <span class="literal">nil</span> &amp;&amp; !isMarked(ref) &#123; <span class="comment">// 标记每个遇到的对象</span></span><br><span class="line">            setMarked(ref)</span><br><span class="line">            worklist.Add(ref)</span><br><span class="line">            <span class="keyword">for</span> !worklist.Empty() &#123;</span><br><span class="line">                ref := worklist.Remove()  <span class="comment">// ref 已经标记过</span></span><br><span class="line">                <span class="keyword">for</span> fld := <span class="keyword">range</span> Pointers(ref) &#123;</span><br><span class="line">                    child := *fld</span><br><span class="line">                    <span class="keyword">if</span> child != <span class="literal">nil</span> &amp;&amp; !isMarked(child) &#123;</span><br><span class="line">                        setMarked(child)</span><br><span class="line">                        worlist.Add(child)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清扫回收：检查堆中每一个对象，将所有未标记的对象当做垃圾进行回收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查堆区间内所有的对象</span></span><br><span class="line">    <span class="keyword">for</span> scan := worklist.Start(); scan &lt; worklist.End(); scan = scan.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> isMarked(scan) &#123;</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            free(scan) <span class="comment">// 将未标记的对象释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3azdn4wrj31a90u0dj4.jpg" alt="img"></p>
<h3 id="并发标记清扫"><a href="#并发标记清扫" class="headerlink" title="并发标记清扫"></a>并发标记清扫</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markSome</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> worklist.empty() &#123;       <span class="comment">// 初始化回收过程</span></span><br><span class="line">        scan(Roots)             <span class="comment">// 赋值器不持有任何白色对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> worklist.empty() &#123;   <span class="comment">// 此时灰色对象已经全部处理完毕</span></span><br><span class="line">            sweep()             <span class="comment">// 标记结束，立即清扫</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收过程尚未完成，后续过程仍需标记</span></span><br><span class="line">    ref = worklist.remove()</span><br><span class="line">    scan(ref)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scan</span><span class="params">(ref <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> fld := <span class="keyword">range</span> Pointers(ref) &#123;</span><br><span class="line">        child := *fld</span><br><span class="line">        <span class="keyword">if</span> child != <span class="literal">nil</span> &#123;</span><br><span class="line">            shade(child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shade</span><span class="params">(ref <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !isMarked(ref) &#123;</span><br><span class="line">        setMarked(ref)</span><br><span class="line">        worklist.add(ref)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在这个过程中，回收器会首先扫描 worklist，而后对根集合进行扫描并重新建立 worklist。 在根集合扫描过程中赋值器现场被挂起时，扫描完成后则不会再存在白色对象。</span><br><span class="line"><span class="comment">//并发清扫</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    collectEnough()</span><br><span class="line">    ref := allocate()</span><br><span class="line">    <span class="keyword">if</span> ref == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectEnough</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stopTheWorld()</span><br><span class="line">    <span class="keyword">defer</span> startTheWorld()</span><br><span class="line">    <span class="keyword">for</span> behind() &#123; <span class="comment">// behind() 控制回收工作每次的执行量</span></span><br><span class="line">        <span class="keyword">if</span> !markSome() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在没有mutator并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于， mutator在回收过程中会并发的更新对象图，从而mutator和回收器可能对对象图的结构产生不同的认知， 这时以一个固定的三色波面作为回收过程前进的边界则不再合理。</span><br></pre></td></tr></table></figure>

<p>垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性</p>
<ol>
<li>mutator修改对象图，导致某一黑色对象引用白色对象；</li>
<li>从灰色对象出发，到达白色对象的、未经访问过的路径被mutator破坏。 只要能够避免其中任何一个条件，则不会出现对象丢失的情况。两个条件都避免，称为强三色不变性，只避免条件1，称为弱三色不变性。</li>
</ol>
<h3 id="mutator屏障技术"><a href="#mutator屏障技术" class="headerlink" title="mutator屏障技术"></a>mutator屏障技术</h3><p>mutator屏障技术即内存屏障，保证代码对内存的操作顺序。不会被CPU乱序执行也不会被编译器优化</p>
<p>三色<strong>标记</strong>法是一种可以并发执行的算法。Collector可以做了一段标记工作后，就让mutator再运行一段。如果在mutator运行期间，一个黑色对象被修改了，比如往一个黑色对象 a 里新存储了一个指针 b，那么把 a 涂成灰色，或者把 b 涂成灰色，就可以了。增量标记的过程中，需要编译器做配合往生成的目标代码中插入读屏障（Read Barrier）和写屏障（Write Barrier）的代码。也就是在程序读写对象的时候，要执行一些逻辑，保证三色的正确性。比如Write Barrier 主要做这样一件事情，<strong>修改原先的写逻辑，当白色节点交由黑色节点引用时， 立刻对被引用节点进行着色，并且着色为”灰色“，并加入到work pool</strong>。因此打开了 Write Barrier 可以保证了三色标记法在并发下安全正确地运行。</p>
<h3 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a>整体实现</h3><ol>
<li><p>什么时候触发下一次GC？</p>
<p>目前触发 GC 的条件使用的是从 Go 1.5 时提出的调步（Pacing）算法，调步算法包含四个部分：</p>
<ol>
<li><p>GC 周期所需的扫描估计器</p>
</li>
<li><p>为用户代码根据堆分配到目标堆大小的时间估计扫描工作量的机制</p>
</li>
<li><p>用户代码为未充分利用 CPU 预算时进行后台扫描的调度程序</p>
</li>
<li><p>GC 触发比率的控制器</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3ib8z6g4j30uo0nrjsl.jpg" alt="img"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">回收器阶段</th>
<th align="left">说明</th>
<th align="left">mutator状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">清扫终止</td>
<td align="left">为下一个阶段的并发标记做准备工作，启动写屏障</td>
<td align="left">STW</td>
</tr>
<tr>
<td align="left">标记</td>
<td align="left">与mutator并发执行，写屏障处于开启状态</td>
<td align="left">并发</td>
</tr>
<tr>
<td align="left">标记终止</td>
<td align="left">保证一个周期内标记任务完成，停止写屏障</td>
<td align="left">STW</td>
</tr>
<tr>
<td align="left">内存清扫</td>
<td align="left">将需要回收的内存归还到堆中，写屏障处于关闭状态</td>
<td align="left">并发</td>
</tr>
<tr>
<td align="left">内存归还</td>
<td align="left">将过多的内存归还给操作系统，写屏障处于关闭状态</td>
<td align="left">并发</td>
</tr>
</tbody></table>
</li>
<li><p>GC如何标记内存</p>
<p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。每个指针被加入到一个 work pool(<code>type gcWork/workbuf struct</code>) 中的队列。后台运行的标记 worker 从这个 work pool 中拿到前面出列的 指针，扫描这个对象然后把在这个对象里找到的指针加入到队列。归功于每一个 span 中的名为 gcmarkBits 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 对象。灰色和黑色在 gcmarkBits 中皆为 1</p>
</li>
<li><p>触发GC的入口</p>
<p>可以调用 runtime.GC来手动的触发 GC。但实际上，触发 GC 的入口一般不会手动调用。正常触发 GC 应该是在申请内存时会调用 <code>runtime.mallocgc</code>或者是 Go 后台的监控线程 sysmon 定时检查调用 <code>runtime.forcegchelper</code></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理 - go栈内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-04 17:56:30" itemprop="dateCreated datePublished" datetime="2021-12-04T17:56:30+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-08 16:50:41" itemprop="dateModified" datetime="2021-12-08T16:50:41+08:00">2021-12-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈空间管理"><a href="#栈空间管理" class="headerlink" title="栈空间管理"></a>栈空间管理</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6iw2lc9sj30hi0bgmxn.jpg" alt="栈"></p>
<h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol>
<li>功能不同：函数调用的参数、返回值以及局部变量都会分配到栈上。</li>
<li>共享性不同：栈是线程私有，堆是共享</li>
<li>栈的空间一般远远小于堆</li>
</ol>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。</p>
<p>栈区的内存由编译器自动分配和释放，其中存储的是函数的入参和局部变量。</p>
<p>总结：Go的栈使用连续栈进行管理，对象或结构体是分配到栈还是堆，由逃逸分析决定，栈是线程私有，Go的栈是以Goroutine作为context，为了高效管理栈，使用了2个寄存器BP,SP来表明其基址和栈顶。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址。BP 和 SP 之间的内存就是当前函数的调用栈。</p>
<p>栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1yjgbzr2j30xj0e6aab.jpg" alt="stack-registers"></p>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><p>创建一个线程时，系统会根据架构不同选择不同的默认栈大小，一般为2~4MB左右，用户程序可以在栈上存储函数参数和局部变量。</p>
<p>对于Go:由于Go设计时以协程实现，所以其再用户态实现Goroutine作为执行上下文。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在手动管理内存的语言中，可以选择将对象或结构体分配到栈或者堆上，但是这样会存在2个问题：</p>
<ul>
<li>不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；</li>
<li>需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；</li>
</ul>
<p>Eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dangling_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 dangling_pointer 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的逃逸分析遵循以下两个不变性：</p>
<ol>
<li>指向栈对象的指针不能存在于堆中；</li>
<li>指向栈对象的指针不能在栈对象回收后存活；</li>
</ol>
<p>Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 <code>new</code>、<code>make</code> 和字面量等方法隐式分配的内存。为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为堆也会被垃圾收集器扫描，所以不会造成内存泄露以及悬挂指针等安全问题。</p>
<p><strong>逃逸分析的实现：</strong></p>
<p>逃逸分析是静态分析的一种，在编译器活动抽象语法树以后，可以通过抽象语法树分析静态的数据流。</p>
<ul>
<li>构建带权重的有向图，其中顶点表示被分配的变量，边表示变量之间的分配关系，权重表示寻址和取地址的次数；</li>
<li>遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么该变量需要分配在堆上；</li>
<li>记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；</li>
</ul>
<h3 id="栈内存空间"><a href="#栈内存空间" class="headerlink" title="栈内存空间"></a>栈内存空间</h3><p>Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多</p>
<p>在1.3版本以后，都是有连续栈，最小栈空间在1.4版本，为2KB</p>
<p>连续栈：</p>
<p>核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。</p>
<p>步骤：</p>
<ol>
<li>在内存空间中分配更大的栈内存空间；</li>
<li>将旧栈中的所有内容复制到新栈中；</li>
<li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li>
<li>销毁并回收旧栈的内存空间；</li>
</ol>
<p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题，即在GC时期合理调整栈的大小。 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。</p>
<h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><h4 id="栈初始化"><a href="#栈初始化" class="headerlink" title="栈初始化"></a>栈初始化</h4><p>运行时使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和线程缓存中的空闲链表分配 32KB 以下的栈内存，使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 和堆内存分配 32KB 以上的栈内存，提高本地分配栈内存的性能。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx263w3xb5j30xc096gma.jpg" alt="stack-memory"></p>
<p>栈空间在运行时中包含两个重要的全局变量，分别是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a>，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：</p>
<p>每一个线程缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 中也都加入了栈缓存减少锁竞争影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackpool [_NumStackOrders]<span class="keyword">struct</span> &#123;</span><br><span class="line">	item stackpoolItem</span><br><span class="line">	_    [cpu.CacheLinePadSize - unsafe.Sizeof(stackpoolItem&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stackpoolItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   mutex</span><br><span class="line">	span mSpanList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackLarge <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock mutex</span><br><span class="line">	free [heapAddrBits - pageShift]mSpanList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的栈内存都是分配到堆上的，运行时初始化会调用<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackinit"><code>runtime.stackinit</code></a> 初始化这些全局变量。</p>
<h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>运行时会在 Goroutine 的初始化函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 中调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配一个大小足够栈内存空间，根据线程缓存和申请栈的大小，该函数会通过三种不同的方法分配栈空间：</p>
<ol>
<li>如果栈空间较小，使用全局栈缓存或者线程缓存上固定大小的空闲链表分配内存；</li>
<li>如果栈空间较大，从全局的大栈缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 中获取内存空间；</li>
<li>如果栈空间较大并且 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 空间不足，在堆上申请一片大小足够内存空间；</li>
</ol>
<h4 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h4><p>编译器会在函数调用中插入运行时检查，检查函数调用当前Goroutine的栈空间是否充足，当需要扩容时，会保存一些栈的信息并调用runtime.newstack创建新栈进行扩容</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newstack"><code>runtime.newstack</code></a> 会先做一些准备工作并检查当前 Goroutine 是否发出了抢占请求。如果当前 Goroutine 不需要被抢占，意味着我们需要新的栈空间来支持函数调用和本地变量的初始化，运行时会先检查目标大小的栈是否会溢出。</p>
<p>如果目标栈的大小没有超出程序的限制，我们会将 Goroutine 切换至 <code>_Gcopystack</code> 状态并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.copystack"><code>runtime.copystack</code></a> 开始栈拷贝。在拷贝栈内存之前，运行时会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配新的栈空间：</p>
<p>分配好以后开始拷贝栈空间</p>
<p>同上的连续栈扩容</p>
<h4 id="栈缩容"><a href="#栈缩容" class="headerlink" title="栈缩容"></a>栈缩容</h4><p>GC时，使用率为1/4时，缩容为之前的一半，也会coptyStack</p>
<h3 id="栈内容扩展"><a href="#栈内容扩展" class="headerlink" title="栈内容扩展"></a>栈内容扩展</h3><h4 id="栈的汇编分析"><a href="#栈的汇编分析" class="headerlink" title="栈的汇编分析"></a>栈的汇编分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = a + b + x;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">.LFB0:</span><br><span class="line">    .file <span class="number">1</span> <span class="string">&quot;call_no_stack.c&quot;</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp             <span class="comment">//rbp入栈 （rsp-8）</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp       <span class="comment">//rsp 赋值给 rbp，这里rsp并没有移动，可能是因为这里是最后一个函数调用，所以不需要移动rsp</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)  <span class="comment">//这里通过rbp来访问栈，将main函数中的实参2放入rbp-20内存</span></span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)  <span class="comment">//这里表示栈空间分配了24字节，猜测：函数中的参数值从栈顶开始存储</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    movb    $<span class="number">1</span>, <span class="number">-5</span>(%rbp)     <span class="comment">//局部变量x入栈，x占用1个字节，相当于x后入栈：栈的地址是向下减少的</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)     <span class="comment">//局部变量c入栈，放在rbp-4处</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">7</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx   </span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %eax, %edx      <span class="comment">//相加操作</span></span><br><span class="line">    movsbl    <span class="number">-5</span>(%rbp), %eax </span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">8</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax  <span class="comment">//将c变量的结果保存到eax寄存器，以便函数返回</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">    popq    %rbp            <span class="comment">//将堆栈pop，此时栈顶保存着调用函数的rbp值，将栈顶元素赋予rbp寄存器（恢复rbp寄存器）</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                     <span class="comment">//跳转回上一层处继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size    foo, .-foo</span><br><span class="line">    .globl    main</span><br><span class="line">    .type    main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">12</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp              <span class="comment">//rbp：64位寄存器——指向栈底，将rbp寄存器内的值入栈-pushq操作会改变rsp的值</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp         <span class="comment">//rsp：64位堆栈指针寄存器——指向栈顶，将rsp值存入rbp寄存器内</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp          <span class="comment">//rsp-16，这里讲栈顶指针向下移动16字节，相当于为main函数预留了16字节的栈空间-保存局部变量包括实参</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">13</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)       <span class="comment">//对应局部变量ret = 0</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">14</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">3</span>, %esi           <span class="comment">//这里直接将实参存入esi寄存器而不是放入堆栈，可加快访问速度</span></span><br><span class="line">    movl    $<span class="number">2</span>, %edi</span><br><span class="line">    call    foo                <span class="comment">//调用foo函数:call指令有另个作用：1，将call指令的下一条指令入栈-并改变rsp 2，修改程序计数器eip，跳转到foo函数的开头执行</span></span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)     <span class="comment">//eax寄存器保存着返回值，这里将eax赋值给rbp-4的位置，也就是ret</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">15</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">16</span> <span class="number">0</span></span><br><span class="line">    leave                     <span class="comment">//leave指令是函数开头的pushq %rbp和movq %rsp,%rbp的逆操作,　　　　　　　　　　　　　　　　　　//有两个作用：1，把rbp赋值给rsp 2,然后把该函数栈栈顶保存的rbp值恢复到rbp寄存器中,同时rsp+4(第二部的操作相当于pop栈顶元素)</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                       <span class="comment">//现在栈顶元素保存的是下一条执行的指令，ret的作用就是pop栈顶元素，并将栈顶元素赋值给程序计数器bip，然后程序跳转回bip所在地址继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size    main, .-main</span><br></pre></td></tr></table></figure>

<ol>
<li>变量存储会按照会根据类型，在汇编的得出其偏移量来操作</li>
<li>只有两个寄存器bp,sp来管理当前栈帧，之前已经入栈的栈帧的相关信息，会存储到其上下文中</li>
</ol>
<h4 id="栈空间对齐"><a href="#栈空间对齐" class="headerlink" title="栈空间对齐"></a>栈空间对齐</h4><p>栈的字节对齐，实际是指栈顶指针必须是16字节的整数倍，栈对齐是为了尽可能少的内存访问周期读取数据，保证性能 - 任何内存分配函数(alloca, malloc, calloc)生成的块的起始地址必须为16的整数倍。大多数函数的栈帧的边界必须为16的整数倍。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>C语言函数栈帧实例：<a target="_blank" rel="noopener" href="https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html">https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/28/go-runtime-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/28/go-runtime-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-28 20:10:39" itemprop="dateCreated datePublished" datetime="2021-11-28T20:10:39+08:00">2021-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-08 16:57:07" itemprop="dateModified" datetime="2021-12-08T16:57:07+08:00">2021-12-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6j27txd4j30u00vygpo.jpg" alt="内存分配器"></p>
<p>程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。</p>
<p>栈：函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；</p>
<p>堆：不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzzuklofzj30xc0h8dgg.jpg" alt="mutator-allocator-collector"></p>
<p>分配方法：一般编程语言的内存分配器包括两种，一种是线性分配器，还有一种是空闲列表分配器。</p>
<h3 id="线性分配器"><a href="#线性分配器" class="headerlink" title="线性分配器"></a>线性分配器</h3><p>使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置</p>
<p>问题：线性分配器无法在内存被释放时重用内存。</p>
<p>因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。</p>
<p>因为线性分配器需要与具有拷贝特性的垃圾回收算法配合，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzzyghypaj30xc082t8w.jpg" alt="bump-allocator"></p>
<h3 id="空闲列表分配器"><a href="#空闲列表分配器" class="headerlink" title="空闲列表分配器"></a>空闲列表分配器</h3><p>类似与早期操作系统的，使用链表管理内存的结构。</p>
<p>这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 𝑂(𝑛)。</p>
<p>选择策略上有4种:</p>
<ol>
<li>首次适应</li>
<li>循环首次适应</li>
<li>最优适应</li>
<li>隔离适应</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwzzzjuq0pj30xc08wdga.jpg" alt="free-list-allocator"></p>
<h3 id="Go采用的方式-空闲列表分配器配合类似隔离适应"><a href="#Go采用的方式-空闲列表分配器配合类似隔离适应" class="headerlink" title="Go采用的方式 - 空闲列表分配器配合类似隔离适应"></a>Go采用的方式 - 空闲列表分配器配合类似隔离适应</h3><h4 id="基本数据结构："><a href="#基本数据结构：" class="headerlink" title="基本数据结构："></a>基本数据结构：</h4><p>该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，它会在上图中找到满足条件的空闲内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。即先找到合适的链表，再去找合适的内存块。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx003dwnrxj30xc0gedgs.jpg" alt="segregated-list"></p>
<h4 id="分级分配："><a href="#分级分配：" class="headerlink" title="分级分配："></a>分级分配：</h4><p>线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的机制，它比 glibc 中的 <code>malloc</code> 还要快很多。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。</p>
<p>运行时根据对象的大小将对象分成微对象、小对象和大对象三种：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">微对象</td>
<td align="center"><code>(0, 16B)</code></td>
</tr>
<tr>
<td align="center">小对象</td>
<td align="center"><code>[16B, 32KB]</code></td>
</tr>
<tr>
<td align="center">大对象</td>
<td align="center"><code>(32KB, +∞)</code></td>
</tr>
</tbody></table>
<p><strong>表 7-1 对象的类别和大小</strong></p>
<p>因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。</p>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>内存分成不同的级别分别管理，线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx008emudtj30xc0hs3zj.jpg" alt="multi-level-cache"></p>
<p>32KB以上的对象，内存分配器会直接分配到页堆，线程缓存不足时，会使用中心缓存进行补充</p>
<h4 id="虚拟内存布局"><a href="#虚拟内存布局" class="headerlink" title="虚拟内存布局"></a>虚拟内存布局</h4><p>稀疏内存：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx29xhzis0j30xj0dmaar.jpg" alt="heap-after-go-1-11"></p>
<p>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题，不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂。</p>
<p>如图所示，使用二维的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.heapArena"><code>runtime.heapArena</code></a> 数组管理所有的内存，每个单元都会管理 64MB 的内存空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">	bitmap       [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line">	spans        [pagesPerArena]*mspan</span><br><span class="line">	pageInUse    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	pageMarks    [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">	checkmarks   *checkmarksMap</span><br><span class="line">	zeroedBase   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bitmap</code> 用于标识 <code>arena</code> 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否空闲；</p>
<p><code>arena</code> 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</p>
<p><code>zeroedBase</code> 字段指向了该结构体管理的内存的基地址。</p>
<h3 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h3><p>最重要的几种组件：runtime.mspan, runtime.mcache, runtime.mcentral, runtime.mheap</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2a4fmmlbj30xj0oqtaq.jpg" alt="go-memory-layout"></p>
<p>Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 用于处理微对象和小对象的分配，它们会持有内存管理单元 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>。</p>
<p>每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 持有的 134 个中心缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 中获取新的内存单元，中心缓存属于全局的堆结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a>，它会从操作系统中申请内存。</p>
<h4 id="内存管理单元runtime-mspan"><a href="#内存管理单元runtime-mspan" class="headerlink" title="内存管理单元runtime.mspan"></a>内存管理单元runtime.mspan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *mspan</span><br><span class="line">	prev *mspan</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mspan是Go语言内存管理的基本单元，它们会构成双向链表的形式，运行时使用mSpanList来使用</p>
<p>每个mspan都管理着npages个大小为8KB的页（操作系统内存页的整数倍）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	startAddr <span class="keyword">uintptr</span> <span class="comment">// 起始地址</span></span><br><span class="line">	npages    <span class="keyword">uintptr</span> <span class="comment">// 页数</span></span><br><span class="line">	freeindex <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	allocBits  *gcBits</span><br><span class="line">	gcmarkBits *gcBits</span><br><span class="line">	allocCache <span class="keyword">uint64</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startAddr 和 npages — 确定该结构体管理的多个页所在的内存，每个页的大小都是 <span class="number">8</span>KB；</span><br><span class="line">freeindex — 扫描页中空闲对象的初始索引；</span><br><span class="line">allocBits 和 gcmarkBits — 分别用于标记内存的占用和回收情况；</span><br><span class="line">allocCache — allocBits 的补码，可以用于快速查找内存中未被使用的内存；</span><br></pre></td></tr></table></figure>

<p>mspan管理内存：</p>
<ol>
<li><p>当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ah0tzpuj30xj0gemxn.jpg" alt="mspan-and-pages"></p>
</li>
<li><p>当用户程序或者线程向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 申请内存时，它会使用 <code>allocCache</code> 字段以对象为单位在管理的内存中快速查找待分配的空间。如果我们能在内存中找到空闲的内存单元会直接返回，当内存中不包含空闲的内存时，上一级的组件 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 会为调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.refill"><code>runtime.mcache.refill</code></a> 更新内存管理单元以满足为更多对象分配内存的需求。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ah7gfxlj30xj0d2mxx.jpg" alt="mspan-and-objects"></p>
</li>
</ol>
<p>每个内存管理单元的状态使用mSpanStateBox管理</p>
<p>该状态可能处于 <code>mSpanDead</code>、<code>mSpanInUse</code>、<code>mSpanManual</code> 和 <code>mSpanFree</code> 四种情况。当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 在空闲堆中，它会处于 <code>mSpanFree</code> 状态；当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 已经被分配时，它会处于 <code>mSpanInUse</code>、<code>mSpanManual</code> 状态，运行时会遵循下面的规则转换该状态：</p>
<ul>
<li>在垃圾回收的任意阶段，可能从 <code>mSpanFree</code> 转换到 <code>mSpanInUse</code> 和 <code>mSpanManual</code>；</li>
<li>在垃圾回收的清除阶段，可能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li>
<li>在垃圾回收的标记阶段，不能从 <code>mSpanInUse</code> 和 <code>mSpanManual</code> 转换到 <code>mSpanFree</code>；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	state       mSpanStateBox</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="跨度类"><a href="#跨度类" class="headerlink" title="跨度类"></a>跨度类</h5><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanClass"><code>runtime.spanClass</code></a> 是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的跨度类，它决定了内存管理单元中存储的对象大小和个数。</p>
<p>Go 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.class_to_size"><code>runtime.class_to_size</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.class_to_allocnpages"><code>runtime.class_to_allocnpages</code></a> 等变量中。</p>
<p><strong>跨度类的数据</strong></p>
<p>会有ID为0的跨度类管理超过32KB的对象</p>
<table>
<thead>
<tr>
<th align="center">class</th>
<th align="right">bytes/obj</th>
<th align="right">bytes/span</th>
<th align="right">objects</th>
<th align="center">tail waste</th>
<th align="center">max waste</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="right">8</td>
<td align="right">8192</td>
<td align="right">1024</td>
<td align="center">0</td>
<td align="center">87.50%</td>
</tr>
<tr>
<td align="center">2</td>
<td align="right">16</td>
<td align="right">8192</td>
<td align="right">512</td>
<td align="center">0</td>
<td align="center">43.75%</td>
</tr>
<tr>
<td align="center">3</td>
<td align="right">24</td>
<td align="right">8192</td>
<td align="right">341</td>
<td align="center">0</td>
<td align="center">29.24%</td>
</tr>
<tr>
<td align="center">4</td>
<td align="right">32</td>
<td align="right">8192</td>
<td align="right">256</td>
<td align="center">0</td>
<td align="center">46.88%</td>
</tr>
<tr>
<td align="center">5</td>
<td align="right">48</td>
<td align="right">8192</td>
<td align="right">170</td>
<td align="center">32</td>
<td align="center">31.52%</td>
</tr>
<tr>
<td align="center">6</td>
<td align="right">64</td>
<td align="right">8192</td>
<td align="right">128</td>
<td align="center">0</td>
<td align="center">23.44%</td>
</tr>
<tr>
<td align="center">7</td>
<td align="right">80</td>
<td align="right">8192</td>
<td align="right">102</td>
<td align="center">32</td>
<td align="center">19.07%</td>
</tr>
<tr>
<td align="center">…</td>
<td align="right">…</td>
<td align="right">…</td>
<td align="right">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">67</td>
<td align="right">32768</td>
<td align="right">32768</td>
<td align="right">1</td>
<td align="center">0</td>
<td align="center">12.50%</td>
</tr>
</tbody></table>
<h4 id="线程缓存"><a href="#线程缓存" class="headerlink" title="线程缓存"></a>线程缓存</h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>，这些内存管理单元都存储在结构体的 <code>alloc</code> 字段中，线程缓存在刚刚被初始化时是不包含 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 的，只有当用户程序申请内存时才会从上一级组件获取新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a> 满足内存分配的需求。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2at81uv6j30xj0b4dgd.jpg" alt="mcache-and-mspans"></p>
<ol>
<li><p>初始化：在初始化处理器时，在系统栈中使用mheap的线程缓存分配器初始化，mcache</p>
</li>
<li><p>替换：<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.refill"><code>runtime.mcache.refill</code></a> 会为线程缓存获取一个指定跨度类的内存管理单元，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：</p>
</li>
<li><p>微分配器：线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门管理 16 字节以下的对象。微分配器只会用于分配非指针类型的内存，上述三个字段中 <code>tiny</code> 会指向堆中的一片内存，<code>tinyOffset</code> 是下一个空闲内存所在的偏移量，最后的 <code>local_tinyallocs</code> 会记录内存分配器中分配的对象个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">	tiny             <span class="keyword">uintptr</span></span><br><span class="line">	tinyoffset       <span class="keyword">uintptr</span></span><br><span class="line">	local_tinyallocs <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="中心缓存"><a href="#中心缓存" class="headerlink" title="中心缓存"></a>中心缓存</h4><p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanSet"><code>runtime.spanSet</code></a>，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p>
<h4 id="页堆"><a href="#页堆" class="headerlink" title="页堆"></a>页堆</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2b0hrqenj30xj0aa74v.jpg" alt="mheap-and-mcentrals"></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 <code>central</code>，另一个是管理堆区内存区域的 <code>arenas</code> 以及相关字段。</p>
<p>页堆中包含一个长度为 136 的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 数组，其中 68 个为跨度类需要 <code>scan</code> 的中心缓存，另外的 68 个是 <code>noscan</code> 的中心缓存。</p>
<ol>
<li><p>内存管理单元：</p>
<p>mspan获取新的单元是通过mheap.alloc获取的</p>
<p>先调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.reclaim"><code>runtime.mheap.reclaim</code></a> 方法回收一部分内存，随后运行时通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.allocSpan"><code>runtime.mheap.allocSpan</code></a> 分配新的内存管理单元</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npages <span class="keyword">uintptr</span>, spanclass spanClass, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">			h.reclaim(npages)</span><br><span class="line">		&#125;</span><br><span class="line">		s = h.allocSpan(npages, <span class="literal">false</span>, spanclass, &amp;memstats.heap_inuse)</span><br><span class="line">	&#125;)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩容：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.grow"><code>runtime.mheap.grow</code></a> 会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：</p>
<ol>
<li>通过传入的页数获取期望分配的内存空间大小以及内存的基地址；</li>
<li>如果 <code>arena</code> 区域没有足够的空间，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap.sysAlloc"><code>runtime.mheap.sysAlloc</code></a> 从操作系统中申请更多的内存；</li>
<li>扩容 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> 持有的 <code>arena</code> 区域并更新页分配器的元信息；</li>
<li>在某些场景下，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.pageAlloc.scavenge"><code>runtime.pageAlloc.scavenge</code></a> 回收不再使用的空闲内存页；</li>
</ol>
</li>
</ol>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>堆上所有的对象都是通过runtime.newobject分配内存的，其会调用runtime.mallocgc分配</p>
<p>可以看到，其会按照对象大小来按不同的方式进行内存分配</p>
<p><strong>三种对象</strong></p>
<ul>
<li>微对象 <code>(0, 16B)</code> — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</li>
<li>小对象 <code>[16B, 32KB]</code> — 依次尝试使用线程缓存、中心缓存和堆分配内存；</li>
<li>大对象 <code>(32KB, +∞)</code> — 直接在堆上分配内存；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	c := gomcache()</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">			<span class="comment">// 微对象分配</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 小对象分配</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象分配</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	publicationBarrier()</span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="微对象"><a href="#微对象" class="headerlink" title="微对象"></a>微对象</h4><p>小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。</p>
<p>微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 <code>maxTinySize</code> 是可以调整的，在默认情况下，内存块的大小为 16 字节。<code>maxTinySize</code> 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；<code>maxTinySize</code> 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。</p>
<ul>
<li>微分配器</li>
</ul>
<h4 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h4><p>小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象，小对象的分配可以被分成以下的三个步骤：</p>
<ol>
<li>确定分配对象的大小以及跨度类 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.spanClass"><code>runtime.spanClass</code></a>；</li>
<li>从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.memclrNoHeapPointers"><code>runtime.memclrNoHeapPointers</code></a> 清空空闲内存中的所有数据；</li>
</ol>
<h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache.allocLarge"><code>runtime.mcache.allocLarge</code></a> 分配大片内存</p>
<h4 id="内存分配算法TCMalloc"><a href="#内存分配算法TCMalloc" class="headerlink" title="内存分配算法TCMalloc"></a>内存分配算法TCMalloc</h4><p>在 TCMalloc 内存管理内部分为两个部分：线程内存（thread memory)和页堆（page heap）。</p>
<ol>
<li>每一个线程都可以获得一个用于无锁分配小对象的缓存，这样可以让并行程序分配小对象（&lt;=32KB）非常高效。PS, java 中叫TLAB：Thread Local Allocation Buffer。Go 中叫mcache（挂在每一个P上）</li>
<li>TCMalloc 管理的堆由一组页组成，<strong>一组连续的页面被表示为 span</strong>。当分配的对象大于 32KB，将使用页堆（Page Heap）进行内存分配。</li>
</ol>
<p>Go 的内存分配器基于 Thread-Cache Malloc (tcmalloc) ，tcmalloc 为每个线程实现了一个本地缓存， 区分了小对象（小于 32kb）和大对象分配两种分配类型，其管理的内存单元称为 span。但与 tcmalloc 存在一定差异。 这个差异来源于 Go 语言被设计为没有显式的内存分配与释放， 完全依靠编译器与运行时的配合来自动处理，因此也就造就了内存分配器、垃圾回收器两大组件。统一管理内存会提前分配或一次性释放一大块内存， 进而减少与操作系统沟通造成的开销，进而提高程序的运行性能。 支持内存管理另一个优势就是能够更好的支持垃圾回收。</p>
<h4 id="内存分配器的核心组件："><a href="#内存分配器的核心组件：" class="headerlink" title="内存分配器的核心组件："></a>内存分配器的核心组件：</h4><ol>
<li><p>heapArena: 保留整个虚拟地址空间</p>
</li>
<li><p>mheap：分配的堆，在页大小为 8KB 的粒度上进行管理</p>
</li>
<li><p>mspan：是 mheap 上管理的一连串的页</p>
</li>
<li><p>mcentral：收集了给定大小等级的所有 span</p>
</li>
<li><p>mcache：为 per-P 的缓存。</p>
</li>
</ol>
<p><strong>go 基于上述 struct 提供了 runtime.newobject 用于goroutine 代码申请内存，由gc 负责回收</strong>。runtime.newobject 就是内存分配的核心入口</p>
<p>页是向操作系统申请内存的最小单位，目前设计为 8KB。传统意义上的栈被 Go 的运行时霸占，不开放给用户态代码；而传统意义上的堆内存，又被 Go 运行时划分为了两个部分， 一个是 Go 运行时自身所需的堆内存，即堆外内存；另一部分则用于 Go 用户态代码所使用的堆内存，也叫做 Go 堆。 Go 堆负责了用户态对象的存放以及 goroutine 的执行栈。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx01et2bvvj337v0u00yu.jpg" alt="img"></p>
<p>Go 内存管理的一般思想是使用不同的内存结构为不同大小的对象使用不同的内存缓存级别来分配内存。将一个从操作系统接收的连续地址的块切分到多级缓存来减少锁的使用，同时<strong>根据object的大小</strong>分配内存减少内存碎片以提高内存分配的效率和在内存释放之后加快 GC 运行的速度。mcache ==&gt; mcentral ==&gt; mheap（向堆申请一个arena） ==&gt; 堆</p>
<ol>
<li>大于 32K 的大对象直接从 mheap 分配。</li>
<li>小于 16B 的使用 mcache 的微型分配器分配</li>
<li>对象大小在 16B ~ 32K 之间的的，首先通过计算使用的大小规格，然后使用 mcache 中对应大小规格的块分配</li>
<li>如果对应的大小规格在 mcache 中没有可用的块，则向 mcentral 申请</li>
<li>如果 mcentral 中没有可用的块，则向 mheap 申请，并根据 BestFit 算法找到最合适的 mspan。如果申请到的 mspan 超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的 mspan 放回 mheap 的空闲列表。</li>
<li>如果 mheap 中没有可用 span，则向操作系统申请一系列新的页（最小 1MB）。 Go 会在操作系统分配超大的页（称作 arena）。分配一大批页会减少和操作系统通信的成本。</li>
</ol>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/" class="post-title-link" itemprop="url">Go多线程编程2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-28 16:09:04 / Modified: 18:11:35" itemprop="dateCreated datePublished" datetime="2021-11-28T16:09:04+08:00">2021-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go多线程编程"><a href="#Go多线程编程" class="headerlink" title="Go多线程编程"></a>Go多线程编程</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul>
<li>Timer：时间到了，执行只执行1次</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 使用</span><br><span class="line">timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">t2 := &lt;-timer1.C</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 延时</span><br><span class="line">(<span class="number">1</span>)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"> timer3 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"> &lt;-timer3.C</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">&lt;-time.After(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 停止</span><br><span class="line">timer4 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">timer4.Stop()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 重置定时器</span><br><span class="line">timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">timer5.Reset(<span class="number">1</span> * time.Second)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.timer基本使用</span></span><br><span class="line">   <span class="comment">//timer1 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//t1 := time.Now()</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t1:%v\n&quot;, t1)</span></span><br><span class="line">   <span class="comment">//t2 := &lt;-timer1.C</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t2:%v\n&quot;, t2)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.验证timer只能响应1次</span></span><br><span class="line">   <span class="comment">//timer2 := time.NewTimer(time.Second)</span></span><br><span class="line">   <span class="comment">//for &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer2.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;时间到&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.timer实现延时的功能</span></span><br><span class="line">   <span class="comment">//(1)</span></span><br><span class="line">   <span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">   <span class="comment">//(2)</span></span><br><span class="line">   <span class="comment">//timer3 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//&lt;-timer3.C</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line">   <span class="comment">//(3)</span></span><br><span class="line">   <span class="comment">//&lt;-time.After(2*time.Second)</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.停止定时器</span></span><br><span class="line">   <span class="comment">//timer4 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//go func() &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer4.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;定时器执行了&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;()</span></span><br><span class="line">   <span class="comment">//b := timer4.Stop()</span></span><br><span class="line">   <span class="comment">//if b &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;timer4已经关闭&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.重置定时器</span></span><br><span class="line">   timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">   timer5.Reset(<span class="number">1</span> * time.Second)</span><br><span class="line">   fmt.Println(time.Now())</span><br><span class="line">   fmt.Println(&lt;-timer5.C)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ticker：时间到了，多次执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取ticker对象</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;-ticker.C</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(&lt;-ticker.C)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                ticker.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>用法类似与Socket里的select</p>
<p>作用：select关键字，可以同时响应多个通道的操作。</p>
<ul>
<li>select可以同时监听一个或多个channel，直到其中一个channel ready</li>
<li>如果多个channel同时ready，则随机选择一个执行</li>
<li>可以用于判断管道是否存满</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">       <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">       <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断管道是否存满</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发安全与锁"><a href="#并发安全与锁" class="headerlink" title="并发安全与锁"></a>并发安全与锁</h2><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>注意：sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>实现单例和资源只加载一次的方法</p>
<p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<p>sync.Once只有一个Do方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>map不是线程安全的，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<p><strong>猜测实现类似于Java中的ConcurrentHashMap，待研究</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>
<p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
<h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func LoadInt32(addr *int32) (val int32) func LoadInt64(addr <code>*int64</code>) (val int64)<br>func LoadUint32(addr<code>*uint32</code>) (val uint32)<br>func LoadUint64(addr<code>*uint64</code>) (val uint64)<br>func LoadUintptr(addr<code>*uintptr</code>) (val uintptr)<br>func LoadPointer(addr<code>*unsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td>func StoreInt32(addr <code>*int32</code>, val int32) func StoreInt64(addr <code>*int64</code>, val int64) func StoreUint32(addr <code>*uint32</code>, val uint32) func StoreUint64(addr <code>*uint64</code>, val uint64) func StoreUintptr(addr <code>*uintptr</code>, val uintptr) func StorePointer(addr <code>*unsafe.Pointer</code>, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td>func AddInt32(addr <code>*int32</code>, delta int32) (new int32) func AddInt64(addr <code>*int64</code>, delta int64) (new int64) func AddUint32(addr <code>*uint32</code>, delta uint32) (new uint32) func AddUint64(addr <code>*uint64</code>, delta uint64) (new uint64) func AddUintptr(addr <code>*uintptr</code>, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td>func SwapInt32(addr <code>*int32</code>, new int32) (old int32) func SwapInt64(addr <code>*int64</code>, new int64) (old int64) func SwapUint32(addr <code>*uint32</code>, new uint32) (old uint32) func SwapUint64(addr <code>*uint64</code>, new uint64) (old uint64) func SwapUintptr(addr <code>*uintptr</code>, new uintptr) (old uintptr) func SwapPointer(addr <code>*unsafe.Pointer</code>, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td>func CompareAndSwapInt32(addr <code>*int32</code>, old, new int32) (swapped bool) func CompareAndSwapInt64(addr <code>*int64</code>, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <code>*uint32</code>, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr <code>*uint64</code>, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <code>*uintptr</code>, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr <code>*unsafe.Pointer</code>, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody></table>
<h3 id="原子操作和互斥锁的性能比较"><a href="#原子操作和互斥锁的性能比较" class="headerlink" title="原子操作和互斥锁的性能比较"></a>原子操作和互斥锁的性能比较</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// x = x + 1</span></span><br><span class="line">    x++ <span class="comment">// 等价于上面的操作</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l.Lock()</span><br><span class="line">    x++</span><br><span class="line">    l.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;x, <span class="number">1</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// go add()       // 普通版add函数 不是并发安全的</span></span><br><span class="line">        <span class="comment">// go mutexAdd()  // 加锁版add函数 是并发安全的，但是加锁性能开销大</span></span><br><span class="line">        <span class="keyword">go</span> atomicAdd() <span class="comment">// 原子操作版add函数 是并发安全，性能优于加锁版</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">go</span> mutexAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.672672</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> atomicAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.63377</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="number">9171</span></span><br><span class="line"><span class="number">5.170112</span>ms</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/27/go%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/27/go%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">go基础 - 方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-27 16:43:49 / Modified: 23:56:07" itemprop="dateCreated datePublished" datetime="2021-11-27T16:43:49+08:00">2021-11-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p>
<p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>
<p>所有给定类型的方法属于该类型的方法集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 只能为当前包内命名类型定义方法。</span><br><span class="line">• 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。</span><br><span class="line">• 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。 </span><br><span class="line">• 不支持方法重载，receiver 只是参数签名的组成部分。</span><br><span class="line">• 可用实例 value 或 pointer 调用全部方法，编译器自动转换。</span><br></pre></td></tr></table></figure>

<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">参数和返回值可以省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</span></span><br></pre></td></tr></table></figure>

<p>指针类型接收者和值类型接收者：当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self Data)</span> <span class="title">ValueTest</span><span class="params">()</span></span> &#123; <span class="comment">// func ValueTest(self Data);</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Value: %p\n&quot;</span>, &amp;self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Data)</span> <span class="title">PointerTest</span><span class="params">()</span></span> &#123; <span class="comment">// func PointerTest(self *Data);</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Pointer: %p\n&quot;</span>, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Data&#123;&#125;</span><br><span class="line">    p := &amp;d</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Data: %p\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    d.ValueTest()   <span class="comment">// ValueTest(d)</span></span><br><span class="line">    d.PointerTest() <span class="comment">// PointerTest(&amp;d)</span></span><br><span class="line"></span><br><span class="line">    p.ValueTest()   <span class="comment">// ValueTest(*p)</span></span><br><span class="line">    p.PointerTest() <span class="comment">// PointerTest(p)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">Data: <span class="number">0xc42007c008</span></span><br><span class="line">Value: <span class="number">0xc42007c018</span></span><br><span class="line">Pointer: <span class="number">0xc42007c008</span></span><br><span class="line">Value: <span class="number">0xc42007c020</span></span><br><span class="line">Pointer: <span class="number">0xc42007c008</span></span><br></pre></td></tr></table></figure>

<h2 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h2><p>1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</p>
<p>2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。但是值类型的接受者，使用指针类型的变量调用方法也是值拷贝的形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通函数</span></span><br><span class="line"><span class="comment">//接收值类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valueIntTest</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收指针类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerIntTest</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;valueIntTest:&quot;</span>, valueIntTest(a))</span><br><span class="line">    <span class="comment">//函数的参数为值类型，则不能直接将指针作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))</span></span><br><span class="line">    <span class="comment">//compile error: cannot use &amp;a (type *int) as type int in function argument</span></span><br><span class="line"></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;pointerIntTest:&quot;</span>, pointerIntTest(&amp;b))</span><br><span class="line">    <span class="comment">//同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))</span></span><br><span class="line">    <span class="comment">//compile error:cannot use b (type int) as type *int in function argument</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法</span></span><br><span class="line"><span class="keyword">type</span> PersonD <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PersonD)</span> <span class="title">valueShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonD)</span> <span class="title">pointShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//值类型调用方法</span></span><br><span class="line">    personValue := PersonD&#123;<span class="number">101</span>, <span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">    personValue.valueShowName()</span><br><span class="line">    personValue.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针类型调用方法</span></span><br><span class="line">    personPointer := &amp;PersonD&#123;<span class="number">102</span>, <span class="string">&quot;hello golang&quot;</span>&#125;</span><br><span class="line">    personPointer.valueShowName()</span><br><span class="line">    personPointer.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structTestValue()</span><br><span class="line">    structTestFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">valueIntTest: <span class="number">12</span></span><br><span class="line">pointerIntTest: <span class="number">15</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello golang</span><br><span class="line">hello golang</span><br></pre></td></tr></table></figure>

<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>可以像字段成员那样访问匿名字段方法，编译器负责查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>,u,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Manager&#123;User&#123;id: <span class="number">1</span>,name: <span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Manager: %p\n&quot;</span>, &amp;m)</span><br><span class="line">	fmt.Println(m.ToString())</span><br><span class="line">	u := User&#123;</span><br><span class="line">		id: <span class="number">2</span>,</span><br><span class="line">		name: <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;User: %p\n&quot;</span>,&amp;u)</span><br><span class="line">	fmt.Println(u.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Manager: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;, <span class="string">&quot;Administrator&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.User.ToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">Manager: <span class="number">0xc420074180</span>, &amp;&#123;&#123;<span class="number">1</span> Tom&#125; Administrator&#125;</span><br><span class="line">User: <span class="number">0xc420074180</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 类型 T 方法集包含全部 receiver T 方法。</span><br><span class="line">• 类型 *T 方法集包含全部 receiver T + *T 方法。</span><br><span class="line">• 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 </span><br><span class="line">• 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 </span><br><span class="line">• 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。</span><br></pre></td></tr></table></figure>

<p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p>
<p>方法集对接口的影响：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending user email to %s&lt;%s&gt;\n&quot;</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;bill@email.com&quot;</span>&#125;</span><br><span class="line">    sendNotificatioin(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotificatioin</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">20</span>: cannot use u (<span class="keyword">type</span> user) as <span class="keyword">type</span> notifier in argument to sendNotificatioin:</span><br><span class="line">        user does not implement notifier (notify method has pointer receiver)</span><br></pre></td></tr></table></figure>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...) ---&gt; &lt;type&gt;.func(instance, args...)</span><br><span class="line">前者称为 method value，后者 method expression。</span><br><span class="line">两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line">    mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">    mExpression := (*User).Test</span><br><span class="line">    mExpression(&amp;u) <span class="comment">// 显式传递 receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法“还原”成函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Data)</span> <span class="title">TestValue</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Data)</span> <span class="title">TestPointer</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Data = <span class="literal">nil</span></span><br><span class="line">    p.TestPointer()</span><br><span class="line"></span><br><span class="line">    (*Data)(<span class="literal">nil</span>).TestPointer() <span class="comment">// method value</span></span><br><span class="line">    (*Data).TestPointer(<span class="literal">nil</span>)   <span class="comment">// method expression</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.TestValue()            // invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Data)(nil).TestValue()  // cannot convert nil to type Data</span></span><br><span class="line">    <span class="comment">// Data.TestValue(nil)      // cannot use nil as type Data in function argument</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zhongsongzhi97.github.io/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/zhongsongzhi97.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/zhongsongzhi97.github.io/page/3/">3</a><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
