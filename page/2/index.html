<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/2/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/02/10/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">序列化和反序列化小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-10 16:40:37 / Modified: 17:22:07" itemprop="dateCreated datePublished" datetime="2022-02-10T16:40:37+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">序列化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序列化和反序列化小结"><a href="#序列化和反序列化小结" class="headerlink" title="序列化和反序列化小结"></a>序列化和反序列化小结</h1><p>序列化是指把数据结构或对象转化为可存储或可传输的结构，这种结构可以用于重建数据结构或对象。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Json</td>
<td>文本</td>
<td>1. 人可读 2. 属性顺序对序列化反序列化无影响</td>
<td>1. 丢弃了类型信息，eg: “num”:100，这里对于num的类型信息是不可知的，解析存在二义性 2. 不支持二进制数据类型</td>
</tr>
<tr>
<td>Protobuf</td>
<td>二进制</td>
<td>性能高</td>
<td>1. 不宜读 2. 向后兼容有约定限制</td>
</tr>
</tbody></table>
<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>JSON建构于两种结构：</p>
<ul>
<li>“Key/Value”对的集合，在不同语言中，可以作为对象，字典，结构体等</li>
<li>值的有序列表。通常可以理解为数组。</li>
</ul>
<p>以上两种结构在大多数语言中都存在，所以在不同语言中使用JSON进行交流非常自然。</p>
<p>形式：</p>
<ol>
<li>对象是一个无序的’key/value’对集合。一个对象以”{“开始，”}”结束。键值对”key:value”表示。键值对之间使用”,”分隔</li>
<li>值的有序集合：一个数组以”[“开始,”]”结束，值之间使用”,”分隔</li>
<li>值value:可以为string-&gt;”abc”，number-&gt;1,Bool-&gt;true/false,null,对象或数组，同时结构可以嵌套</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>传输数据量较小，且实时性要求比较低的服务</li>
<li>JSON的前后兼容性比较强，对于接口经常变化，对可调性要求高的场景比较适合，比如移动端和服务端通讯</li>
<li>JSON的典型场景： JSON+HTTP</li>
</ol>
<p>JSON的性能和序列化的额外空间开销比较大，对于大数据量服务或持久化来说，会有巨大的开销。同时JSON本身没有使用IDL约束参与方，尽管在大多数语言中它的形式都可以兼容，但是还是会存在问题，需要通过文档方式进行约束，对调试会带来不便。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>protobuf有许多作为优秀的序列化协议的众多优点：</p>
<ol>
<li>使用了标志的IDL</li>
<li>序列化数据紧凑，空间开销小</li>
<li>序列化反序列化速度很快</li>
</ol>
<p>protobuf产生与Google，其支持多种语言，支持的数据类型相对较少，常见与一下rpc框架中使用。</p>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><p>protobuf的空间开销小，加上解析性能高，使用与RPC调用的场景。protobuf提供了标志的IDL，IDL对于各方都有比较强的约束。此外对于应用层对象持久化来说，也比较适合。</p>
<p>缺点在于调试比较麻烦</p>
<h2 id="使用ANTLR设计自己的序列化协议-TODO"><a href="#使用ANTLR设计自己的序列化协议-TODO" class="headerlink" title="使用ANTLR设计自己的序列化协议 TODO"></a>使用ANTLR设计自己的序列化协议 TODO</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/29/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">MySQL - 查询优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-29 17:16:04 / Modified: 18:19:14" itemprop="dateCreated datePublished" datetime="2022-01-29T17:16:04+08:00">2022-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><ol>
<li>确认程序是否在检索大量超过需要的数据</li>
<li>确认Mysql服务器是否在分析大量超过需要的数据行</li>
</ol>
<h3 id="请求了不需要的数据"><a href="#请求了不需要的数据" class="headerlink" title="请求了不需要的数据"></a>请求了不需要的数据</h3><ol>
<li>查询不需要的记录：Mysql总是先返回全部结果集再计算，最好的办法是在查询后面加上LIMIT</li>
<li>多表关联时返回全部列：只取需要的列</li>
<li>使用select *</li>
<li>重复查询相同的数据：使用缓存将数据缓存下来</li>
</ol>
<h3 id="是否在扫描额外的记录"><a href="#是否在扫描额外的记录" class="headerlink" title="是否在扫描额外的记录"></a>是否在扫描额外的记录</h3><p>衡量标准：1. 响应时间 2. 扫描的行数 3. 返回的行数 -&gt; 查询慢日志获得指标 4. 扫描的行数和访问类型 -&gt; 通过EXPLAIN语句中的type列可以获取访问类型。</p>
<p>优化思路：</p>
<ol>
<li>使用索引覆盖扫描</li>
<li>改变库表结构</li>
<li>重写复杂查询，让优化器能够以更优化的方式去执行查询</li>
</ol>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ol>
<li><p>将一个复杂查询分解为多个简单查询</p>
</li>
<li><p>切分查询：将一个重的事务分解为多个小的事务（eg：删除过期数据）</p>
</li>
<li><p>分解关联查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag JOIN tag_post WHERE tag_post.id=tag.id JOIN post ON tag_post.id=post.id </span><br><span class="line">WHERE tag.tag=&#x27;mysql&#x27;</span><br><span class="line"></span><br><span class="line">//将关联查询分解为多个单表查询，然后在业务程序再进行关联</span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456)</span><br></pre></td></tr></table></figure></li>
<li><p>Mysql客户端和服务端的通信协议: 半双工-&gt; 导致Mysql查询，需要所有的数据都接收到以后才能是否查询占用的资源。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">如何实现一个远程调用框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-27 14:45:00 / Modified: 17:09:32" itemprop="dateCreated datePublished" datetime="2022-01-27T14:45:00+08:00">2022-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="如何实现一个远程调用框架"><a href="#如何实现一个远程调用框架" class="headerlink" title="如何实现一个远程调用框架"></a>如何实现一个远程调用框架</h1><p>RPC框架会涉及到的内容，线程模型，通信协议设计，同步/异步调用，负载均衡等。</p>
<h2 id="RPC框架架构设计"><a href="#RPC框架架构设计" class="headerlink" title="RPC框架架构设计"></a>RPC框架架构设计</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gys9sub3prj31940msabj.jpg" alt="Lark20210101-221749.png"></p>
<p>大概有三个部分的组件，1. 客户端 2. 注册中心 3. 服务端</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>使用注册中心来实现服务注册和发现的功能。</p>
<p>服务端节点上线以后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点数据移除。</p>
<p>客户端向服务端发起调用时，自己从注册中心获取到服务端的服务列表，然后通过负载均衡算法选择其中一个服务节点进行调用。</p>
<p><strong>问题</strong>：服务端节点下线时如何移除节点数据，尤其是异常下线的情况。</p>
<p>方式：主动通知+心跳检测</p>
<p>当服务端下线时会主动通知注册节点下线移除数据，同时注册中心会对服务节点进行探活。</p>
<h2 id="通信协议与序列化："><a href="#通信协议与序列化：" class="headerlink" title="通信协议与序列化："></a>通信协议与序列化：</h2><p>因为RPC框架对于性能要求较高，所以通信协议越简单越好。</p>
<p>主流的是TPC,HTTP，gRPC使用的HTTP2。需要稳定可靠的协议。</p>
<p>数据和序列化：如果是一般的框架会选用通用且高效的序列化方式，比如Json,Protocbuf等待，如果是特定场景下使用的话，可以使用特定的序列化方式，这样会更加高效。</p>
<h2 id="RPC的调用方式："><a href="#RPC的调用方式：" class="headerlink" title="RPC的调用方式："></a>RPC的调用方式：</h2><p>一般支持的调用方式：</p>
<ol>
<li>同步Sync：客户端发起RPC调用后，当前线程会一直阻塞，指定服务端返回结果或者超时。</li>
<li>异步Future：客户端发起调用以后不会阻塞等待，而是拿到RPC框架的Future对象，调用结果会被服务端缓存，客户端自行决定何时拿到返回结果，主动获取结果的过程是阻塞等待的。</li>
<li>回调Callback：客户端发起调用时，将Callback对象传递给RPC框架，无需同步等待，直接返回。当获取到服务端响应结果或者超时，再执行用户注册的Callback回调。这种Callback接口一般包含了onResponse和onException两个方法</li>
<li>单向Oneway：客户端发起请求后直接返回，忽略结果</li>
</ol>
<h2 id="线程模型："><a href="#线程模型：" class="headerlink" title="线程模型："></a>线程模型：</h2><p>使用主从Reactor线程模型，其中Boss和Worker线程池可以看做IO线程，IO线程用于处理网络数据，比如事件轮询，编解码，数据传输等。业务逻辑使用业务线程执行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gysaijfmhoj317q0onn2d.jpg" alt="Lark20210101-221822.png"></p>
<h2 id="负载均衡："><a href="#负载均衡：" class="headerlink" title="负载均衡："></a>负载均衡：</h2><p>常见的负载均衡的策略：</p>
<p><strong>Round-Robin 轮询</strong>。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</p>
<p><strong>Weighted Round-Robin 权重轮询</strong>。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</p>
<p><strong>Least Connections 最少连接数</strong>。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</p>
<p><strong>Consistent Hash 一致性 Hash</strong>。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</p>
<h2 id="代理："><a href="#代理：" class="headerlink" title="代理："></a>代理：</h2><p>RPC框架如果要做到像调用本地接口一样调用远端服务，需要创建代理对象，在代理对象中完成数据报文编码，然后发起调用数据给服务方，以此来屏蔽RPC框架的调用细节。可以通过动态代理的方式生成桩类（代理类），gRPC则是通过定义好的DSL，使用DSL来生成桩类和代理方法。</p>
<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc-facade # HelloFacade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-provider # HelloFacadeImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloFacade.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFacadeImpl</span> <span class="keyword">implements</span> <span class="title">HelloFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc-consumer # HelloController</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务方"><a href="#服务方" class="headerlink" title="服务方"></a>服务方</h3><ol>
<li>服务提供者启动服务，并暴露服务端口；</li>
<li>启动时扫描需要对外发布的服务，并将服务元数据信息发布到注册中心；</li>
<li>接收 RPC 请求，解码后得到请求消息；</li>
<li>提交请求至自定义线程池进行处理，并将处理结果写回客户端。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/24/%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">基于线程和事件驱动的响应模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-24 20:33:09 / Modified: 21:02:52" itemprop="dateCreated datePublished" datetime="2022-01-24T20:33:09+08:00">2022-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Reactor-Pattern"><a href="#Reactor-Pattern" class="headerlink" title="Reactor Pattern"></a>Reactor Pattern</h1><p>Reactor pattern的理念:</p>
<ol>
<li>连接和线程总是存在一对一的关系。Unfortunately, there is always a one-to-one relationship between connections and threads</li>
<li>事件驱动的方法可以将线程与连接分开，它只对特定回调/处理程序的事件使用线程。Event-driven approach can separate threads from connections, which only uses threads for events on specific callbacks/handlers.</li>
<li>一个事件驱动的架构由事件的创建者和事件的消费者组成。创建者，也就是事件的源头，只知道事件发生了。消费者是需要知道事件已经发生的实体。消费者可能参与到事件处理中去，也可能只是受到事件的影响。An event-driven architecture consists of event creators and event consumers. The creator, which is the source of the event, only knows that the event has occurred. Consumers are entities that need to know the event has occurred. They may be involved in processing the event or they may simply be affected by the event.</li>
<li>反应器模式时事件驱动架构的一种实现，简单来说，它是由一个单线程的事件循环对发出事件的资源进行了阻塞并且将其分配给对应的处理程序或者回调。The reactor pattern is one implementation technique of the event-driven architecture. <strong>In simple words, it uses a single threaded event loop blocking on resources emitting events and dispatches them to corresponding handlers/callbacks.</strong></li>
<li>只有注册了处理程序和回调，就没必要阻塞IO了。事件就行传入的一个新的连接，已经可以读，可以写了<strong>There is no need to block on I/O, as long as handlers/callbacks for events are registered to take care of them.</strong> Events are like incoming a new connection, ready for read, ready for write, etc.</li>
<li>This pattern decouples modular application-level code from reusable reactor implementation.这种模式可以解耦模块化的应用级代码和可重复使用的反应器实现。</li>
<li>The purpose of the Reactor design pattern is to avoid the common problem of creating a thread for each message/request/connection.Avoid this problem is to avoid the famous and known problem C10K.反应器模式的目的是为了避免为每个消息/请求/连接创建一个线程的问题。也是为了解决C10K问题。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/18/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">MySQL高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-18 02:01:29" itemprop="dateCreated datePublished" datetime="2022-01-18T02:01:29+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-28 17:46:56" itemprop="dateModified" datetime="2022-01-28T17:46:56+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL高可用"><a href="#MySQL高可用" class="headerlink" title="MySQL高可用"></a>MySQL高可用</h1><h2 id="主备一致是如何保证的"><a href="#主备一致是如何保证的" class="headerlink" title="主备一致是如何保证的"></a>主备一致是如何保证的</h2><p>主库同步到从库的过程：</p>
<ol>
<li>主库接收到写请求以后，执行内部事务的更新逻辑，同时写binlog</li>
<li>从库和主库直接维持了一个长连接，主库A内部有一个线程，专门用于服务备库B的长连接。</li>
<li>事务日志同步：从库和主库建立好长连接后，会收到主库的binlog，存储到本地为relaylog，会有一个线程读取relaylog，解析日志里的sql命令，然后执行</li>
</ol>
<p>binlog的三种格式：</p>
<ol>
<li><p>statement</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf1oqf7jj31ga05xdhk.jpg" alt="img"></p>
<p>statement格式存储的是原始的SQL语句。</p>
<p>存在的问题：主库和从库执行同一条sql语句，可能存在结果不一致的情况。</p>
</li>
<li><p>row</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytf2ifijgj31hc0et411.jpg" alt="img"></p>
<p>row格式里存储的是: Table_map, Delete_rows，row格式记录了真实删除行的主键id，也就是主库和备库最终结果是一致的</p>
</li>
<li><p>mixed</p>
<p>mixed是以上两种混合使用的结果</p>
<p>statement格式的binlog可能会造成主备不一致</p>
<p>row格式的话，会很占用空间 - 比如delete删除10万行，row格式要记录10w个记录，statement只记录一句sql</p>
<p>Mixed: 主动判断SQL语句是否可能造成主备不一致，可能就用row，否则stament</p>
</li>
<li><p>实践：设置为mixed，如果需要恢复数据的场景，则设置为row</p>
</li>
</ol>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytgdcxmwcj31hc0ig0y2.jpg" alt="img"></p>
<p>row格式中记录的信息中，bin_row_image的默认设置会存储行的所有字段的值，上面设置为只记录必要信息，只有id=4这个信息</p>
<p>所以在row格式中，可以记录所有的行的信息。</p>
<ol>
<li>delete：执行的delete语句，在row格式的binlog中，被删除的每一行的信息都会保存，既可以将删除的数据insert回去。</li>
<li>insert: insert语句，row格式的binlog会记录所有字段信息，可以用于定义刚刚插入的一行，使用delete删除即可</li>
<li>update: update语句，row格式的binlog会记录修改前的整行数据和修改后的整行数据，只需要对调前后，执行update即可</li>
</ol>
<h2 id="双主结构和循环复制"><a href="#双主结构和循环复制" class="headerlink" title="双主结构和循环复制"></a>双主结构和循环复制</h2><p>当两个库都作为主库时，会有2个长连接来保持相互同步，但是如何保证不会循环复制。这里使用serverid来做区分。</p>
<h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>数据同步的节点：</p>
<ol>
<li>主库A执行完成一个事务，写入binlog T1</li>
<li>binlog传给备库B，备库接收完这个binlog T2</li>
<li>备库B执行完成事务 T3</li>
</ol>
<p>主备延迟 = T3 - T1</p>
<p>T2 - T1 = 网络传输的时间，比较短</p>
<p>T3 - T2 = 接收完binlog并执行事务的时间（长）</p>
<p>主备延迟 约等于 T3-T2 接收完binlog，执行relaylog的速度差</p>
<p><strong>主备延迟的来源</strong>：</p>
<ol>
<li>主库机器被备库好</li>
<li>备库压力大</li>
<li>大事务 - 因为主库必须等事务执行完以后才会写入binlog，如果大事务执行时间为t1则延迟为t1</li>
<li>备库的并行复制</li>
</ol>
<h3 id="针对主备延迟带来的主备切换策略："><a href="#针对主备延迟带来的主备切换策略：" class="headerlink" title="针对主备延迟带来的主备切换策略："></a>针对主备延迟带来的主备切换策略：</h3><ol>
<li>可靠性优先策略：</li>
<li>可用性优先策略：</li>
</ol>
<h3 id="小时级的主备延迟-备库并行复制"><a href="#小时级的主备延迟-备库并行复制" class="headerlink" title="小时级的主备延迟 - 备库并行复制"></a>小时级的主备延迟 - 备库并行复制</h3><p>在备库执行日志的速度持续低于主库生成日志的速度情况下，主备延迟有可能变成小时级别。</p>
<p>为什么要多线程并行复制 - 客户端事务是可以并发的，如果备库处理relaylog是单线程的，则会导致备库执行日志速度持续低于主库生成日志，造成较长时间的主备延迟。</p>
<p>协调器 - 多工作线程的模式（同时需要保证 不能更新覆盖，不能拆同一个事务）</p>
<h3 id="一主多从的结构"><a href="#一主多从的结构" class="headerlink" title="一主多从的结构"></a>一主多从的结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gytifl1yznj30vq0ns0u1.jpg" alt="img"></p>
<p>具体结构：A与A1是互为主从，B，C，D是执行A的从库，主库为WR，从库为readonly</p>
<ol>
<li><p>主库故障后的主从切换：</p>
<p>当A出错后，A1会作为新的主库，对于从库B来说需要执行change master命令，需要建立到新主库的连接并且将日志位点对齐新主库</p>
<p><strong>重点问题：日志位点很难对齐</strong></p>
<p>对于相同的日志，A和A1的位点是不同的，所以从库首先需要对齐位点</p>
<p>通用的做法是使用GTID来对齐位点：</p>
<p>GTID(Global Transaction Identifier) 是全局事务ID，是一个事务在提交时生成的</p>
<p>在开启了GTID以后，日志位点就可以自动对齐了</p>
<p><strong>流程：</strong></p>
<ol>
<li>从库B指定主库A1，基于主备协议建立连接</li>
<li>从库B把自己的GTID集合set_b发给新主库A1</li>
<li>主库A1把set_b和自己的GTID集合set_a比较，获取差集，然后看自己是否包含所有的差集</li>
<li>主库A1在binlog中找到第一个差集中的事务，然后向后顺序取binlog给B</li>
</ol>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/13/Redis%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">Redis小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-13 17:59:13" itemprop="dateCreated datePublished" datetime="2022-01-13T17:59:13+08:00">2022-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-13 00:34:32" itemprop="dateModified" datetime="2022-02-13T00:34:32+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis学习小结"><a href="#Redis学习小结" class="headerlink" title="Redis学习小结"></a>Redis学习小结</h1><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7med1wej30uy0u0djk.jpg" alt="screenshot-20220113-181317" style="zoom:150%;" />

<h2 id="Redis的设计与实现"><a href="#Redis的设计与实现" class="headerlink" title="Redis的设计与实现"></a>Redis的设计与实现</h2><p>核心点：</p>
<ol>
<li><p>Redis的五种数据类型是由什么数据结构实现？</p>
<p>String-&gt; 动态字符串</p>
<p>List-&gt;  压缩链表，双向链表</p>
<p>Hash-&gt; 压缩链表，hash表</p>
<p>Set-&gt;set</p>
<p>sortedSet-&gt;压缩链表，跳表</p>
</li>
<li><p>Redis的字符串类型即可以存储字符串，又可以存储整数和浮点数，甚至二进制位，Redis内部如何存储这些不同的值？</p>
<p>针对不同场景，为同一类型设置不同的数据结构实现。</p>
<p>比如字符串，数字时存为INT，长度小的时候为编码的简单字符串，长的时候就是简单动态字符串</p>
</li>
<li><p>Redis 的一部分命令只能对特定数据类型执行（比如 APPEND 只能对字符串执行， HSET 只能对哈希表执行）， 而另一部分命令却可以对所有数据类型执行（比如 DEL 、 TYPE 和 EXPIRE ）， 不同的命令在执行时是如何进行类型检查的？ Redis 在内部是否实现了一个类型系统？</p>
<p>是的Redis内部实现了一套类型系统</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb70oiqptj30se0ks0ue.jpg" alt="img"></p>
</li>
<li><p>Redis 的数据库是怎样储存各种不同数据类型的键值对的？ 数据库里面的过期键又是怎样实现自动删除的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gzb6ys3r6mj30sf0fvmyj.jpg" alt="img"></p>
</li>
<li><p>Redis 还拥有发布与订阅、脚本、事务等特性， 这些特性又是如何实现的？</p>
</li>
<li><p>怎么处理客户端的命令请求？</p>
<p>使用RESP协议（自定义的）进行通信</p>
</li>
</ol>
<p>整体结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc81jn065j31hb0u0wj0.jpg" alt="img"></p>
<h2 id="K-V如何组织"><a href="#K-V如何组织" class="headerlink" title="K-V如何组织"></a>K-V如何组织</h2><p>使用的是Hash表的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8wiczbwj30lf08zgm8.jpg" alt="img"></p>
<p>问题：</p>
<ol>
<li><p>Hash冲突？ -&gt;链式解决</p>
</li>
<li><p>Rehash(分配更大的空间，减少冲突): </p>
<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 为了避免copy 过程阻塞用户请求，Redis 采用了渐进式 rehash，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，<strong>顺带着</strong>将这个索引位置上的所有 entries 拷贝到哈希表 2 中。PS：跟redis 通过用户请求顺带清理 过期数据是一样的。</li>
<li>释放哈希表 1 的空间。</li>
</ol>
</li>
<li><p>RedisObject: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount;   <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;  <span class="comment">// 指向实际值的指针，可以指向不同的数据类型</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>由于Redis的数据类型很多，所以是用了一个RedisObject来做封装</p>
</li>
</ol>
<h2 id="K-V底层数据结构"><a href="#K-V底层数据结构" class="headerlink" title="K-V底层数据结构"></a>K-V底层数据结构</h2><p>Key只能为string类型，value可以为复杂类型</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc8tm64v5j32t00u0jyx.jpg" alt="img"></p>
<p>压缩列表：</p>
<p>由于压缩列表节约内存，所以hash,list,sortedSet的底层实现在数据量小的时候都采用压缩列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">            +---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                         ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>图中各个域的作用如下：</p>
<table>
<thead>
<tr>
<th align="left">域</th>
<th align="left">长度/类型</th>
<th align="left">域的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left">到达 ziplist 表尾节点的偏移量。 通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left">ziplist 中节点的数量。 当这个值小于 <code>UINT16_MAX</code> （<code>65535</code>）时，这个值就是 ziplist 中节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left"><code>?</code></td>
<td align="left">ziplist 所保存的节点，各个节点的长度根据内容而定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>255</code> 的二进制值 <code>1111 1111</code> （<code>UINT8_MAX</code>） ，用于标记 ziplist 的末端。</td>
</tr>
</tbody></table>
<p>Entry的构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">            +------------------+----------+--------+---------+</span><br><span class="line">component   | pre_entry_length | encoding | length | content |</span><br><span class="line">            +------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p>Redis客户端与服务端使用了RESP(Redis Serialization Protocol)的二进制安全文本协议进行通信，通过TCP连接实现数据交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure>

<p>对于特定场景，使用自定义的通信协议，性能会好于通用的通信协议</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    redisDb *db;    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;      <span class="comment">// 服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *dict;     <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *expires;  <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7x6r5umj30sf0fvmyj.jpg" alt="img"></p>
<h2 id="单线程的原因"><a href="#单线程的原因" class="headerlink" title="单线程的原因"></a>单线程的原因</h2><ol>
<li>只是对读写使用了单线程，底层使用了IO多路复用机制</li>
<li>单线程使用简单，并且这里主要的瓶颈不是单线程而是共享资源</li>
</ol>
<h2 id="持久化（单机高可用）"><a href="#持久化（单机高可用）" class="headerlink" title="持久化（单机高可用）"></a>持久化（单机高可用）</h2><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyc7lzkw1yj31fn0u0wju.jpg" alt="screenshot-20220113-181342" style="zoom:150%;" />

<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h3><p>MySQL使用的是写前日志（WAL）。但是AOF日志是写后日志，需要Redis先执行命令，写入内存后，再记录日志。</p>
<p>优点：记录每一条命令但是不需要检查语法。AOF也不会阻塞当前命令</p>
<p>缺点：存在执行完命令没有记录日志丢失数据的风险。AOF会阻塞下一个命令执行，如果后续磁盘写压力大会导致变慢。</p>
<p>解决问题：</p>
<ol>
<li><p>丢失数据风险：提供三种配置, Always(同步写回)，EverySec(每秒写回),NO(只写到内存，有操作系统写入磁盘)</p>
</li>
<li><p>日志文件变大：使用AOF重写机制</p>
<p>AOF重写机制：</p>
<ol>
<li>执行重写是，主线程fork一个子线程，内存会拷贝一份，如何对同一键值对的反复修改的命令只保留其值即可。主线程未阻塞，仍然可以处理新来的操作。如果有写操作，除了正在写的AOF 日志，还会再写一份AOF 重写日志。等到bgrewriteaof 拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，此时，就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycbr21z07j31s40u0436.jpg" alt="img"></p>
<h3 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h3><p>记录某一时刻的内存中的数据，以文件的形式写到磁盘。即快照。</p>
<p>提供了两个命令生成RDB：</p>
<ol>
<li>Save: 主线程执行，会阻塞</li>
<li>Bgsave: 创建一个子进程，专门写入RDB文件，避免了主线程的阻塞，但是这样做确需要暂停写操作，可以使用Copy-On-Write，即会复制一份值用于写。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyccaxy4m4j31hc0u0ad2.jpg" alt="img"></p>
<p>快照频率使用上，频率搞了消耗大，低了数据容易丢</p>
<p>更好的应用场景：快照不频繁使用，AOF记录两次快照之间的操作。</p>
<p>因为RDB和AOF都会使用fork，<strong>fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长</strong>（所以使用RDB时，单个实例的redis 内存不宜过大）</p>
<p>同时，Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到 swap 的影响，而导致性能变慢。</p>
<h2 id="主从同步（多机高可用）"><a href="#主从同步（多机高可用）" class="headerlink" title="主从同步（多机高可用）"></a>主从同步（多机高可用）</h2><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjk9u4c0j31nk0q4gru.jpg" alt="screenshot-20220114-010708"></p>
<p>Redis提供了主从库模式，主从库同步是如何完成的呢？</p>
<ol>
<li><p>第一次同步：启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，然后使用RDB进行数据同步</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjmznewtj31ve0u0q8l.jpg" alt="img"></p>
</li>
<li><p>主从级联模式：从库很多，如果都要和主库进行全量复制，就会导致主库压力大，通过“主-从-从”的模式就可以解决</p>
</li>
<li><p>主从库端口：通过增量复制的方式继续同步。主从库断连后，主库会将写操作持续写入一个buffer（注：环状）</p>
</li>
</ol>
<p>主库挂了怎么办？</p>
<p>通过哨兵机制解决：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjsvqhk5j31qs0me78h.jpg" alt="screenshot-20220114-011539"></p>
<p>哨兵是一个特殊模式下的Redis进程，主要用于：监控，选主，通知</p>
<ol>
<li>监控。周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>选主。筛选+打分，在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉（在线状态、断连次数）。然后，我们再按照一定的规则，给剩下的从库逐个打分（从库优先级、从库复制进度= master_repl_offset-slave_repl_offset 以及从库 ID 号），将得分最高的从库选为新主库。</li>
<li>通知。哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</li>
</ol>
<p>单哨兵也可能会出问题，所以可以使用哨兵集群：</p>
<h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gycjydb0w0j31ho0u00yi.jpg" alt="screenshot-20220114-012052"></p>
<p>当数据量变大以后，就需要扩展，如果只是单纯的扩大单个Redis的内存，会导致fork时间变长，Redis性能变差。此时需要纵向扩展。通过切片集群解决，这里即对一个K-V,先通过K找到需要保存到那个redis示例，在通过K找到在redis的hash表的存放位置。对于第一步来说，还需要考虑负载均衡的问题。</p>
<p>实际：Redis Cluster是通过Hash Slot实现的，一个环状的hash槽（16384个），通过hash算法（hash(key)%N）找到slot位置。在部署时，Redis会自动将这些槽平均到集群实例上。</p>
<p>如何知道哈希槽分布在哪个实例上？Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>当出现增删节点和负载均衡情况等变化的情况，通过重定向机制处理，即原本的实例存放了变更的位置，会通过重定向将请求发给变更的位置</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区是Redis中用于，当客户端和服务端进行通信时，暂存客户端命令或服务端结果的。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckdibgooj31880u0adf.jpg" alt="img"></p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ol>
<li>对于缓存来说，淘汰策略很重要，通过时间局部性和空间局部性来保证缓存的作用</li>
<li>单范围淘汰，即对设置了过期时间的数据进行淘汰</li>
<li>全范围淘汰，按照淘汰算法对所有数据进行</li>
</ol>
<p>LRU（Redis）实现：在RedisObject中有个lru字段，保存一个数据访问的时间戳，因为数据量很大，Redis也只是抽取一定数量的数据，然后对齐按照lru的大小进行淘汰</p>
<p>LFU（Redis）实现:  也是使用RedisObject中lru字段，总共24bit，拆为16bit（时间戳）,counter(8bit)访问值（最大255）。Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。这样可以保证访问次数很大也可以进行比较，但是这样本身存在一定误差，数据量大的时候其counter值才置信。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyckrc17jwj318m0hawhk.jpg" alt="screenshot-20220114-014847"></p>
<p>Redis的事务，一致性和隔离性可以保证，持久性和原子性不行。</p>
<h2 id="缓存异常问题"><a href="#缓存异常问题" class="headerlink" title="缓存异常问题"></a>缓存异常问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>问题：应用请求无法在Redis处理，大量的被传导到数据库了</p>
<ol>
<li>大量数据同时到期 -&gt; a. 微调时间，给业务数据加上一个小的随机数 b. 服务降级，只保证核心内容服务</li>
<li>Redis实例宕机导致 -&gt; a.进行服务熔断和请求限流 b. 建立高可靠的集群</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>问题：对于某个热点数据的访问很频繁，但是此时该数据刚好过期，导致大量请求到了数据库。</p>
<p>解决办法：对于热点数据，不设置过期时间</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>问题：要访问的数据即不在Redis缓存也不在数据库，通常由于业务层误操作或者恶意攻击导致</p>
<p>解决办法：</p>
<ol>
<li>缓存空值</li>
<li>使用Bloom Filer（一个初值全为0的数组和N个hash函数组成，对于某个值，如果存在，则使用N个hash将它的位置置为1）快速判断数据是否存在。（存在一定通过Bloom Filter，不存在大部分通不过Bloom Filter）</li>
<li>对请求进行合法校验，避免恶意请求</li>
</ol>
<h3 id="缓存与数据库数据不一致问题"><a href="#缓存与数据库数据不一致问题" class="headerlink" title="缓存与数据库数据不一致问题"></a>缓存与数据库数据不一致问题</h3><p>核心：需要保证缓存中有数据，缓存的数据必须和数据库中相同。没有数据，则数据库中必须为最新值。</p>
<p>解决办法：</p>
<p>读写缓存：同步写回</p>
<p>只读缓存：</p>
<ol>
<li>先删缓存再更新数据库：无并发，重试机制（使用消息队列保证操作成功） 并发：延迟双删（先删除缓存，再更新数据库，休眠一秒，再次删除缓存）</li>
<li>先更新数据库再删缓存（更好）：无并发，重试机制   并发：在客户端暂存并发请求</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/MySQL%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">MySQL事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-11 16:44:02" itemprop="dateCreated datePublished" datetime="2022-01-11T16:44:02+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-14 11:03:51" itemprop="dateModified" datetime="2022-01-14T11:03:51+08:00">2022-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/zhongsongzhi97.github.io/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><p>在业务实现时，通常需要保证一批SQL同时具备ACID特性。</p>
<p>ACID:</p>
<ol>
<li>原子性（Atomicity）：事务内SQL要么同时成功要么同时失败 ，基于UndoLog实现。</li>
<li>一致性（Consistency）：系统从一个正确态转移到另一个正确态，由应用通过AID来保证，并非数据库的责任。</li>
<li>隔离性（Isolation）：控制事务并发执行时数据的可见性，当多个应用并发访问数据库系统时，提供了一种隔离方法，防止彼此的操作相互干扰，基于锁和MVCC实现。</li>
<li>持久性（Durability）：提交后一定存储成功不会丢失，基于RedoLog实现。</li>
</ol>
<h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p><img src="/Users/bytedance/Documents/screenshot-20220111-180509.png" alt="screenshot-20220111-180509"></p>
<p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。</p>
<p>实现<strong>原子性</strong>：通过日志将所有对数据的更新操作都写入日志。如果事务一部分操作已完成又无法全部完成，则通过undolog将执行成功的操作撤销</p>
<p>实现<strong>持久性</strong>：在事务提交之前，redo log已经持久化了，对于已经执行成功未写入磁盘的操作，会通过redo log写入磁盘</p>
<p>最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重新执行所有已经执行成功，但尚未写入到磁盘的操作，保证持久性），再对所有崩溃时尚未成功提交的事务进行进行undo（撤销所有执行一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<p>Todo:</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/2G_2ZYAbQIblVJY7pmrhKg">Redo Log</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/427911093">Undo Log</a></p>
<h2 id="锁与MVCC"><a href="#锁与MVCC" class="headerlink" title="锁与MVCC"></a>锁与MVCC</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9w6wgo1vj313a0gwdik.jpg" alt="screenshot-20220111-180737"></p>
<p>隔离性: 数据库允许多个并发事务同时对数据进⾏读写和修改的能⼒，且互相不影响，看起来像串⾏执⾏⼀样， 并不会出现由于事务交叉执⾏⽽导致的数据不⼀致</p>
<p>如何判断一个事务调度是正确的：⼀个并发事务的调度执⾏结果能和多种串⾏执⾏的其中⼀个结果相等，我们认为这是⼀个正确的调度， 称之为serializable schedule</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybvcdykimj31t40p8dlc.jpg" alt="screenshot-20220113-110918"></p>
<p>应该满足A+B = 2120</p>
<p>隔离级别：</p>
<p><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</p>
<p><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read 不可重复读是读取了其他事务更改的数据，<strong>针对update操作</strong>）；</p>
<p><code>REPEATABLE READ</code>：加记录锁和间隙锁。多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（读取了其他事务新增的数据，<strong>针对insert和delete操作</strong>）；</p>
<p><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</p>
<p>并发产⽣的异象，本质上是出现了冲突：</p>
<ul>
<li>W-W冲突：两个事务先后修改了同⼀个数据库的相同object </li>
<li> W-R冲突：⼀个事务T1修改某个object后(未提交)，另⼀个事务T2对改object进⾏了读操作 </li>
<li> R-W冲突：⼀个事务T1读取了某个object或者某个range后，另⼀个事务T2对object或者range进⾏了修改</li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybw8bsdt3j31gs0i475x.jpg" alt="screenshot-20220113-113925"></p>
<ol>
<li><p>2PL - 读写锁</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwb7pt63j30k60riq50.jpg" alt="screenshot-20220113-114256" style="zoom: 50%;" />

<p>可能发生死锁。需要进行死锁检测或死锁预防</p>
</li>
<li><p>T/O - T/O的核⼼思想就是利⽤时间戳来决定事务之间的等价执⾏顺序：如果TS(Ti) &lt; TS(Tj)，那么数据库必须保证实际的 schedule先执⾏Ti，后执⾏Tj的结果等价。</p>
</li>
<li><p>OCC - todo</p>
</li>
<li><p>MV2PL:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybwip4vkwj31rc0u045v.jpg" alt="screenshot-20220113-114917"></p>
</li>
<li><p>MVTO - todo</p>
</li>
<li><p>MVOCC - todo</p>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>为了提⾼数据库的并发性能，⼈们提出了MVCC(Multi-Version Concurrency Control)来实现读写互不阻塞，从⽽提⾼数据 库的并发性能</p>
<p>MySQL实现的是多版本的两阶段锁协议(Multiversion 2PL)将MVCC和2PL结合。每一个版本的数据行都有一个唯一的时间戳。</p>
<p>读事务：从多个（可见（时间戳早于当前事务））版本的数据项中返回具有最大时间戳的</p>
<p>更新操作：读取最新版本（可见）的数据计算更新的结果，然后创建一个新版本的数据，新数据的时间戳为当前数据行的最大版本+1</p>
<p>删除操作：MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">锁与MVCC</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/11/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">系统监控</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-11 00:26:10 / Modified: 00:35:15" itemprop="dateCreated datePublished" datetime="2022-01-11T00:26:10+08:00">2022-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go系统监控的设计和实现原理"><a href="#Go系统监控的设计和实现原理" class="headerlink" title="Go系统监控的设计和实现原理"></a>Go系统监控的设计和实现原理</h1><p>守护进程：后台运行的计算机程序，有操作系统启动，会在整个系统的生命周期存在，随着系统的启动而启动，系统的结束而结束。</p>
<p>Go的系统监控，会在内部启动一个不会中止的循环，循环内部进行网络轮询，抢占长期运行或者处于系统调用的Goroutine以及触发垃圾回收</p>
<h2 id="监控循环"><a href="#监控循环" class="headerlink" title="监控循环"></a>监控循环</h2><p>启动时机：main函数进入时会通过系统调用创建一个新线程并启动系统监控（sysmon）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead() <span class="comment">//检查是否存在死锁</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//监控循环</span></span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123;</span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123;</span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123;</span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay) <span class="comment">//挂起当前线程</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序稳定后，系统监控会每10ms触发一次，完成如下工作:</p>
<ul>
<li><p>运行计时器 — 获取下一个需要被触发的计时器；</p>
</li>
<li><p>轮询网络 — 获取需要处理的到期文件描述符；</p>
</li>
<li><p>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</p>
</li>
<li><p>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</p>
</li>
</ul>
<h3 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h3><h3 id="轮询网络"><a href="#轮询网络" class="headerlink" title="轮询网络"></a>轮询网络</h3><h3 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/10/%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/" class="post-title-link" itemprop="url">网络轮询器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-01-10 00:37:38 / Modified: 02:30:20" itemprop="dateCreated datePublished" datetime="2022-01-10T00:37:38+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO与网络轮询器"><a href="#IO与网络轮询器" class="headerlink" title="IO与网络轮询器"></a>IO与网络轮询器</h1><p>如今的大部分服务都是I/O密集型的，应用会花费大量的时间等待I/O操作完成。Go使用了网络轮询器用于处理I/O操作，底层使用了操作系统的多路复用机制epoll</p>
<p>通常的IO多路模型是通过回调机制进行控制的，Go的话将其隐藏在了runtime中了，Go开发者无需关注socket是否是 non-block的，也无需亲自注册文件描述符的回调，只需在每个连接对应的goroutine中以“block I/O”的方式对待socket处理即可。</p>
<h2 id="原理和前言"><a href="#原理和前言" class="headerlink" title="原理和前言"></a>原理和前言</h2><p>作用：监控网络I/O，文件I/O</p>
<p>I/O模型“</p>
<h3 id="阻塞I-O模型："><a href="#阻塞I-O模型：" class="headerlink" title="阻塞I/O模型："></a>阻塞I/O模型：</h3><h3 id="非阻塞I-O模型："><a href="#非阻塞I-O模型：" class="headerlink" title="非阻塞I/O模型："></a>非阻塞I/O模型：</h3><h3 id="I-O多路复用："><a href="#I-O多路复用：" class="headerlink" title="I/O多路复用："></a>I/O多路复用：</h3><h2 id="网络轮询器："><a href="#网络轮询器：" class="headerlink" title="网络轮询器："></a>网络轮询器：</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/#662-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">网络轮询器</a></p>
<ol>
<li>多路复用依赖于epoll 机制</li>
<li>epoll 机制包含两个fd:epfd 和 待读写数据的fd（比如socket）。先创建efpd，然后向epfd 注册fd事件， 之后触发epoll_wait 轮询注册在epfd 的fd 事件发生了没有。</li>
<li>netpoller 负责将 操作系统 提供的nio 转换为 goroutine 支持的blocking io。为屏蔽linux、windows 等底层nio 接口的差异，netpoller 定义一个虚拟接口来封装底层接口。</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span> //单例，初始化轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span> //监听<span class="title">FD</span>的事件，创建事件并加入监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="keyword">int64</span>)</span> <span class="title">gList</span> //轮询网络并返回一组已经准备就绪的<span class="title">Goroutine</span> &lt;0 无限期等待 =0 非阻塞轮询 &gt;0 阻塞特定时间轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span> //中断轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">bool</span> //判断<span class="title">FD</span>是否被轮询器使用</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7xf9y6qzj30xj08caae.jpg" alt="poll-desc-list"></p>
<p>pollCache是一个运行时包的全局变量，包含一个互斥锁和一个链表（pollDesc链表),pollDesc是对fd的封装</p>
<p>初始化和释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">alloc</span><span class="params">()</span> *<span class="title">pollDesc</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123; <span class="comment">//初次初始化时，会进行批量初始化以增加吞吐量</span></span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			pd.link = c.first</span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pd := c.first <span class="comment">//返回的是链表头的没有使用过的pollDesc</span></span><br><span class="line">	c.first = pd.link</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经用过的pollDesc会在运行时调用free释放</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">free</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	pd.link = c.first <span class="comment">//释放时将其出队</span></span><br><span class="line">	c.first = pd</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="网络轮询器的初始化"><a href="#网络轮询器的初始化" class="headerlink" title="网络轮询器的初始化"></a>网络轮询器的初始化</h4><p>调用 <code>internal/poll.pollDesc.init</code> 初始化文件描述符时不止会初始化网络轮询器，会通过 <code>runtime.poll_runtime_pollOpen</code> 函数重置轮询信息 <code>runtime.pollDesc</code> 并调用 <code>runtime.netpollopen</code> 初始化轮询事件。<code>runtime.netpollopen</code> 会调用 epollctl 向全局的轮询文件描述符 epfd 中加入新的轮询事件监听文件描述符的可读和可写状态</p>
<h4 id="如何向网络轮询器加入待监控的任务"><a href="#如何向网络轮询器加入待监控的任务" class="headerlink" title="如何向网络轮询器加入待监控的任务"></a>如何向网络轮询器加入待监控的任务</h4><h4 id="如何从网络轮询器获取触发的事件"><a href="#如何从网络轮询器获取触发的事件" class="headerlink" title="如何从网络轮询器获取触发的事件"></a>如何从网络轮询器获取触发的事件</h4><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ol>
<li><p>等待事件：在fd执行读写操作，如果fd不可读或者不可写，当前Goroutine会执行pollWait让出线程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	gpp := &amp;pd.rg <span class="comment">//检查pollDesc状态</span></span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123; </span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>) <span class="comment">//让出当前线程，Goroutine转换到休眠状态并等待运行时唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>轮询等待</p>
<p>Go的runtime会在调度或系统监控中调用netpoll轮询网络</p>
<p>步骤：</p>
<ul>
<li>根据传入的delay计算epoll系统调用需要等待的时间</li>
<li>调用epollwait等待可读或可写事件</li>
<li>在循环中依次处理epollevent事件</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms) <span class="comment">//等待fd可读或可写</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123; <span class="comment">//epoll返回负值，返回空gList或者重试</span></span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//如果大于0，则在循环中处理事件</span></span><br><span class="line"><span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">    <span class="comment">//netpollBreak的事件，中断网络轮询器</span></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常的读写事件，通过netpollready进行处理</span></span><br><span class="line">		<span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.everr = <span class="literal">false</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rg, wg *g</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">		wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>) <span class="comment">//将pd中的读写信号转换为pdReady，并返回pd的Goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		toRun.push(wg) <span class="comment">//加入待执行列表，Goroutine列表会被加入到处理器或者全局运行队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="截止日期"><a href="#截止日期" class="headerlink" title="截止日期"></a>截止日期</h4><p>计时器依赖于网络轮询器唤醒，文件和网络I/O的截止日期也由其负责处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于设置截止日期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="keyword">int64</span>, mode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rd0, wd0 := pd.rd, pd.wd</span><br><span class="line">	<span class="keyword">if</span> d &gt; <span class="number">0</span> &#123;</span><br><span class="line">		d += nanotime()</span><br><span class="line">	&#125;</span><br><span class="line">	pd.rd = d <span class="comment">//先使用截止日期计算过期的时间点</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> pd.rt.f == <span class="literal">nil</span> &#123; <span class="comment">//如果没有设置执行的函数</span></span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123;</span><br><span class="line">			pd.rt.f = netpollReadDeadline  <span class="comment">//设置计时器到期执行的函数</span></span><br><span class="line">			pd.rt.arg = pd</span><br><span class="line">			pd.rt.seq = pd.rseq</span><br><span class="line">			resettimer(&amp;pd.rt, pd.rd) <span class="comment">//重置计时器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.rd != rd0 &#123; <span class="comment">//如果截止日期已改变</span></span><br><span class="line">		pd.rseq++</span><br><span class="line">		<span class="keyword">if</span> pd.rd &gt; <span class="number">0</span> &#123; <span class="comment">//新截止日期 &gt; 0 ，修改计时器</span></span><br><span class="line">			modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//新日期 &lt; 0 ，删除计时器, 并会在后面直接唤醒对应的Goroutine</span></span><br><span class="line">			deltimer(&amp;pd.rt)</span><br><span class="line">			pd.rt.f = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行时会在计时器到期时调用netpolldeadlineimpl,直接使用netpollgoready唤醒对应的Goroutine，Goroutine被唤醒后，会意识到当前I/O操作已经超时，选择重试或者终止调用</p>
<h2 id="IO前后的GPM"><a href="#IO前后的GPM" class="headerlink" title="IO前后的GPM"></a>IO前后的GPM</h2><ol>
<li>G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zf09e2xj30h508vmxk.jpg" alt="img"></p>
<ol start="2">
<li><p>G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zgho21oj313f0krmyp.jpg" alt="img"></p>
</li>
<li><p>异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环/eventloop。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7zh0rzj3j30if09kt94.jpg" alt="img"></p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>网络轮询器并不是一个独立运行的，调度器和系统调用都会通过netpoll与网络循环器交换信息，获取待执行的GoRoutine列表，并将待执行的Goroutine加入运行队列等待处理</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/07/%E6%89%8B%E6%92%B8DSL%E5%92%8CgRPC%E8%A7%A3%E6%9E%90-proto%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/07/%E6%89%8B%E6%92%B8DSL%E5%92%8CgRPC%E8%A7%A3%E6%9E%90-proto%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">手撸DSL和gRPC解析.proto分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-07 11:27:36" itemprop="dateCreated datePublished" datetime="2022-01-07T11:27:36+08:00">2022-01-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-10 15:05:14" itemprop="dateModified" datetime="2022-01-10T15:05:14+08:00">2022-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DSL和gRPC-protoc-gen-go"><a href="#DSL和gRPC-protoc-gen-go" class="headerlink" title="DSL和gRPC protoc-gen-go"></a>DSL和gRPC protoc-gen-go</h1><h2 id="DSL介绍"><a href="#DSL介绍" class="headerlink" title="DSL介绍"></a>DSL介绍</h2><p>定义：DSL(Domain Specific Language)为领域特定语言，GPL(General Purpose Language)通用编程语言(图灵完备)，比如C，C++，Python，C#等</p>
<p>常见的DSL：1. Regex,HTML,CSS,CocoaPods,Grandle,SQL</p>
<p>Regex: 正则表达式，指定了字符串的模型，会判断当前字符串跟正则表达式是否匹配</p>
<p>SQL: 用于操作数据库，数据库会从SQL语句读取信息，然后返回使用者期望的结果</p>
<p>CocoaPods|Grandle: 设定了具体的规则，用于管理第三方库和工程配置 </p>
<h2 id="如何手撸DSL"><a href="#如何手撸DSL" class="headerlink" title="如何手撸DSL"></a>如何手撸DSL</h2><h3 id="构建DSL"><a href="#构建DSL" class="headerlink" title="构建DSL"></a>构建DSL</h3><ol>
<li>设计语法和语义，定义DSL中的元素（token）是什么样的，元素（token）代表什么意思</li>
<li>实现parser，对DSL进行解析，生成并处理抽象树(AST)，DSL最终通过解释器来执行</li>
</ol>
<h3 id="内部DSL和外部DSL"><a href="#内部DSL和外部DSL" class="headerlink" title="内部DSL和外部DSL"></a>内部DSL和外部DSL</h3><p>外部DSL：语法语义，语法解析器和抽象树的处理都需要自己完成。</p>
<p>内部DSL：内部DSL嵌入一些编程语言中的，比如iOS的CocoaPods(Ruby)和Android的Gradle(Groovy)。</p>
<p>内部DSL使用了宿主的能力，不需要实现语法分析器(Parser)，通常会使用宿主语言的特性进行创造。</p>
<h3 id="CocoaPods分析："><a href="#CocoaPods分析：" class="headerlink" title="CocoaPods分析："></a>CocoaPods分析：</h3><ol>
<li><p>为什么基于Ruby:</p>
<ol>
<li>ruby一切皆对象，减少了语言中的元素，不存在基本类型，操作符</li>
<li>ruby方法传入代码块很方便</li>
<li>作为解释执行的语言，eval可以将字符串作为代码执行</li>
<li>代码格式不受限</li>
</ol>
</li>
<li><p>Podfile:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span> </span><br><span class="line">source <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>   </span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;testTTAcount&#x27;</span> <span class="keyword">do</span></span><br><span class="line">   pod <span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Source: 依赖的源地址</p>
<p>Target: 要添加依赖的工程的名字</p>
<p>Pod: 表示依赖，gRPC-Swift为依赖库，后面为版本号</p>
<p>将上面的部分以更符合代码形式则表示为:</p>
<p>在执行时会作为Ruby代码来执行</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source(<span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span>)</span><br><span class="line">source(<span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&#x27;testTTAcount&#x27;</span>) <span class="keyword">do</span></span><br><span class="line">  pod (<span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何使用Ruby实现一个简单的内部DSL</p>
<ol>
<li>创建一些Podfile中”代码“执行的上下文，即一些方法。</li>
<li>读取Podfile中的内容到脚本中。</li>
<li>使用eval在上下文中执行Podfile的”代码“</li>
</ol>
</li>
<li><p>实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span> </span><br><span class="line">source <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;10.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;testTTAcount&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;gRPC-Swift&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里的source, platform, target,pod都是方法，所以需要构建包含这些方法的上下文</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval_pod.rb</span></span><br><span class="line"><span class="variable">$hash_value</span> = &#123;&#125; /<span class="regexp">/存储指定的依赖</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def source(url)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def target(target)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def platform(platform, version)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">def pod(pod)</span></span><br><span class="line"><span class="regexp">end</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">content = File.read &#x27;./</span>Podfile<span class="string">&#x27;//从一个podfile中读取</span></span><br><span class="line"><span class="string">eval content //使用eval执行，读取的内容（作为ruby代码执行）</span></span><br><span class="line"><span class="string">p $hash_value //打印指定的依赖</span></span><br></pre></td></tr></table></figure>

<p>简单实现一下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;source&#x27;</span>] = url</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line">    targets = <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>]</span><br><span class="line">    targets = [] <span class="keyword">if</span> targets == <span class="literal">nil</span></span><br><span class="line">    targets &lt;&lt; target</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>] = targets</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line">    pods = <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>]</span><br><span class="line">    pods = [] <span class="keyword">if</span> pods == <span class="literal">nil</span></span><br><span class="line">    pods &lt;&lt; pod</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>] = pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br><span class="line">&#123;<span class="string">&quot;source&quot;</span>=&gt;[<span class="string">&#x27;https://github.com/volcengine/volcengine-specs.git&#x27;</span>,<span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>], <span class="string">&quot;targets&quot;</span>=&gt;[<span class="string">&quot;testTTAcount&quot;</span>], <span class="string">&quot;pods&quot;</span>=&gt;[<span class="string">&quot;gRPC-Swift&quot;</span>, <span class="string">&quot;SDWebImage&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理:"></a>编译原理:</h3><p>编译的过程：</p>
<ol>
<li><p>预处理:</p>
<ul>
<li>头文件替换</li>
<li>宏展开</li>
<li>注释清除</li>
<li>预编译指令处理</li>
<li>条件编译</li>
<li>…</li>
</ul>
</li>
<li><p>词法分析:</p>
<p>简单的说就是想读英文文章一样，先一个一个的读出单词，获取到单词的意思。</p>
<p>这里将“词法记号”，即token。词法分析的过程叫做分词，可以将语句切割成多个token</p>
<ol>
<li>通过正则文法读取</li>
<li>通过有限自动机</li>
</ol>
</li>
<li><p>语法分析：</p>
<p>在词法分析的基础上识别程序的语法结构，生成一个树状结构，即抽象语法树(AST Abstract Syntax Tree)</p>
<p>Eg: 1+2*3</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gy5597m3jmj30ni0i6t9i.jpg" alt="img" style="zoom:50%;" /></li>
<li><p>语义分析：</p>
<p>基于AST，编译器会进行语义分析。语义分析会标注在抽象语法树的节点上。</p>
<p>Eg: </p>
<ol>
<li>某个表达式的结果是什么类型？不一样能否自动转换</li>
<li>一个代码块内部和外部有相同名称的变量，执行时应该用哪一个</li>
</ol>
</li>
<li><p>中间代码生成：</p>
<p>一般来说，编译器会有一个抽象于机器平台的中间语言（IR）以便后续的机器无关的优化</p>
</li>
<li><p>代码优化：</p>
<p>机器无关的优化。函数内联，for循环展开</p>
</li>
<li><p>目标代码生成：</p>
<p>生成目标平台的代码，如果是编译型的语言，往往是产生.o文件。这里编译器的工作已经结束了。</p>
</li>
</ol>
<p>词法分析，语法分析，语义分析为编译器前端内容</p>
<p>中间代码生成，代码优化，目标代码生成为编译器后端内容</p>
<h3 id="ANTLR"><a href="#ANTLR" class="headerlink" title="ANTLR:"></a>ANTLR:</h3><p>教程文档:<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/antlr4-short-course/content/">https://wizardforcel.gitbooks.io/antlr4-short-course/content/</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.antlr.org/support.html">https://www.antlr.org/support.html</a></p>
<p>介绍:</p>
<p>ANTLR v4是一款功能强大的语法分析器生成器，可以用来读取、处理、执行和转换结构化文本或二进制文件。它被广泛应用于学术界和工业界构建各种语言、工具和框架。</p>
<p>从称为文法的一种形式化的语言描述中，ANTLR生成该语言的语法分析器。生成的语法分析器可以自动构建语法分析树——表示文法如何匹配输入的数据结构。ANTLR还可以自动生成树遍历器，你可以用它来访问那些树的节点，以执行特定的代码。</p>
<p>原理：</p>
<p><a target="_blank" rel="noopener" href="http://staff.ustc.edu.cn/~yuzhang/compiler/2019f/lectures/allstar.pdf">ANTLR原理</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/">ANTLR-Go</a></p>
<h3 id="算法表达式示例"><a href="#算法表达式示例" class="headerlink" title="算法表达式示例"></a>算法表达式示例</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy58m7uqwkj312y0oytbm.jpg" alt="飞书20220107-172941"></p>
<ol>
<li><p>词法定义：</p>
<p>词法规则类似与正则表达式，这里即关注数字和加减乘除，忽略空白符</p>
</li>
<li><p>文法规则：</p>
<p>start为文法的入口； expresion定义了具体的计算表达式。</p>
<p>表达式：表达式可以是一个数字，数字的加减乘除，表达式的加减乘除，或者通过括号包裹表达式组合。</p>
</li>
<li><p>规则名称：</p>
<p>antlr会将.g4定义的规则生成一个解析器的代码框架，能自动解析并生成AST。业务层拿到抽象语法树以后，还需要根据AST来处理业务逻辑以及业务需求</p>
</li>
<li><p>上下文标记：</p>
<p>为文法规则分配上下文标记，该标记可用再业务代码处理AST时，更加明确区分当前上下文的规则。</p>
<p>比如在：AdditionOrSubstraction这行，左右表达式都是expressin，这里通过上下文标记，left=,right=的方式为左右expresion添加了上下文标记，这样业务代码也就可用区分左右表达式了</p>
</li>
<li><p>生成解析器（Visitor模式|Listener模式）</p>
<p>Visitor模式：</p>
<p>执行对于语言的命令后，会生成对应语言下的代码：</p>
<p>其中calcLexer是词法分析器，calcParser是语法分析器，calcVisitor是遍历AST的访问器的interface，业务代码需要实现该interface实现具体的业务需求逻辑</p>
</li>
</ol>
<p>生成的结构：</p>
<p>根据名字大概可以看出各个文件的作用，calc_lexer为词法分析器，作用是生成tokens流。calc_parser是语法分析器，用于生成AST。calcVisitor是用于遍历AST的访问器的接口，业务代码通过实现该接口来实现具体的业务逻辑。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gy8eni3fvlj30b60a4glz.jpg" alt="飞书20220110-111501" align='left' style="zoom: 67%;" />

<p>在calc_visitor这个接口中，定义了一系列以visit为前缀的函数，这些函数对应了.g4中的每一个规则名称。</p>
<p>eg: visitNumber对应了.g4里的#Number规则</p>
<p>这些访问函数，都接收一个上下文参数，不同的规则，上下文参数会有差异，最主要就是会有不同的上下文标记可用使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CalcVisitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	antlr.ParseTreeVisitor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#start.</span></span><br><span class="line">	VisitStart(ctx *StartContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Number.</span></span><br><span class="line">	VisitNumber(ctx *NumberContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#MultiplicationOrDivision.</span></span><br><span class="line">	VisitMultiplicationOrDivision(ctx *MultiplicationOrDivisionContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#AdditionOrSubstraction.</span></span><br><span class="line">	VisitAdditionOrSubstraction(ctx *AdditionOrSubstractionContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Parentheses.</span></span><br><span class="line">	VisitParentheses(ctx *ParenthesesContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visit a parse tree produced by CalcParser#Power.</span></span><br><span class="line">	VisitPower(ctx *PowerContext) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键函数.visit：这个函数是遍历AST的核心函数，这个函数内部会根据visit的具体规则，进入到visitXXX函数，在具体的visitXXX函数，又通过业务代码调用.visit来实现深度优先遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;Calc/parser&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/antlr/antlr4/runtime/Go/antlr&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">opt</span><span class="params">(opr <span class="keyword">string</span>,a,b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span>  &#123; <span class="comment">//处理算术运行逻辑</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;_opt&quot;</span>,opr,a,b)</span><br><span class="line">	a1,b1 := a.(<span class="keyword">int</span>),b.(<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">switch</span> opr[<span class="number">0</span>] &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> a1+b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> a1-b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> a1*b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> a1/b1</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a1),<span class="keyword">float64</span>(b1)))</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;_opt err&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyCalVisitor <span class="keyword">struct</span> &#123;</span><br><span class="line">	parser.BaseCalcVisitor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">Visit</span><span class="params">(tree antlr.ParseTree)</span> <span class="title">interface</span></span>&#123;&#125;  &#123;<span class="comment">//目前Go的实现为返回nil，需要自己处理一下</span></span><br><span class="line">	<span class="keyword">switch</span> val := tree.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *parser.NumberContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitNumber(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.MultiplicationOrDivisionContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitMultiplicationOrDivision(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.AdditionOrSubstractionContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitAdditionOrSubstraction(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.ParenthesesContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitParentheses(val)</span><br><span class="line">	<span class="keyword">case</span> *parser.PowerContext:</span><br><span class="line">		<span class="keyword">return</span> v.VisitPower(val)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitStart</span><span class="params">(ctx *parser.StartContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">//入口，为一个表达式</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitStart&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> v.Visit(ctx.Expression())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitNumber</span><span class="params">(ctx *parser.NumberContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">//解析token为一个数字</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitNumber&quot;</span>)</span><br><span class="line">	num,_ := strconv.Atoi(ctx.NUMBER().GetText())</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitMultiplicationOrDivision</span><span class="params">(ctx *parser.MultiplicationOrDivisionContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="comment">//乘除算术运算</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitMultiplicationOrDivision&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitAdditionOrSubstraction</span><span class="params">(ctx *parser.AdditionOrSubstractionContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="comment">//加减算术运算</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitAdditionOrSubstraction&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitParentheses</span><span class="params">(ctx *parser.ParenthesesContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">//括号</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitParentheses&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> v.Visit(ctx.GetInner())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *MyCalVisitor)</span> <span class="title">VisitPower</span><span class="params">(ctx *parser.PowerContext)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">//阶乘</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;VisitPower&quot;</span>)</span><br><span class="line">	a := v.Visit(ctx.GetLeft())</span><br><span class="line">	b := v.Visit(ctx.GetRight())</span><br><span class="line">	<span class="keyword">return</span> _opt(ctx.GetOperator().GetText(),a,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="protoc-gen"><a href="#protoc-gen" class="headerlink" title="protoc-gen"></a>protoc-gen</h2><h5 id="generator-GenerateAllFiles"><a href="#generator-GenerateAllFiles" class="headerlink" title="generator.GenerateAllFiles()"></a>generator.GenerateAllFiles()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成所有.proto文件对应的go源代码，这里只是将源代码内容存储到g.Response中，</span></span><br><span class="line"><span class="comment">// 并没有直接创建源代码文件，插件将Response传递给protoc进程后由protoc进程来负</span></span><br><span class="line"><span class="comment">// 责创建源代码文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">GenerateAllFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the plugins</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> plugins &#123;</span><br><span class="line">        p.Init(g)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Generate the output. The generator runs for every file, even the files</span></span><br><span class="line">    <span class="comment">// that we don&#x27;t generate output for, so that we can collate the full list</span></span><br><span class="line">    <span class="comment">// of exported symbols to support public imports.</span></span><br><span class="line">    genFileMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*FileDescriptor]<span class="keyword">bool</span>, <span class="built_in">len</span>(g.genFiles))</span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> g.genFiles &#123;</span><br><span class="line">        genFileMap[file] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> g.allFiles &#123;</span><br><span class="line">        g.Reset()</span><br><span class="line">        g.writeOutput = genFileMap[file]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用generator的generate(...)方法来生成该proto文件的</span></span><br><span class="line">        <span class="comment">// FileDescriptorProto描述对应的go源代码</span></span><br><span class="line">        g.generate(file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.Response.File = <span class="built_in">append</span>(g.Response.File, &amp;plugin.CodeGeneratorResponse_File&#123;</span><br><span class="line">            Name:    proto.String(file.goFileName()),</span><br><span class="line">            Content: proto.String(g.String()),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator .generate()方法如何实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对.proto文件（由FileDescriptor表示）生成对应的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">generate</span><span class="params">(file *FileDescriptor)</span></span> &#123;</span><br><span class="line">    g.file = g.FileOf(file.FileDescriptorProto)</span><br><span class="line">    g.usedPackages = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要生成源代码的首个proto文件对应的go源代码，这部分代码顶部插入版权信息</span></span><br><span class="line">    <span class="keyword">if</span> g.file.index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// For one file in the package, assert version compatibility.</span></span><br><span class="line">        g.P(<span class="string">&quot;// This is a compile-time assertion to ensure that this generated file&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// is compatible with the proto package it is being compiled against.&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// A compilation error at this line likely means your copy of the&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;// proto package needs to be updated.&quot;</span>)</span><br><span class="line">        g.P(<span class="string">&quot;const _ = &quot;</span>, g.Pkg[<span class="string">&quot;proto&quot;</span>], <span class="string">&quot;.ProtoPackageIsVersion&quot;</span>, generatedCodeVersion, <span class="string">&quot; // please upgrade the proto package&quot;</span>)</span><br><span class="line">        g.P()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成import语句</span></span><br><span class="line">    <span class="keyword">for</span> _, td := <span class="keyword">range</span> g.file.imp &#123;</span><br><span class="line">        g.generateImported(td)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成enum类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, enum := <span class="keyword">range</span> g.file.enum &#123;</span><br><span class="line">        g.generateEnum(enum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成message类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, desc := <span class="keyword">range</span> g.file.desc &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t generate virtual messages for maps.</span></span><br><span class="line">        <span class="keyword">if</span> desc.GetOptions().GetMapEntry() &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.generateMessage(desc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成extension类型定义语句</span></span><br><span class="line">    <span class="keyword">for</span> _, ext := <span class="keyword">range</span> g.file.ext &#123;</span><br><span class="line">        g.generateExtension(ext)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成初始化函数语句</span></span><br><span class="line">    g.generateInitFunction()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前面生成enum、message、extension等的方式都基本类似，后面我们只给出一个</span></span><br><span class="line">    <span class="comment">// 生成枚举类型方法的说明，生成message、extension的实现方法可以执行查看</span></span><br><span class="line">    <span class="comment">// generator.go中的实现。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 需要注意的是，前面的各个生成源代码的方法不能处理service服务定义的rpc接</span></span><br><span class="line">    <span class="comment">// 口代码，这部分rpc代码的生成需要借助于grpc子插件来完成，即下面的g.runPlugins(...)</span></span><br><span class="line">    g.runPlugins(file)</span><br><span class="line"></span><br><span class="line">    g.generateFileDescriptor(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待输出的源代码需要知道哪些package是需要import的，哪些不需要，因此先运行</span></span><br><span class="line">    <span class="comment">// 插件生成go代码中除import之外的其他部分代码，然后知道了哪些package需要</span></span><br><span class="line">    <span class="comment">// import，再插入具体的import语句。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 最后在go源代码中插入header、import</span></span><br><span class="line">    rem := g.Buffer</span><br><span class="line">    g.Buffer = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    g.generateHeader()</span><br><span class="line">    g.generateImports()</span><br><span class="line">    <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    g.Write(rem.Bytes())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新格式化生成的go源代码（gofmt）</span></span><br><span class="line">    fset := token.NewFileSet()</span><br><span class="line">    raw := g.Bytes()</span><br><span class="line">    ast, err := parser.ParseFile(fset, <span class="string">&quot;&quot;</span>, g, parser.ParseComments)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Print out the bad code with line numbers.</span></span><br><span class="line">        <span class="comment">// This should never happen in practice, but it can while changing generated code,</span></span><br><span class="line">        <span class="comment">// so consider this a debugging aid.</span></span><br><span class="line">        <span class="keyword">var</span> src bytes.Buffer</span><br><span class="line">        s := bufio.NewScanner(bytes.NewReader(raw))</span><br><span class="line">        <span class="keyword">for</span> line := <span class="number">1</span>; s.Scan(); line++ &#123;</span><br><span class="line">            fmt.Fprintf(&amp;src, <span class="string">&quot;%5d\t%s\n&quot;</span>, line, s.Bytes())</span><br><span class="line">        &#125;</span><br><span class="line">        g.Fail(<span class="string">&quot;bad Go source code was generated:&quot;</span>, err.Error(), <span class="string">&quot;\n&quot;</span>+src.String())</span><br><span class="line">    &#125;</span><br><span class="line">    g.Reset()</span><br><span class="line">    err = (&amp;printer.Config&#123;Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: <span class="number">8</span>&#125;).Fprint(g, fset, ast)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        g.Fail(<span class="string">&quot;generated Go source code could not be reformatted:&quot;</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何生成enum"><a href="#如何生成enum" class="headerlink" title="如何生成enum"></a>如何生成enum</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成指定enum类型的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">generateEnum</span><span class="params">(enum *EnumDescriptor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// enum类型的完整类型名</span></span><br><span class="line">    typeName := enum.TypeName()</span><br><span class="line">    <span class="comment">// CamelCased之后的完整类型名</span></span><br><span class="line">    ccTypeName := CamelCaseSlice(typeName)</span><br><span class="line">    ccPrefix := enum.prefix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印enum类型定义之前的leading comments</span></span><br><span class="line">    <span class="comment">// - 提取源代码信息SourceCodeInfo都是通过Location path来获取的；</span></span><br><span class="line">    <span class="comment">// - 提取注释信息也不例外，下面我们会介绍PrintComments(path)如何通过</span></span><br><span class="line">    <span class="comment">//   Location path来生成注释信息；</span></span><br><span class="line">    g.PrintComments(enum.path)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成枚举类型的定义起始部分：type 枚举类型名 int32</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, ccTypeName, <span class="string">&quot; int32&quot;</span>)</span><br><span class="line">    g.file.addExport(enum, enumSymbol&#123;ccTypeName, enum.proto3()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举类型里面的各个枚举值都作为const int32常量来定义</span></span><br><span class="line">    g.P(<span class="string">&quot;const (&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值定义之前缩进一下</span></span><br><span class="line">    g.In()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对枚举类型里面的所有枚举值进行源代码生成</span></span><br><span class="line">    <span class="keyword">for</span> i, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        <span class="comment">// 生成枚举值前面的leading comments</span></span><br><span class="line">        g.PrintComments(fmt.Sprintf(<span class="string">&quot;%s,%d,%d&quot;</span>, enum.path, enumValuePath, i))</span><br><span class="line">        <span class="comment">// 生成枚举值的name = value形式的go源代码</span></span><br><span class="line">        name := ccPrefix + *e.Name</span><br><span class="line">        g.P(name, <span class="string">&quot; &quot;</span>, ccTypeName, <span class="string">&quot; = &quot;</span>, e.Number)</span><br><span class="line">        g.file.addExport(enum, constOrVarSymbol&#123;name, <span class="string">&quot;const&quot;</span>, ccTypeName&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值定义完之后取消缩进</span></span><br><span class="line">    g.Out()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印最后的结束信息</span></span><br><span class="line">    g.P(<span class="string">&quot;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成枚举类型相关的两个map</span></span><br><span class="line">    <span class="comment">// - 其中一个是枚举值到枚举名的映射；</span></span><br><span class="line">    <span class="comment">// - 另一个是枚举名到枚举值的映射；</span></span><br><span class="line">    g.P(<span class="string">&quot;var &quot;</span>, ccTypeName, <span class="string">&quot;_name = map[int32]string&#123;&quot;</span>)</span><br><span class="line">    g.In()</span><br><span class="line">    <span class="comment">// 第一个map</span></span><br><span class="line">    generated := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">bool</span>) <span class="comment">// avoid duplicate values</span></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        duplicate := <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> _, present := generated[*e.Number]; present &#123;</span><br><span class="line">            duplicate = <span class="string">&quot;// Duplicate value: &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        g.P(duplicate, e.Number, <span class="string">&quot;: &quot;</span>, strconv.Quote(*e.Name), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        generated[*e.Number] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    g.Out()</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    <span class="comment">// 第二个map</span></span><br><span class="line">    g.P(<span class="string">&quot;var &quot;</span>, ccTypeName, <span class="string">&quot;_value = map[string]int32&#123;&quot;</span>)</span><br><span class="line">    g.In()</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> enum.Value &#123;</span><br><span class="line">        g.P(strconv.Quote(*e.Name), <span class="string">&quot;: &quot;</span>, e.Number, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    g.Out()</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他处理动作，也会生成部分源代码，这里可以忽略不计了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrintComments如何通过Location path来提前并打印关联的注释信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印.proto文件中对该location path关联的leading comments注释信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">PrintComments</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !g.writeOutput &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在protoc进程解析.proto文件的时候就已经将各个类型、字段的comments信息维</span></span><br><span class="line">    <span class="comment">// 护起来了，k就是location的path，通过path就能获取到对应的location，每个</span></span><br><span class="line">    <span class="comment">// location中保存了这个位置的源代码的leading comments、trailing comments信</span></span><br><span class="line">    <span class="comment">// 息，这里只打印leading comments</span></span><br><span class="line">    <span class="keyword">if</span> loc, ok := g.file.comments[path]; ok &#123;</span><br><span class="line">        text := strings.TrimSuffix(loc.GetLeadingComments(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(text, <span class="string">&quot;\n&quot;</span>) &#123;</span><br><span class="line">            g.P(<span class="string">&quot;// &quot;</span>, strings.TrimPrefix(line, <span class="string">&quot; &quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何生成service服务的rpc接口源代码"><a href="#如何生成service服务的rpc接口源代码" class="headerlink" title="如何生成service服务的rpc接口源代码"></a>如何生成service服务的rpc接口源代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run all the plugins associated with the file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Generator)</span> <span class="title">runPlugins</span><span class="params">(file *FileDescriptor)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在上述generator处理的基础上，继续运行generator中注册的插件，依次运行插件</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> plugins &#123;</span><br><span class="line">        p.Generate(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成.proto文件中service定义的rpc接口的go源代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *grpc)</span> <span class="title">Generate</span><span class="params">(file *generator.FileDescriptor)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有定义service服务直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(file.FileDescriptorProto.Service) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相关变量定义</span></span><br><span class="line">    g.P(<span class="string">&quot;// Reference imports to suppress errors if they are not otherwise used.&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;var _ &quot;</span>, contextPkg, <span class="string">&quot;.Context&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;var _ &quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言，检查版本兼容性</span></span><br><span class="line">    g.P(<span class="string">&quot;// This is a compile-time assertion to ensure that this generated file&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;// is compatible with the grpc package it is being compiled against.&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;const _ = &quot;</span>, grpcPkg, <span class="string">&quot;.SupportPackageIsVersion&quot;</span>, generatedCodeVersion)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对所有的service定义生成相关的service的go源代码</span></span><br><span class="line">    <span class="keyword">for</span> i, service := <span class="keyword">range</span> file.FileDescriptorProto.Service &#123;</span><br><span class="line">        g.generateService(file, service, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc中对generateService的实现，生成service相关的go源代码</span></span><br><span class="line"><span class="comment">// @param .proto解析后的各种DescriptorProto的wrapping类，通过它可以方便地访问.proto中定义的东西 </span></span><br><span class="line"><span class="comment">// @param .proto中的某个service解析后对应的ServiceDescriptorProto</span></span><br><span class="line"><span class="comment">// @param .proto中可能定义了多个service，当前这个service对应的索引值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *grpc)</span> <span class="title">generateService</span><span class="params">(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构建当前service对应的path!</span></span><br><span class="line">    path := fmt.Sprintf(<span class="string">&quot;6,%d&quot;</span>, index) <span class="comment">// 6 means service.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取service名称</span></span><br><span class="line">    origServName := service.GetName()</span><br><span class="line">    fullServName := origServName</span><br><span class="line">    <span class="keyword">if</span> pkg := file.GetPackage(); pkg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fullServName = pkg + <span class="string">&quot;.&quot;</span> + fullServName</span><br><span class="line">    &#125;</span><br><span class="line">    servName := generator.CamelCase(origServName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备生成client相关的go源代码</span></span><br><span class="line">    g.P()</span><br><span class="line">    g.P(<span class="string">&quot;// Client API for &quot;</span>, servName, <span class="string">&quot; service&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务用户端go源代码生成</span></span><br><span class="line">    <span class="comment">// - type 服务名+Client interface</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, servName, <span class="string">&quot;Client interface &#123;&quot;</span>)</span><br><span class="line">    <span class="comment">// - 服务用户端定义的各个接口方法</span></span><br><span class="line">    <span class="keyword">for</span> i, method := <span class="keyword">range</span> service.Method &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接口的leading comments</span></span><br><span class="line">        g.gen.PrintComments(fmt.Sprintf(<span class="string">&quot;%s,2,%d&quot;</span>, path, i)) <span class="comment">// 2 means method in a service.</span></span><br><span class="line">        <span class="comment">// 生成接口的签名</span></span><br><span class="line">        g.P(g.generateClientSignature(servName, method))</span><br><span class="line">    &#125;</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务的用户端struct，其中包括了一个cc *grpc.ClientConn，后面会在该struct</span></span><br><span class="line">    <span class="comment">// 上实现上述服务接口</span></span><br><span class="line">    g.P(<span class="string">&quot;type &quot;</span>, unexport(servName), <span class="string">&quot;Client struct &#123;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;cc *&quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewClient工厂 </span></span><br><span class="line">    g.P(<span class="string">&quot;func New&quot;</span>, servName, <span class="string">&quot;Client (cc *&quot;</span>, grpcPkg, <span class="string">&quot;.ClientConn) &quot;</span>, servName, <span class="string">&quot;Client &#123;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;return &amp;&quot;</span>, unexport(servName), <span class="string">&quot;Client&#123;cc&#125;&quot;</span>)</span><br><span class="line">    g.P(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> methodIndex, streamIndex <span class="keyword">int</span></span><br><span class="line">    serviceDescVar := <span class="string">&quot;_&quot;</span> + servName + <span class="string">&quot;_serviceDesc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务用户端的接口方法实现</span></span><br><span class="line">    <span class="keyword">for</span> _, method := <span class="keyword">range</span> service.Method &#123;</span><br><span class="line">        <span class="keyword">var</span> descExpr <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> !method.GetServerStreaming() &amp;&amp; !method.GetClientStreaming() &#123;</span><br><span class="line">            <span class="comment">// Unary RPC method</span></span><br><span class="line">            descExpr = fmt.Sprintf(<span class="string">&quot;&amp;%s.Methods[%d]&quot;</span>, serviceDescVar, methodIndex)</span><br><span class="line">            methodIndex++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Streaming RPC method</span></span><br><span class="line">            descExpr = fmt.Sprintf(<span class="string">&quot;&amp;%s.Streams[%d]&quot;</span>, serviceDescVar, streamIndex)</span><br><span class="line">            streamIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        g.generateClientMethod(servName, fullServName, serviceDescVar, method, descExpr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.P(<span class="string">&quot;// Server API for &quot;</span>, servName, <span class="string">&quot; service&quot;</span>)</span><br><span class="line">    g.P()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端接口go源代码生成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator生成service以为的代码，grpc生成service相关的go代码</p>
<p>参考:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/dsl/">https://draveness.me/dsl/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hitzhangjie.pro/blog/2017-05-23-protoc%E5%8F%8A%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%B2%BE%E5%8D%8E%E7%89%88/#242-%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8Bcodegeneratorrequest--codegeneratorresponse%E7%9A%84%E5%AE%9A%E4%B9%89">https://www.hitzhangjie.pro/blog/2017-05-23-protoc%E5%8F%8A%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E7%B2%BE%E5%8D%8E%E7%89%88/#242-%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8Bcodegeneratorrequest--codegeneratorresponse%E7%9A%84%E5%AE%9A%E4%B9%89</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zhongsongzhi97.github.io/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/zhongsongzhi97.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/zhongsongzhi97.github.io/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/zhongsongzhi97.github.io/page/5/">5</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
