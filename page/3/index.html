<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/3/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2022/01/06/MySQL-%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2022/01/06/MySQL-%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">MySQL - 索引和调优小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-06 21:28:07" itemprop="dateCreated datePublished" datetime="2022-01-06T21:28:07+08:00">2022-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-29 17:10:15" itemprop="dateModified" datetime="2022-01-29T17:10:15+08:00">2022-01-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MySQL索引和SQL调优"><a href="#MySQL索引和SQL调优" class="headerlink" title="MySQL索引和SQL调优"></a>MySQL索引和SQL调优</h1><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>MySQL支持多种引擎，各种引擎对所有的支持不同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。其中只有为BTree索引。</p>
<h3 id="B-Tree索引："><a href="#B-Tree索引：" class="headerlink" title="B-Tree索引："></a>B-Tree索引：</h3><p>eg:  key(last_name, first_name, birthday)</p>
<p>适用于全键值，键值范围，键前缀查找</p>
<p>全值匹配：和索引的所有列匹配，查询一个名为 ab出生日期c的 人</p>
<p>匹配最左前缀：匹配 last_name = a的人，只使用了索引的第一列</p>
<p>匹配列前缀：查询last_name的第一个字母为J的人</p>
<p>匹配范围值：查询last_name在allen和Bob之间的人，只使用了索引第一列</p>
<p>精确匹配某一列并范围匹配另一列：查询姓为allen，名字k开头的人。即第一列last_name精确匹配，第二列first_name范围匹配</p>
<p>覆盖索引：即要查的数据都在索引中包含了，即不需要回查具体的行的内容</p>
<p><strong>索引用于ORDER BY</strong>: 满足上述范围的查询，进行order by也可以使用索引</p>
<p><strong>限制：</strong></p>
<ol>
<li>最左前缀匹配优先：如果不是按照索引最左列开始查找，就无法使用索引。比如上述的所有无法查找first_name = bill 的人，需要取出所有的值，然后再匹配</li>
<li>不能跳过索引中的列：比如无法在索引上找到last_name=’Smith’并且birthday=”1997-01-01”的人，只能通过索引找到last_name=Smith的所有行，然后在去匹配</li>
<li>如果最左匹配中遇到某一行为范围查询，则后续的列都无法使用索引：比如 where last_name = ‘Smith’ AND first_name list ‘%j’ and birthday = ‘1997-01-01’则会找到满足last_name和first_name的，然后取出所有行再和birthday做匹配</li>
</ol>
<h2 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h2><p>目的：提高查询效率（读，写），数据库的查询情况复杂，包括等值查询，范围查询，模糊查询，并集查询，多值匹配等。需要每次查找数据时，磁盘IO次数较少，高度可控的多路搜索树就是很好的选择。</p>
<p>索引结构：B+树</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树的重要性质：</p>
<ol>
<li><p>索引字段越小，数据项的数目越多，树的高度越低 - 所以B+树的索引字段要尽量小</p>
</li>
<li><p>最左匹配：当B+树的数据项是复合的数据结构，比如(name, age, sex)的时候，b+树是按照从左到右的顺序来构建搜索树的。比如(张三，24，F)进行检索时，会优先比较name来确定下一个搜索方向，name相同再依次比较age，sex，最后得到检索的数据。</p>
<p>但是当(24,F)这样的没有name的数据来的时候，B+数不知道下一步该查哪一个节点</p>
<p>当（张三，F）进行检索，先根据name进行搜索，由于age缺失，只能把所有满足张三的都找到，然后再匹配性别为F的数据</p>
</li>
</ol>
<p>B+树在磁盘存储中表现的特性</p>
<ol>
<li>为了节省内存，是把B+树存储到硬盘中的，对于每一个节点的访问都对应了一次磁盘IO操作 -&gt; 树的高度 == 查询时的磁盘IO次数</li>
<li>一个m叉树，m越大高度越低。但是操作系统是按页（4KB）来读取磁盘或内存中的数据的。如果读取的数据量超过4KB，则会触发多次IO操作。所以在选择m的大小时，尽量让每个节点的大小等于一个页的大小。这样一个节点只需要一次IO。（总的次数：(向上取整)(节点大小)/4KB  * 树的高度）</li>
<li>数据的增加删除修改都会导致B+树结构调整，自增字段会减少消耗</li>
</ol>
<h2 id="MySQL索引的实现"><a href="#MySQL索引的实现" class="headerlink" title="MySQL索引的实现"></a>MySQL索引的实现</h2><p>主要为MyISAM和InnoDB</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6r6in5akj30hs0ebjs2.jpg" alt="图片"></p>
<p>使用B+树，叶子节点存放的是数据的地址。</p>
<p>在MyISAM中，主索引和辅助索引在结构上都是一样的，只是主索引要求key是唯一的</p>
<p>上图使用的是Col1作为Primary Key,如果使用Col2作为辅助索引如下图</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6racejzaj30hs0ebaaq.jpg" alt="图片"></p>
<p>所以，对于MyISAM来说，索引检索为首先按照B+树的方式搜索索引，找到key以后读取地址值，再根据地址值读取相应的数据（非聚集的索引）</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>使用B+树，但是InnoDB的数据文件本身就是索引文件，表数据文件本身是按照B+树组织的一个索引结构，叶节点保存了完整的数据，索引key是数据表的主键。这种叫做聚集索引。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6rfassnzj30f306pdg3.jpg" alt="图片"></p>
<p>由于InnoDB的数据文件本身需要根据主键组织，所以InnoDB要求必须有主键（MyISAM可以没有）</p>
<p>如果没有显示指定，则MySQL会自动旋转一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则会自动生成一个隐含字段作为主键（自增，6字节的长整形）</p>
<p>由于InnoDB的表数据文件按照B+数组织，所以对于InnoDB的辅助索引来说，辅助索引的叶子节点需要保存的是主键的值而不是地址</p>
<p><strong>造成的不同</strong>：聚集索引的方式会使得按照主键（主索引）搜索的方式变得高效，但是对于辅助索引来说，需要进行两次检索（使用辅助索引检索到主键，然后在主索引通过主键找到记录）</p>
<p>重要特性：</p>
<ol>
<li>InnoDB的索引形式，导致其使用过长的字段作为主键，它的所有辅助索引都会因此变得过大</li>
<li>使用非单调的字段作为主键，在InnoDB中不是好事，因为InnoDB本身是B+树，非单调的主键会在插入新数据时，B+树频繁的分裂调整，所以使用自增字段作为主键是一个很好的选择</li>
</ol>
<h2 id="建立索引的原理"><a href="#建立索引的原理" class="headerlink" title="建立索引的原理"></a>建立索引的原理</h2><p>联合索引：</p>
<p>MySQL的索引可以按照一定的顺序引用多个列，这种索引叫做联合索引</p>
<p>一个联合索引是一个有序元祖。</p>
<p>索引匹配的最左原则：</p>
<p>假如索引列分别为A，B，C，顺序也是A，B，C</p>
<ol>
<li>如果查询[A],[A,B],[A,B,C]可以通过索引查询</li>
<li>如果使用[A,C]，则只能使用到A索引</li>
<li>如果查询的时候，是[B],[B,C],[C]，由于没有用的第一列索引，所以后面的索引也用不到</li>
<li>如果查询时范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列用不了索引</li>
</ol>
<p>索引的代价：</p>
<ol>
<li>索引本身需要空间存储</li>
<li>MySQL运行时也需要维护索引</li>
</ol>
<p>InnoDB存储引擎：没有特殊情况，使用一个与业务无关的自增主键</p>
<p>磁盘IO: MySQL的数据都是以文件形式存储在磁盘上的，数据库对数据的读取以页为基本单位单位读取，一般为4KB的整数倍。为了提升效率，会有缓冲池（时间局部性&amp;空间局部性）</p>
<p>随机读取和顺序读取：随机读取的消耗时间大约为10ms，内存中的随机读取大约1ms，顺序读写能达到一页0.1ms。所以能减少随机IO，使用顺序读取，会大大提高磁盘吞吐量。</p>
<p>过滤因子：一个 SQL 查询扫描的索引片大小其实是由过滤因子决定的，也就是满足查询条件的记录行数所占的比例。如果过滤因子比较好，则该列的重复字段的比例低。</p>
<p>匹配列和过滤列： users 表中有 name、age 和 (name, sex, age) 三个辅助索引。当where存在age=21或name=”123”时，三个索引都会成功匹配列用于选择索引树中的数据行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;draven&quot; <span class="keyword">AND</span> sex <span class="operator">=</span> &quot;male&quot; <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对于这种有等值有范围的请求，只会使用name,sex作为匹配列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>但是当其扫描到了所有的满足条件的数据行以后，会把age作为过滤列，这样可以减少去磁盘读取IO的情况</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy92m69i80j30rs099aag.jpg" alt="Match-Columns-Filter-Columns"></p>
<h3 id="建立索引的常见技巧："><a href="#建立索引的常见技巧：" class="headerlink" title="建立索引的常见技巧："></a>建立索引的常见技巧：</h3><ol>
<li><p>最终前缀匹配原则：MySQL会一直向右匹配直到遇见范围查询</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
<li><p>尽量选择区分度高的列作为索引，区分度高是指字段不重复的比例，比例越大扫描的记录数越少，唯一键的区分度为1</p>
</li>
<li><p>索引列不参与计算</p>
<p>eg:from_unixtime(create_time) = ’2014-05-29’就不能使用到索引</p>
<p>原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</p>
<p>Eg: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM actor WHERE actor_id + 1 = 5;</span><br><span class="line">//这里无法使用 key(actor_id) 因为mysql无法解析表达式</span><br><span class="line">SELECT actor_id FROM actor WHERE actor_id = 4; 保证索引列单独在比较符号的左边即可</span><br></pre></td></tr></table></figure></li>
<li><p>尽量扩展索引而不是新建索引，比如本身已经有a索引了，需要（a，b）索引，则最好修改原来的索引a为（a，b）最好，否则会存冗余和重复索引（MySQL也不会自动删除）</p>
</li>
<li><p>前缀索引：对于value为字符串类型的索引来说，直接索引值会使得索引变得很大且很慢。如果只是索引开始的部分字符，就可以解决。前缀索引无法用于做ORDER BY和GROUP BY，也不能使用前缀索引做覆盖扫描。</p>
</li>
<li><p>多列索引和合适的索引列顺序：多列索引-&gt;不为每个列建一个索引，而是建一个多列索引。多列索引的顺序最好按照区分度来，区分度搞的在前面。对于有些情况，比如登录用户，除了普通用户以为，还有大量的游客用户是用的相同的username，则最好的办法是在业务层面上做好区分。</p>
</li>
<li><p>使用自增主键</p>
</li>
<li><p>对于常用的查询，建立覆盖索引</p>
</li>
<li><p>使用索引扫描来做排序：如何生成有序的结果：1. 通过排序操作 2. 按索引顺序扫描</p>
<p>扫描索引本身很快，但是不是覆盖索引，就需要回表，基本都是随机IO，所以按索引顺序读取数据通常比全表扫描更慢。只有当索引的列顺序和ORDER BY的子句顺序完全一致，并且排序方向都一致时，才能使用索引对结果进行排序。如果是Join多张表，只有ORDER BY子句引用的字段全是第一个表时，才能使用索引做排序。</p>
</li>
</ol>
<h3 id="索引设计的案列"><a href="#索引设计的案列" class="headerlink" title="索引设计的案列"></a>索引设计的案列</h3><ol>
<li><p>支持多种过滤条件：</p>
<p>设计一个在线约会网站，用户信息表有很多列，包括国家，地区，城市，性别等。需要支持按照以上特质组合来搜索用户</p>
<p>这里由于sex, country使用的情况非常多，所以需要用(sex, country)列做前缀。但是sex, country的区分度很低，如果某个查询没有使用到sex该怎么办？这里使用 查询条件 AND SEX IN(‘m’, ‘f’) 来让索引能够被使用，包括contry也可以</p>
</li>
<li><p>避免多个范围条件：</p>
<p>在上述的在线约会网站中，有一个last_online列并希望能够查询过去几周上过线的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE last_online &gt; DATE_SUB(NOW(),INTERVAL 7 DAY) AND age BETWEEN 18 AND 25</span><br></pre></td></tr></table></figure>

<p>对于范围查询，MySQL无法使用范围列后面的其他索引列，但是对于多个“等值条件查询”没有这个限制</p>
<p>这里有两个范围条件, last_online和age，MySQL可以使用last_online或者age，但是没有办法同时使用，如果也无法使用IN来优化为多个等值条件查询，比如这里的，那就可以将范围查询转换为一个简单的等值查询来处理。</p>
<p>这里最好的解决办法是，维护以active列，在业务层使用定时任务来维护。</p>
</li>
<li><p>优化排序：</p>
<ul>
<li><p>如何对区分度非常低的列进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;cols&gt; FROM users WHERE sex=&#x27;M&#x27; ORDER BY rating LIMIT 10;</span><br><span class="line">//这个索引同时使用了ORDER BY 和 LIMIT 如果没有索引会很慢</span><br><span class="line">//创建索引 &lt;sex,rating&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>但是以上情况在查询翻页比较靠后的情况 LIMIT 100000,10也会很慢</p>
<p>这里需要现在用户翻页的数量，不过也可以通过延迟关联来优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;cols&gt; FROM users INNER JOIN (SELECT &lt;primary key cols&gt; FROM users WHERE x.sex=&#x27;M&#x27; ORDER BY rating LIMIT 100000,10) AS x USING(&lt;primary key cols&gt;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p>概念：如果一个查询语句的索引是三星索引，那么它只需要进行<strong>一次磁盘的随机读及一个窄索引片的顺序扫描</strong>就可以得到全部的结果集</p>
<p>最简单的方式：在设计单表的索引时，首先把查询中所有的<strong>等值谓词全部取出</strong>以任意顺序放在索引最前面，在这时，如果索引中同时存在范围索引和 ORDER BY 就需要权衡利弊了，希望最小化扫描的索引片厚度时，应该将<strong>过滤因子最小的范围索引列</strong>加入索引，如果希望避免排序就选择 <strong>ORDER BY 中的全部列</strong>，在这之后就只需要将查询中<strong>剩余的全部列</strong>加入索引了，通过这种固定的方法和逻辑就可以最快地获得一个查询语句的二星或者三星索引了。</p>
<p>Todo: 数据库索引设计与优化 Book</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/31/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/31/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">计算广告小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-31 14:51:42 / Modified: 16:09:21" itemprop="dateCreated datePublished" datetime="2021-12-31T14:51:42+08:00">2021-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算广告小结"><a href="#计算广告小结" class="headerlink" title="计算广告小结"></a>计算广告小结</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxx0qu65d3j30tk1lj10k.jpg" alt="计算广告基础概念"></p>
<h2 id="广告基础："><a href="#广告基础：" class="headerlink" title="广告基础："></a>广告基础：</h2><ol>
<li><p>什么是广告？</p>
<p>广告是由已确定的出资人通过各种媒介进行的有关产品的，有组织，综合，劝服性的非人员的信息传播活动</p>
</li>
<li><p>广告的目的？</p>
<p>广告主通过媒体达到低成本的用户接触</p>
</li>
<li><p>广告的参与者：</p>
<p>需求方：广告主</p>
<p>供给方：媒体或者其他技术形态的变现平台</p>
<p>受众：普通群众，一个被动的参与方</p>
</li>
<li><p>分类：</p>
<p>大体上是按照售卖方式，分为品牌广告和效果广告。</p>
<p>如果按照广告的形式，可以有多种多样，比如开屏广告，激励视频广告，搜索广告等等。</p>
<p>品牌广告：广告主希望借助媒体达到宣传品牌形象，提升中长期购买率和利润空间的目的。</p>
<p>效果广告：广告主希望能利用广告手段马上带来大量的购买行为。</p>
</li>
</ol>
<h2 id="计算广告："><a href="#计算广告：" class="headerlink" title="计算广告："></a>计算广告：</h2><ol>
<li><p>特点：</p>
<ol>
<li>技术和计算导向</li>
<li>效果可衡量</li>
<li>创意和投放方式标准化</li>
<li>媒体概念多样化</li>
<li>数据驱动的投放决策</li>
</ol>
</li>
<li><p>基本概念：</p>
<ol>
<li>点击率CTR(Click Through Rate):广告点击与广告展现的比率</li>
<li>转化率CVR(Conversion Rate):点击广告以后，会打开广告主的落地页，落地页成功打开次数与点击次数的比率成为到达率。从落地页开始，进一步完成下单等操作，则是转化，转化次数与到达次数的比例成为转化率。</li>
<li>千次展示付费(Cost Per Mille)CPM：广告每展示千次作为单位收取广告费。</li>
<li>千次展示收入(Effective cost per maille)eCPM：每千次展示可以获得的广告收入</li>
</ol>
</li>
<li><p>常见的收费模式：</p>
<ol>
<li><p>CPM：</p>
<p>对于效果和目的不便于直接衡量的，可以使用CPM（千次展示收费）方式计费。供给方和需求方约定好千次展示的计费标准，这些展示是否能够代理相应的收益，需要由需求方类估计和控制。</p>
</li>
<li><p>CPC：</p>
<p>CPC(Cost Per Click)计费，按点击收费。通常用于效果广告。CPC计费有利于发挥供给方和需求方的长处，把点击率的估计交给供给方，点击价值的估计交给需求方。供给方通过收集大量用户数据，可以准确评估点击率，转化效果则是广告商站内的行为，需要由他们自己的数据分析体系更准确的对其进行评估。</p>
</li>
<li><p>CPS/CPA/ROI:</p>
<p>按照销售订单数，转化行为数，投入产出比来计费。这种情况下，需求方只按照最后的转化收益来结算，极大程度的规避了风险。供给方不但需要估计点击率，还需要对点击价值做出估计，才能合理决定流量分配。</p>
<p>问题：</p>
<ol>
<li>转化行为对于供给方来说很难控制，也无法进行估计和优化。</li>
<li>存在广告主故意降低转化率以低成本获取大量品牌曝光的可能。</li>
</ol>
</li>
<li><p>CPT:</p>
<p>CPT(Cost Per Time)计费，这是针对大品牌广告主特定的广告活动，将某个广告位以独占的方式交给某广告主，按独占时间段收取费用。CPT虽然有额外的品牌效果和橱窗效应，但是无法利用受众定向技术。</p>
</li>
</ol>
<h2 id="广告投放和广告竞价"><a href="#广告投放和广告竞价" class="headerlink" title="广告投放和广告竞价"></a>广告投放和广告竞价</h2></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/29/%E9%93%BE%E6%8E%A5-%E8%A3%85%E8%BD%BD%EF%BC%8C%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/29/%E9%93%BE%E6%8E%A5-%E8%A3%85%E8%BD%BD%EF%BC%8C%E5%BA%93/" class="post-title-link" itemprop="url">链接,装载，库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-29 19:13:32" itemprop="dateCreated datePublished" datetime="2021-12-29T19:13:32+08:00">2021-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-30 12:00:26" itemprop="dateModified" datetime="2021-12-30T12:00:26+08:00">2021-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链接，装载，库"><a href="#链接，装载，库" class="headerlink" title="链接，装载，库"></a>链接，装载，库</h1><h2 id="从源代码到内存的通路"><a href="#从源代码到内存的通路" class="headerlink" title="从源代码到内存的通路"></a>从源代码到内存的通路</h2><h3 id="可执行文件的组成"><a href="#可执行文件的组成" class="headerlink" title="可执行文件的组成"></a>可执行文件的组成</h3><p>在链接前，需要将源文件编译为目标文件，目标文件链接为可执行文件。可执行文件（动态链接与运行时加载）由多个段组成：</p>
<ol>
<li>文件头：文件基本信息。</li>
<li>段表：描述各段的基本信息。</li>
<li>基本的代码段和数据段。</li>
<li>链接相关的。（符号的解析和重定位）</li>
<li>装载相关。</li>
</ol>
<h3 id="可执行文件的加载："><a href="#可执行文件的加载：" class="headerlink" title="可执行文件的加载："></a>可执行文件的加载：</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxuy176e6rj30u00znmy3.jpg" alt="img"></p>
<p>源代码编译而成的目标文件一般依赖系统的运行库和其他共享对象，将它们链接成可执行的程序并加载到内存。有以下这些方式“</p>
<ol>
<li>将所有相关文件静态链接成一个完整的可执行文件，然后加载到内存</li>
<li>将目标文件作为可执行文件，载入内存时由动态链接器加载其依赖的其他文件</li>
<li>将目标文件作为可执行文件，载入内存，由程序调用”依赖函数“加载或找到已加载到内存的函数地址，继续执行。</li>
</ol>
<h3 id="文件的映射"><a href="#文件的映射" class="headerlink" title="文件的映射"></a>文件的映射</h3><p>程序并不会完整的加载到内存中，会在执行时访问数据发生缺页时再加载。其中有两个关键的映射关系：、</p>
<ol>
<li>可执行文件各段与虚拟地址空间的映射。（VMA的数据结构）</li>
<li>虚拟地址空间与物理地址空间的映射。（页表）</li>
</ol>
<h3 id="进程虚拟地址空间的分布："><a href="#进程虚拟地址空间的分布：" class="headerlink" title="进程虚拟地址空间的分布："></a>进程虚拟地址空间的分布：</h3><p>代码区：</p>
<p>数据区：</p>
<p>​    静态数据区，动态数据区（堆，栈）</p>
<h2 id="符号-amp-模块，静态链接，动态链接"><a href="#符号-amp-模块，静态链接，动态链接" class="headerlink" title="符号&amp;模块，静态链接，动态链接"></a>符号&amp;模块，静态链接，动态链接</h2><h3 id="符号-amp-模块"><a href="#符号-amp-模块" class="headerlink" title="符号&amp;模块"></a>符号&amp;模块</h3><p>符号：符号最早起源于汇编的概念，汇编最早使用机器码（数字）来描述指令，操作数，地址值，后续改进为使用符号代替机器码。后续的符号也通常用于表示地址值，对于函数地址和变量地址都以符号来表示。</p>
<p>模块：现代语言中，通常会按照功能划分为不同的模块。在C语言中，若干变量和函数组成了一个模块，存放到一个.c源码文件中，这些源代码文件按照目录结构组织。</p>
<p>大规模软件通常会有很大规模的模块，这些模块直接相互依赖又相互独立。编译器会对每一个模块单独编译，每一个模块都会生成中间文件。中间文件最后会组合为一个单一的可执行文件。</p>
<p>因为模块间存在相互依赖，表现为：1. 模块间的函数调用 2. 模块间的变量访问</p>
<p>函数访问需要知道目标函数的地址，变量访问需要知道变量的地址，即：模块间符号的引用</p>
<h3 id="静态链接："><a href="#静态链接：" class="headerlink" title="静态链接："></a>静态链接：</h3><p>主要过程：</p>
<pre><code> 1. 地址和空间分配：
 + 扫描所有的目标文件，获得它们每个节的长度，属性，位置，并将目标文件中的符号表中所有的符号定义和符合引用收集，统一放到一个全局的符号表。链接器可以获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度和位置，建立映射关系。
 2. 符号决议
 + 将每个引用于它输入的可重定位目标文件的符号表中的一个确定的符合定义关联起来。
 + 相同模块的局部符号的引用。（每个模块的每个局部符合只有一个定义）
 + 全局符号：编译器遇到一个不在当前模块中定义的符号，会假设其再其他某个模块中定义，生成一个链接器符号表条目，并将其交给链接器处理。如果链接器在它的任何输入模块都找不到被引用符号的定义，就会输出一条错误信息并终止。
 + 多个目标文件出现相同名字的全局符合：
   1. 不允许有多个同名的强符号
   2. 如果有一个强符合与多个弱符合同名，选择强符合
   3. 多个弱符号同名，则从这些弱符合中任意选择一个。
 + 一个弱符号定义在多个目标文件
   1. 多个强符号类型不同（非法）
   2. 一个强符号，多个弱符合，出现类型不一致（同强符号，如果弱符合类型大于强，则发出警告）
   3. 多个弱符合类型不一致（选择最大的类型）
 3. **重定位**：
 + 链接器已经确定所有符合的虚拟地址了。链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> shared;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="keyword">int</span> shared = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = &amp;a;</span><br><span class="line">    &amp;a = &amp;b;</span><br><span class="line">    &amp;b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c中定义了2个全局符号，一个变量<strong>shared</strong>，一个函数<strong>swap</strong>. a.c中定义了一个全局符号<strong>main</strong>，a.c中引用了b.c中的2个符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c b.c</span><br></pre></td></tr></table></figure>

<p>使用gcc将这两个文件编译为中间文件以后，a的中间文件中，符号<strong>shared</strong>,<strong>swap</strong>地址的值都为0.</p>
<p>在这个过程中，每个模块会有一个relocation table保存每个模块的那些符号需要重定位，整体上有一个symbol table保存符号地址。</p>
<p>静态链接过程中，各个中间文件会把relocation table中需要重定位的符号进行重定位。</p>
<p>静态链接的问题：1. 浪费磁盘和内存空间 - 各个可执行程序中依赖的库都需要链接到可执行文件中 2. 程序的更新，部署，发布会有很多麻烦 - 每当更新程序时，都需要重新进行编译和链接</p>
<h3 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h3><p>不对组成程序的目标文件进行链接，等到程序运行时才进行链接。即链接推迟到运行时进行。</p>
<p>动态链接还分为：non-lazy binding(程序运行前就会被绑定) lazy binding(符号第一次使用时)绑定</p>
<h4 id="基本实现："><a href="#基本实现：" class="headerlink" title="基本实现："></a>基本实现：</h4><ol>
<li>动态链接会涉及到运行时的链接以及多个文件的装载，必须有操作系统的支持。</li>
<li>在Linux中，ELF动态链接文件被称为 DSO（动态共享对象 Dynamic Shared Objects）</li>
<li>Windows (DLL Dynamic Linking Library)</li>
<li>当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库，然后进行重定位。</li>
</ol>
<h4 id="动态链接程序运行时地址空间的分布"><a href="#动态链接程序运行时地址空间的分布" class="headerlink" title="动态链接程序运行时地址空间的分布"></a>动态链接程序运行时地址空间的分布</h4><ol>
<li>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射即可执行文件。对于动态链接，除了可执行文件以外，还有它所依赖的共享目标文件。</li>
<li>共享目标文件的地址分配<ol>
<li>静态共享库（地址固定）将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为哪些已知的模块预留足够的控件。这个地址对不同的应用程序都是固定的。</li>
<li>动态共享库（地址不固定）在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对所有绝对地址引用进行重定位。</li>
</ol>
</li>
<li>地址无关代码：<ol>
<li>把指令中需要修改的部分都剥离出来，和数据部分放在一起。这样指令部分就可以保持不变，而数据部分在每个进程都有一个副本。</li>
</ol>
</li>
<li>地址引用的处理<ol>
<li>模块内部的函数调用<ol>
<li>调用函数和调用者在同一模块，相对位置固定，不需要重定位</li>
</ol>
</li>
<li>模块内部的数据访问<ol>
<li>统一模块，相对位置固定</li>
</ol>
</li>
<li>模块外部的函数调用<ol>
<li>会在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table, GOT)，当需要引用该全局变量，可以通过GOT中相对应的间接引用。链接器会在装载模块时查找每个变量所在的地址，然后填充GOT中各项，确保指向地址正确。</li>
</ol>
</li>
<li>模块外部的数据访问<ol>
<li>会在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table, GOT)，当需要引用该全局变量，可以通过GOT中相对应的间接引用。链接器会在装载模块时查找每个变量所在的地址，然后填充GOT中各项，确保指向地址正确。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="其他内容："><a href="#其他内容：" class="headerlink" title="其他内容："></a>其他内容：</h2><h3 id="函数调用与栈："><a href="#函数调用与栈：" class="headerlink" title="函数调用与栈："></a>函数调用与栈：</h3><ol>
<li>为什么值传递：函数调用时，参数和返回值都是放到栈帧中的，对参数的操作访问是访问的栈帧中的内容。出栈时相关的修改部分就会丢失。</li>
<li>局部变量的生命周期：因为局部变量时存放到栈帧当中，所以局部变量的生命周期也就只有函数调用过程中。</li>
</ol>
<h3 id="构造函数和析构函数存在："><a href="#构造函数和析构函数存在：" class="headerlink" title="构造函数和析构函数存在："></a>构造函数和析构函数存在：</h3><p>可执行文件除了代码段以外，构造函数和析构函数一般存放在.init和.finit段。</p>
<p>运行库中包含由入口函数，这是进程执行的入口，它会在main之前执行.init中的代码，main执行完毕后执行.finit</p>
<p>?defer关键词是否存放到.finit</p>
<h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>应用场景1：</p>
<p>问题：APMInsight用于监控SDK本身的崩溃。对于动态库，由于可以拿到动态库的地址范围，所有很好判断。但是对于静态库SDK来说，它本身就是代码文件的一个集合，会被加入到App的compile source当中一起被编译，链接。最早的方案是通过对SDK的进行扫描，获得所有的符号集合，通过筛选符号是否在符合集合中判断堆栈里的函数是否是SDK的函数。</p>
<p>前提概念：</p>
<p>Xcode的静态库：</p>
<p>由于Xcode编译源代码文件是按照compile source里顺序编译并链接的，并且是静态链接的。当整个SDK被添加到应用里的时候，相对于起始地址存在一个偏移量m，SDK的第一个符号symbol1的地址为addr1,第二个符号的地址为addr2,symbolN的地址为addrN,所有符号直接的地址偏差是固定的，也就是SDK的符号的地址范围为addr1-&gt;addrN，这样就可以在SDK的组件前后分别加上2个.c文件，获取自己的地址，这样就可以拿到SDK所属代码区间，在APM筛选过程中判断函数地址是否在SDK的范围内，即可筛选出是否为SDK的崩溃。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/" class="post-title-link" itemprop="url">并发编程 - Context</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-19 14:36:52 / Modified: 15:14:22" itemprop="dateCreated datePublished" datetime="2021-12-19T14:36:52+08:00">2021-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发编程-上下文Context"><a href="#并发编程-上下文Context" class="headerlink" title="并发编程 - 上下文Context"></a>并发编程 - 上下文Context</h1><h2 id="Context的作用和使用"><a href="#Context的作用和使用" class="headerlink" title="Context的作用和使用"></a>Context的作用和使用</h2><p>上下文 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。</p>
<p>该接口有4个需要实现的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>) <span class="comment">//返回context.Context被取消的时间</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//返回一个channel，会在工作完成或context被取消后关闭，重复调用返回同一个Channel</span></span><br><span class="line">	Err() error <span class="comment">//被取消 - Canceled错误 超时 - DeadlineExceeded</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; <span class="comment">//获取键对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的最大作用。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj50vvo7hj30xc0aa0tb.jpg" alt="golang-context-usage"></p>
<p>Go 服务的每一个请求都是通过单独的 Goroutine 处理的，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务，如上图所示，对于同一个请求可能会创建多个Goroutine，需要使用Context.context在Goroutine直接同步特定数据，取消信号以及处理请求的截止日期。</p>
<p>当上层的Goroutine因为某些原因执行失败时，使用context.Context就可以在下层及时停掉无用的工作以减少额外资源的消耗</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;handle&quot;</span>,ctx.Err())</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">		fmt.Println(<span class="string">&quot;process request with&quot;</span>,duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(),<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> handle(ctx,<span class="number">500</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>,ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle处理时间为500ms</span></span><br><span class="line">process request with <span class="number">500</span>ms</span><br><span class="line">main context deadline exceeded</span><br><span class="line"><span class="comment">//handle处理时间为1500ms</span></span><br><span class="line">handle context deadline exceeded</span><br><span class="line">main context deadline exceeded</span><br></pre></td></tr></table></figure>

<p>多个Goroutine同时订阅ctx.Done()管道中的消息，一旦收到取消信号就立刻停止当前执行的工作</p>
<h2 id="默认上下文"><a href="#默认上下文" class="headerlink" title="默认上下文"></a>默认上下文</h2><p>context里最常用的方法是context.Background, context.TODO，这两个方法都会返回预先初始化好的私有变量backgroud和todo，这两个变量都是通过new(emptyCtx)初始化，即全为空实现的context.Context</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a> 是上下文的默认值，所有其他的上下文都应该从它衍生出来；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.TODO"><code>context.TODO</code></a> 应该仅在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a> 作为起始的上下文向下传递。</p>
<h2 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithCancel"><code>context.WithCancel</code></a> 函数能够从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<p>除了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithCancel"><code>context.WithCancel</code></a> 之外，<a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的另外两个函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithDeadline"><code>context.WithDeadline</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithTimeout"><code>context.WithTimeout</code></a> 也都能创建可以被取消的计时器上下文 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.timerCtx"><code>context.timerCtx</code></a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj5x724t9j30xc0aawf3.jpg" alt="golang-parent-cancel-context"></p>
<h2 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h2><p>如何使用上下文传值:<a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.WithValue"><code>context.WithValue</code></a> 能从父上下文中创建一个子上下文，传值的子上下文使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx"><code>context.valueCtx</code></a> 类型</p>
<p>如果 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx"><code>context.valueCtx</code></a> 中存储的键值对与 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.valueCtx.Value"><code>context.valueCtx.Value</code></a> 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 <code>nil</code> 或者查找到对应的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 语言中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的主要作用还是在多个 Goroutine 组成的树中同步<strong>取消信号</strong>以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 传递请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/13/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/13/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%B0%83%E5%BA%A6%E5%99%A8/" class="post-title-link" itemprop="url">Go并发编程 - 调度器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-13 00:32:29" itemprop="dateCreated datePublished" datetime="2021-12-13T00:32:29+08:00">2021-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-19 15:55:13" itemprop="dateModified" datetime="2021-12-19T15:55:13+08:00">2021-12-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><h2 id="调度器的由来"><a href="#调度器的由来" class="headerlink" title="调度器的由来"></a>调度器的由来</h2><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存。</p>
<p>后来发现，线程可以分为 “内核态 “线程和” 用户态 “线程。一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”。</p>
<h3 id="协程与线程的映射关系"><a href="#协程与线程的映射关系" class="headerlink" title="协程与线程的映射关系"></a>协程与线程的映射关系</h3><p>N:1 -&gt; 一个进程的所有协程都绑定到一个线程了</p>
<p>1:1 -&gt; 协程的管理由CPU完成，成本过高</p>
<p>M:N: 比较合适</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbl2jjhosj31020u0gop.jpg" alt="img"></p>
<h2 id="调度器发展"><a href="#调度器发展" class="headerlink" title="调度器发展"></a>调度器发展</h2><h3 id="单线程调度器"><a href="#单线程调度器" class="headerlink" title="单线程调度器"></a>单线程调度器</h3><p>只包含G，M</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	G* gp;</span><br><span class="line">	lock(&amp;sched);<span class="comment">//获取调度器的全局锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(gosave(&amp;m-&gt;sched))&#123; <span class="comment">//gosave保存栈寄存器和程序计数器</span></span><br><span class="line">		lock(&amp;sched);</span><br><span class="line">		gp = m-&gt;curg;</span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;</span><br><span class="line">		<span class="keyword">case</span> Grunnable:</span><br><span class="line">		<span class="keyword">case</span> Grunning:</span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">		notewakeup(&amp;gp-&gt;stopped);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp = nextgandunlock(); <span class="comment">//获取下一个需要运行的Goroutine并解锁调度器</span></span><br><span class="line">	noteclear(&amp;gp-&gt;stopped);</span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp; <span class="comment">//修改全局线程上要执行的Goroutine为gp</span></span><br><span class="line">	g = gp;</span><br><span class="line">	gogo(&amp;gp-&gt;sched);<span class="comment">//调用gogo运行最新的Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程调度器"><a href="#多线程调度器" class="headerlink" title="多线程调度器"></a>多线程调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(G *gp)</span> </span>&#123;</span><br><span class="line">	schedlock();</span><br><span class="line">	<span class="keyword">if</span>(gp != nil) &#123;</span><br><span class="line">		gp-&gt;m = nil;</span><br><span class="line">		uint32 v = runtime·xadd(&amp;runtime·sched.atomic, <span class="number">-1</span>&lt;&lt;mcpuShift);</span><br><span class="line">		<span class="keyword">if</span>(atomic_mcpu(v) &gt; maxgomaxprocs)</span><br><span class="line">			runtime·<span class="keyword">throw</span>(<span class="string">&quot;negative mcpu in scheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(gp-&gt;status)&#123;</span><br><span class="line">		<span class="keyword">case</span> Grunning:</span><br><span class="line">			gp-&gt;status = Grunnable;</span><br><span class="line">			gput(gp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ...:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	gp = nextgandunlock();</span><br><span class="line">	gp-&gt;status = Grunning;</span><br><span class="line">	m-&gt;curg = gp;</span><br><span class="line">	gp-&gt;m = m;</span><br><span class="line">	runtime·gogo(&amp;gp-&gt;sched, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务窃取调度器"><a href="#任务窃取调度器" class="headerlink" title="任务窃取调度器"></a>任务窃取调度器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    G *gp;</span><br><span class="line"> top:</span><br><span class="line">    <span class="keyword">if</span>(runtime·gcwaiting) &#123;<span class="comment">//如果当前运行时在等待垃圾回收，则调用gcstopm</span></span><br><span class="line">        gcstopm();</span><br><span class="line">        <span class="keyword">goto</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//调用runqget和findrunnable从本地或全局的运行队列获取待执行的Goroutine</span></span><br><span class="line">    gp = runqget(m-&gt;p);<span class="comment">//本地</span></span><br><span class="line">    <span class="keyword">if</span>(gp == nil)</span><br><span class="line">        gp = findrunnable();<span class="comment">//全局获取，会触发工作窃取，从其他处理器的队列中随机获取Goroutine</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    execute(gp);<span class="comment">//调用execute在当前线程M上运行Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在G-M模型基础上引入了P</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> P &#123;</span><br><span class="line">	Lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32</span>	status;</span><br><span class="line">	P*	link;</span><br><span class="line">	<span class="keyword">uint32</span>	tick;</span><br><span class="line">	M*	m;</span><br><span class="line">	MCache*	mcache;</span><br><span class="line"></span><br><span class="line">	G**	runq;</span><br><span class="line">	<span class="keyword">int32</span>	runqhead;</span><br><span class="line">	<span class="keyword">int32</span>	runqtail;</span><br><span class="line">	<span class="keyword">int32</span>	runqsize;</span><br><span class="line"></span><br><span class="line">	G*	gfree;</span><br><span class="line">	<span class="keyword">int32</span>	gfreecnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj6qv3mq0j30xc0bemxg.jpg" alt="golang-gmp"></p>
<p>处理器持有一个由可运行的 Goroutine 组成的运行队列 <code>runq</code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。</p>
<h3 id="抢占式调度器"><a href="#抢占式调度器" class="headerlink" title="抢占式调度器"></a>抢占式调度器</h3><p>对于非抢占式的调度器饥饿问题很严重</p>
<h4 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h4><p>存在无法被抢占的边缘情况</p>
<p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。</p>
<p><strong>原理：</strong></p>
<ol>
<li>编译器会在调用函数前插入 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a>；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li>
<li>当发生函数调用时，可能会执行编译器插入的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.morestack</code></a> 函数，它调用的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/1e112cd59f560129f4dca5e9af7c3cbc445850b6/src/pkg/runtime/stack.c#L192"><code>runtime.newstack</code></a> 会检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li>
<li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li>
</ol>
<h4 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h4><ol>
<li>程序启动时，在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L494"><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</li>
<li>在触发垃圾回收的栈扫描时会调用<code>runtime.suspendG</code>挂起 Goroutine，该函数会执行下面的逻辑：<ol>
<li>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 触发抢占；</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/67f0f83216930e053441500e2b28c3fa2b667581/src/runtime/signal_unix.go#L346"><code>runtime.preemptM</code></a> 会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/8e0be05ec7c369387c0ed3c9cf37968c6d3afbbd/src/runtime/os_linux.go#L483"><code>runtime.signalM</code></a> 向线程发送信号 <code>SIGURG</code>；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/62e53b79227dafc6afcd92240c89acb8c0e1dd56/src/runtime/signal_unix.go#L326"><code>runtime.doSigPreempt</code></a> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/7955ecebfc85851d43913f9358fa5f6a7bbb7c59/src/runtime/signal_386.go#L69"><code>runtime.sigctxt.pushCall</code></a> 会修改寄存器并在程序回到用户态时执行 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a>；</li>
<li>汇编指令 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/cdb7fd6b06937aa38a7a4921f567697144448073/src/runtime/preempt_386.s#L6"><code>runtime.asyncPreempt</code></a> 会调用运行时函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/dcdee153cd61de47d0cabd6729a17673536b0418/src/runtime/preempt.go#L302"><code>runtime.asyncPreempt2</code></a> 会调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a>；</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/64c22b70bf00e15615bb17c29f808b55bc339682/src/runtime/proc.go#L2739"><code>runtime.preemptPark</code></a> 会修改当前 Goroutine 的状态到 <code>_Gpreempted</code> 并调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/8d7be1e3c9a98191f8c900087025c5e78b73d962/src/runtime/proc.go#L2482"><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能</p>
<h2 id="Go协程goroutine"><a href="#Go协程goroutine" class="headerlink" title="Go协程goroutine"></a>Go协程goroutine</h2><p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。</p>
<p>Goroutine 特点：</p>
<ul>
<li>占用内存更小（几 kb）</li>
<li>调度更灵活 (runtime 调度)</li>
</ul>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>符号含义： G -&gt; goroutine P -&gt; processor M-&gt;thread</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxbl71yyqej30sg0lcdhh.jpg" alt="img"></p>
<ul>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<h4 id="P和M的个数问题"><a href="#P和M的个数问题" class="headerlink" title="P和M的个数问题"></a>P和M的个数问题</h4><p>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</p>
<p>P:</p>
<p>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行</p>
<p>M:</p>
<ul>
<li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li>
<li>一个 M 阻塞了，会创建新的 M。</li>
</ul>
<h4 id="P和M何时被创建"><a href="#P和M何时被创建" class="headerlink" title="P和M何时被创建"></a>P和M何时被创建</h4><p>1、P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p>2、M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p>
<h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><ol>
<li><p>复用线程：</p>
<p>work stealing 机制:当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p>
<p>hand off 机制:当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p>
</li>
<li><p>利用并行：</p>
<p>GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。</p>
</li>
<li><p>抢占：</p>
<p>在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。</p>
</li>
<li><p>全局G队列：</p>
<p>在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。</p>
</li>
</ol>
<h3 id="调度器的调度流程"><a href="#调度器的调度流程" class="headerlink" title="调度器的调度流程"></a>调度器的调度流程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxblfko443j30yg0jewgb.jpg" alt="img"></p>
<p> 1、我们通过 go func () 来创建一个 goroutine；</p>
<p> 2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p>
<p> 3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p>
<p> 4、一个 M 调度 G 执行的过程是一个循环机制；</p>
<p> 5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p>
<p> 6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxblhrrhddj30c70o8gmg.jpg" alt="img"></p>
<p>M0</p>
<p>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</p>
<p>G0</p>
<p>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也会经历如上图所示的过程：</p>
<p>1.runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</p>
<p>2.调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。</p>
<p>3.示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。</p>
<p>4.启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</p>
<p>5.G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</p>
<p>6.M 运行 G</p>
<p>7.G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</p>
<h3 id="GMP数据查看的工具"><a href="#GMP数据查看的工具" class="headerlink" title="GMP数据查看的工具"></a>GMP数据查看的工具</h3><ol>
<li>go tool trace</li>
<li>Debug trace</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/10/how-to-read-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/10/how-to-read-source-code/" class="post-title-link" itemprop="url">how to read source code</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-10 14:31:00" itemprop="dateCreated datePublished" datetime="2021-12-10T14:31:00+08:00">2021-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-27 15:27:09" itemprop="dateModified" datetime="2022-01-27T15:27:09+08:00">2022-01-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="怎样阅读源码"><a href="#怎样阅读源码" class="headerlink" title="怎样阅读源码"></a>怎样阅读源码</h1><h2 id="怎样阅读源码-1"><a href="#怎样阅读源码-1" class="headerlink" title="怎样阅读源码"></a>怎样阅读源码</h2><p>focus on code which either does something that I want to replicate the style of in the future, or which deepens my knowledge of code I use daily</p>
<p>find a high-level abstraction as a starting point and then gradually dig deeper into the internals</p>
<p> make notes in OneNote as I study the code, describing the flow and how the code works</p>
<p>This process is less about having a reference, although that can be useful, than it is about embedding the knowledge into my memory. By describing it in writing, I find that it sticks with me much longer</p>
<p>Navigating code and forming a mental picture of the logical flow is a handy skill. If you can learn this through reading code, it’ll pay dividends when you’re next trying to fix a critical bug under pressure.</p>
<p>Once I have an overview formed the next step is to go deeper. For this, I tend to clone the repository so that I can bring it into an IDE or VS Code.</p>
<p> I like to think about how I’d have chosen to approach a problem and contrast it with the actual implementation。Is the author’s approach better or more efficient? Should I file it away for when I next face a similar requirement?</p>
<p>Often the code may use APIs that I’ve never discovered when writing code.I study the description and method signature(s) to understand their designed use. This extends my code vocabulary.</p>
<p>I find tricks and shortcuts to save time when navigating the code</p>
<h2 id="不了解源码怎么办"><a href="#不了解源码怎么办" class="headerlink" title="不了解源码怎么办"></a>不了解源码怎么办</h2><p>You want to expose yourself to new APIs or new syntax in the code which you read so that you further your own code vocabulary.</p>
<p>Try to break things down into smaller chunks to work through in your head. What is the code doing and also why has it been written that way? Has the author used an approach to solving something you had not previously considered? As you come up against language syntax or keywords you don’t understand, stop and search for the documentation. Armed with an actual use case, often the documentation will make sense in the context you are approaching it from.</p>
<p>Similarly, when you encounter framework APIs which you have never used before, visit the code documentation if there is any.</p>
<h2 id="如何打造自己的技术体系，如何学习一个新的技术"><a href="#如何打造自己的技术体系，如何学习一个新的技术" class="headerlink" title="如何打造自己的技术体系，如何学习一个新的技术"></a>如何打造自己的技术体系，如何学习一个新的技术</h2><h2 id="体系化：目标制定与执行"><a href="#体系化：目标制定与执行" class="headerlink" title="体系化：目标制定与执行"></a>体系化：目标制定与执行</h2><ol>
<li>该技术能够解决什么问题，可以提升哪些能力？</li>
<li>短期目标和长期目标是什么？</li>
<li>我需要做哪些事情可以实现目标？</li>
</ol>
<p>首先可以通过官方文档，博客等渠道快速了解一门技术的概貌，当决定深入研究这门技术时，首先需要制定自己的学习计划，比如应该知道有哪些重要的概念，特性需要去深入学习，然后制定具体的学习计划表，在学习过程中，当理解更加深入时，会发现更多需要去挖掘的知识点，然后再去调整和完善学习计划。</p>
<p>途径：项目实战，源码学习，写博客，参加社区都是高效的办法。需要定时回顾相关的计划是否有效和阶段性的检验。</p>
<h2 id="思考和总结"><a href="#思考和总结" class="headerlink" title="思考和总结"></a>思考和总结</h2><p>学习一门技术时，除了使用层面上，还需要知道该技术能够解决什么问题，相比于同领域的其他技术有什么优缺点。可以从技术原理中去了解问题的本质，然后找到问题的解决防范，让结果更有说服力。同时从优秀的开源项目中去挖掘技术原理也是非常有帮助的。</p>
<p>同时多维度的思考，不停留于表明，一个技术问题需要考虑多种因素，需要将方方面面考虑得非常细致。同时对于别人的观点和他人的方案进行学习，总结出自己独特的思考。</p>
<h2 id="分享和交流"><a href="#分享和交流" class="headerlink" title="分享和交流"></a>分享和交流</h2><p>交流和分享时检验自己的学习成果的有效方法，技术分享，书籍，博客都是沉淀知识的途径。交流与分析可以让我们梳理自己的知识体系，牢固自己的知识，让别人检验自己对知识的理解是否正确。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81/" class="post-title-link" itemprop="url">同步原语与锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-09 01:03:41" itemprop="dateCreated datePublished" datetime="2021-12-09T01:03:41+08:00">2021-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-20 02:12:01" itemprop="dateModified" datetime="2021-12-20T02:12:01+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="同步原语与锁"><a href="#同步原语与锁" class="headerlink" title="同步原语与锁"></a>同步原语与锁</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj839w6zaj30ur0r1n0j.jpg" alt="同步原语与锁"></p>
<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">//互斥锁的状态</span></span><br><span class="line">	sema  <span class="keyword">uint32</span> <span class="comment">//控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjbw1caljj30xc05a0sy.jpg" alt="golang-mutex-state"></p>
<p>在默认情况下，互斥锁的所有状态位都是 0，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<p><strong>正常模式和饥饿模式</strong></p>
<ul>
<li><p>正常模式：正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』</p>
</li>
<li><p>饥饿模式：饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式</p>
</li>
<li><p>对比：正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时</p>
</li>
</ul>
<p><strong>加锁与解锁</strong>:</p>
<p><strong>前提条件:CAS操作的实现：</strong></p>
<p>通过CPU提供的原子性指令实现了CAS</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="keyword">uint32</span>, old, <span class="built_in">new</span> <span class="keyword">uint32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line">TEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, $<span class="number">0</span><span class="number">-25</span></span><br><span class="line"> MOVQ ptr+<span class="number">0</span>(FP), BX</span><br><span class="line"> MOVQ old+<span class="number">8</span>(FP), AX</span><br><span class="line"> MOVQ <span class="built_in">new</span>+<span class="number">16</span>(FP), CX</span><br><span class="line"> LOCK  <span class="comment">//锁住总线保证多次内存操作的原子性</span></span><br><span class="line"> CMPXCHGQ CX, <span class="number">0</span>(BX) <span class="comment">//cmpxchg %cx, %bx；如果AX与BX相等，则CX送BX且ZF置1；否则BX送CX，且ZF清0</span></span><br><span class="line"> SETEQ ret+<span class="number">24</span>(FP)</span><br><span class="line"> RET</span><br></pre></td></tr></table></figure>

<ol>
<li><ol>
<li>拿AX(old) 与 BX(共享数据ptr) 做对比。</li>
<li>相等，则修改BX(共享数据ptr)，状态码ZX设置为 1 。</li>
<li>不相等，则将CX(new)置为目前BX(共享数据ptr)的值， 状态码ZX设置为 0</li>
</ol>
</li>
</ol>
<h4 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;<span class="comment">//当锁的状态是 0 时，将 mutexLocked 位置成 1</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.lockSlow()<span class="comment">//尝试通过自旋（Spinnig）等方式等待锁的释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 判断当前 Goroutine 能否进入自旋；</span></span><br><span class="line"><span class="comment">//2. 通过自旋等待互斥锁的释放；</span></span><br><span class="line"><span class="comment">//3. 计算互斥锁的最新状态；</span></span><br><span class="line"><span class="comment">//4. 更新互斥锁的状态并获取锁；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//进入自旋会调用doSpin并执行30次PAUSE指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	MOVL	cycles+<span class="number">0</span>(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$<span class="number">1</span>, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p><strong>自旋会使得当前进程一直保存CPU的占用，持续检查某个条件是否为真</strong>。在多核CPU上，自旋可以避免线程的上下文切换，在自旋时间较短的情况下会有较大收益。</p>
<p>Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li><code>runtime.sync_runtime_canSpin</code>需要返回ture<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
</li>
</ol>
<p><strong>处理了自旋相关的逻辑后，互斥锁会根据上下文计算当前互斥锁状态</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//几个不同的条件分别会更新 state 字段中存储的不同信息 — mutexLocked、mutexStarving、mutexWoken 和 mutexWaiterShift</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">	<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算了互斥锁的状态后，会使用CAS更新状态</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁</span></span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">  <span class="comment">//如果没有通过 CAS 获得锁，会调用 runtime.sync_runtime_SemacquireMutex 通过信号量保证资源不会被两个 Goroutine 获取。</span></span><br><span class="line">  <span class="comment">//runtime.sync_runtime_SemacquireMutex 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，sync.Mutex.Lock 的剩余代码也会继续执行</span></span><br><span class="line">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">				&#125;</span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先查看是否通过CAS获得了锁，没有则会通过信号量保证资源不会被多个Goroutine获取</li>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ol>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//首先尝试使用AddInt32快速解锁</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</p>
</li>
<li><p>如果该函数返回的新状态不等于 0，这段代码会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.unlockSlow"><code>sync.Mutex.unlockSlow</code></a> 开始慢速解锁：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;<span class="comment">//校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序</span></span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">//互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">        <span class="comment">//存在等待者，则会通过runtime_Semrelease唤醒等待者</span></span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">    <span class="comment">//直接调用runtime_Semrelease将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h2 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h2><p>结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex <span class="comment">//Mutex锁</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">//写等待读</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">//读等待写</span></span><br><span class="line">	readerCount <span class="keyword">int32</span> <span class="comment">//正在执行的读操作</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span> <span class="comment">//写操作被阻塞时等待的读操作的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<ul>
<li><p>写操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code>sync.RWMutex.Lock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 方法；</p>
</li>
<li><p>读操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code>sync.RWMutex.RLock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 方法；</p>
</li>
</ul>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁:"></a>写锁:</h4><p>获取写锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.w.Lock() <span class="comment">//获取Mutex锁</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders <span class="comment">//阻塞后续的读操作，readerConnt设置为负数</span></span><br><span class="line">  <span class="comment">//仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 runtime.sync_runtime_SemacquireMutex 进入休眠状态等待所有读锁所有者执行结束后释放 writerSem 信号量将当前协程唤醒</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放写锁:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders) <span class="comment">//将readerCount变成正数释放读锁</span></span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;<span class="comment">//for 循环释放所有因为获取读锁而陷入等待的 Goroutine</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	rw.w.Unlock()<span class="comment">//释放Mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』</p>
<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁:"></a>读锁:</h4><p>读锁加锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 runtime.sync_runtime_SemacquireMutex 陷入休眠等待锁的释放；</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//非负数则成功返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读锁释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//减少readerCount数</span></span><br><span class="line">  <span class="comment">//返回值&gt;=0读锁解锁成功</span></span><br><span class="line">  <span class="comment">//返回值&lt;0有正在执行的写操作，执行rw.rUnlockSlow(r)</span></span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//减少获取锁的写操作等待的读操作数 readerWait 并在所有读操作都被释放之后触发写操作的信号量 writerSem，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine</span></span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>读锁和写锁的关系：</p>
<ul>
<li>调用<code>sync.RWMutex.Lock</code>尝试获取写锁时；<ul>
<li>每次 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerCount</code> 其减一，当它归零时该 Goroutine 会获得写锁；</li>
<li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li>
</ul>
</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">    &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<p><strong>结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">//在编译期间检查，保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span> <span class="comment">//存储着状态和信号量 私有方法 sync.WaitGroup.state 能够帮我们从 state1 字段中取出它的状态和信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjnnwqwptj30xc08cq3d.jpg" alt="golang-waitgroup-state"></p>
<p><strong>接口：</strong></p>
<ol>
<li>Add +1</li>
<li>Wait 等待group事件完成</li>
<li>Done -1</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	w := <span class="keyword">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">//唤醒等待状态的Goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 runtime.sync_runtime_Semacquire 陷入睡眠</span></span><br><span class="line"><span class="comment">//当 sync.WaitGroup 的计数器归零时，陷入睡眠状态的 Goroutine 会被唤醒，上述方法也会立刻返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 必须在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 只是对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p> <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。通常可以用于实现单例：</p>
<p>在运行如下所示的代码时，我们会看到如下所示的运行结果:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := &amp;sync.Once&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">only once</span><br></pre></td></tr></table></figure>

<p><strong>结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">uint32</span> <span class="comment">//标识代码块是否执行过,保证函数不会被执行第二次</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">//传入的参数已经执行过了，会直接返回，没有则会调用doSlow执行传入的函数</span></span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock() <span class="comment">//获取互斥锁</span></span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>) <span class="comment">//将成员变量更新为1</span></span><br><span class="line">		f() <span class="comment">//执行传入的无入参函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>作为用于保证函数执行次数的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法<strong>传入不同的函数只会执行第一次调传入的函数</strong>；</li>
</ul>
<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><p>条件变量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a>，它可以让一组的 Goroutine 都在满足特定条件时被唤醒。每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(ch, os.Interrupt)</span><br><span class="line">	&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">listen</span><br><span class="line">...</span><br><span class="line">listen</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情</span></span><br><span class="line"><span class="comment">//10 个 Goroutine 通过 sync.Cond.Wait 等待特定条件的满足；</span></span><br><span class="line"><span class="comment">//1 个 Goroutine 会调用 sync.Cond.Broadcast 唤醒所有陷入等待的 Goroutine；</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体:"></a>结构体:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy  noCopy <span class="comment">//保证结构体不会在编译期间拷贝</span></span><br><span class="line">	L       Locker <span class="comment">//用于保护内部的 notify 字段，Locker接口类型的变量；</span></span><br><span class="line">	notify  notifyList <span class="comment">//一个 Goroutine 的链表，它是实现同步机制的核心结构</span></span><br><span class="line">	checker copyChecker <span class="comment">//用于禁止运行期间发生的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait <span class="keyword">uint32</span> <span class="comment">//正在等待的Goroutine索引</span></span><br><span class="line">	notify <span class="keyword">uint32</span> <span class="comment">//已经通知到的Goroutine索引</span></span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">	head *sudog <span class="comment">//链表头</span></span><br><span class="line">	tail *sudog <span class="comment">//链表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><ol>
<li><p>sync.Cond.Wait 将当前 Goroutine 陷入休眠状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify) <span class="comment">// 将等待加数器加一并解锁</span></span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t) <span class="comment">// 等待其他Goroutine的唤醒并加锁</span></span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)<span class="comment">//将当前的Goroutine陷入休眠</span></span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sync.Cond.Signal唤醒队列最前面的Goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从notifyList链表中找到满足条件的Goroutine并唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	t := l.notify</span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			readyWithTime(s, <span class="number">4</span>) <span class="comment">//唤醒</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sync.Cond.Broadcast唤醒队列中全部的Goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次通过readWithTime唤醒链表中的Goroutine</span></span><br><span class="line"><span class="comment">//Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的可能 Goroutine 需要等待调度器的调度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>在一般情况下，我们都会先调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 或者 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 <code>for &#123;&#125;</code> 进行忙碌等待相比，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 能够让出处理器的使用权，提高 CPU 的利用率。使用时我们也需要注意以下问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-05 21:32:34" itemprop="dateCreated datePublished" datetime="2021-12-05T21:32:34+08:00">2021-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-20 20:53:10" itemprop="dateModified" datetime="2021-12-20T20:53:10+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6k42uj67j31260pttdv.jpg" alt="垃圾回收器"></p>
<p>对于一门语言来说，除了需要负责堆内存的分配以外，还需要负责回收不再使用的对象和内存空间。</p>
<h2 id="垃圾收集器的原理"><a href="#垃圾收集器的原理" class="headerlink" title="垃圾收集器的原理"></a>垃圾收集器的原理</h2><p>通常来说管理内存的方式有两种，手动的方式和自动的方式，C,C++等是手动的方式管理的，Java，C#，Objective-C，Go是通过自动管理的，其中Objective-C是通过引用计数，半自动的方式管理的。</p>
<p>在GO语言中，用户程序是通过内存分配器在堆上申请内存，通过垃圾收集器来负责回收堆上的内存。</p>
<p>垃圾回收的基本算法：</p>
<p>GO的垃圾回收器是使用的三色标记清除算法，无分代，不整理，并发。</p>
<p>分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象（新生代）上，而非频繁的检查所有的对象。但是对于Go来说，Go的编译器会通过逃逸分析将大部分的新生对象存储到栈上，只有需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h4 id="串行标记清扫："><a href="#串行标记清扫：" class="headerlink" title="串行标记清扫："></a>串行标记清扫：</h4><p>回收器开始执行的时候，会将并发的赋值器挂起（即Stop The World）。</p>
<ol>
<li>挂起赋值器，stop the world</li>
<li>从根集合（寄存器，执行栈，全局变量）开始遍历对象图，标记根对象可达的每一个对象</li>
<li>清扫回收时，会检查堆中的每一个对象，将所有未标记的对象当做垃圾进行回收</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记追踪：从根集合（寄存器、执行栈、全局变量）开始遍历对象图，标记遇到的每个对象；</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mark</span><span class="params">()</span></span> &#123;</span><br><span class="line">    worklist.Init()                       <span class="comment">// 初始化标记 work 列表</span></span><br><span class="line">    <span class="keyword">for</span> root := <span class="keyword">range</span> roots &#123;             <span class="comment">// 从根开始扫描</span></span><br><span class="line">        ref := *root</span><br><span class="line">        <span class="keyword">if</span> ref != <span class="literal">nil</span> &amp;&amp; !isMarked(ref) &#123; <span class="comment">// 标记每个遇到的对象</span></span><br><span class="line">            setMarked(ref)</span><br><span class="line">            worklist.Add(ref)</span><br><span class="line">            <span class="keyword">for</span> !worklist.Empty() &#123;</span><br><span class="line">                ref := worklist.Remove()  <span class="comment">// ref 已经标记过</span></span><br><span class="line">                <span class="keyword">for</span> fld := <span class="keyword">range</span> Pointers(ref) &#123;</span><br><span class="line">                    child := *fld</span><br><span class="line">                    <span class="keyword">if</span> child != <span class="literal">nil</span> &amp;&amp; !isMarked(child) &#123;</span><br><span class="line">                        setMarked(child)</span><br><span class="line">                        worlist.Add(child)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清扫回收：检查堆中每一个对象，将所有未标记的对象当做垃圾进行回收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查堆区间内所有的对象</span></span><br><span class="line">    <span class="keyword">for</span> scan := worklist.Start(); scan &lt; worklist.End(); scan = scan.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> isMarked(scan) &#123;</span><br><span class="line">            unsetMarked(scan)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            free(scan) <span class="comment">// 将未标记的对象释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3azdn4wrj31a90u0dj4.jpg" alt="img"></p>
<h3 id="并发标记清扫"><a href="#并发标记清扫" class="headerlink" title="并发标记清扫"></a>并发标记清扫</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markSome</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> worklist.empty() &#123;       <span class="comment">// 初始化回收过程</span></span><br><span class="line">        scan(Roots)             <span class="comment">// 赋值器不持有任何白色对象的引用</span></span><br><span class="line">        <span class="keyword">if</span> worklist.empty() &#123;   <span class="comment">// 此时灰色对象已经全部处理完毕</span></span><br><span class="line">            sweep()             <span class="comment">// 标记结束，立即清扫</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收过程尚未完成，后续过程仍需标记</span></span><br><span class="line">    ref = worklist.remove()</span><br><span class="line">    scan(ref)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scan</span><span class="params">(ref <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> fld := <span class="keyword">range</span> Pointers(ref) &#123;</span><br><span class="line">        child := *fld</span><br><span class="line">        <span class="keyword">if</span> child != <span class="literal">nil</span> &#123;</span><br><span class="line">            shade(child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shade</span><span class="params">(ref <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !isMarked(ref) &#123;</span><br><span class="line">        setMarked(ref)</span><br><span class="line">        worklist.add(ref)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在这个过程中，回收器会首先扫描 worklist，而后对根集合进行扫描并重新建立 worklist。 在根集合扫描过程中赋值器现场被挂起时，扫描完成后则不会再存在白色对象。</span><br><span class="line"><span class="comment">//并发清扫</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发清扫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    collectEnough()</span><br><span class="line">    ref := allocate()</span><br><span class="line">    <span class="keyword">if</span> ref == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ref, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collectEnough</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stopTheWorld()</span><br><span class="line">    <span class="keyword">defer</span> startTheWorld()</span><br><span class="line">    <span class="keyword">for</span> behind() &#123; <span class="comment">// behind() 控制回收工作每次的执行量</span></span><br><span class="line">        <span class="keyword">if</span> !markSome() &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在没有mutator并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于， mutator在回收过程中会并发的更新对象图，从而mutator和回收器可能对对象图的结构产生不同的认知， 这时以一个固定的三色波面作为回收过程前进的边界则不再合理。</span><br></pre></td></tr></table></figure>

<p>垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性</p>
<ol>
<li>mutator修改对象图，导致某一黑色对象引用白色对象；</li>
<li>从灰色对象出发，到达白色对象的、未经访问过的路径被mutator破坏。 只要能够避免其中任何一个条件，则不会出现对象丢失的情况。两个条件都避免，称为强三色不变性，只避免条件1，称为弱三色不变性。</li>
</ol>
<h3 id="mutator屏障技术"><a href="#mutator屏障技术" class="headerlink" title="mutator屏障技术"></a>mutator屏障技术</h3><p>mutator屏障技术即内存屏障，保证代码对内存的操作顺序。不会被CPU乱序执行也不会被编译器优化</p>
<p>三色<strong>标记</strong>法是一种可以并发执行的算法。Collector可以做了一段标记工作后，就让mutator再运行一段。如果在mutator运行期间，一个黑色对象被修改了，比如往一个黑色对象 a 里新存储了一个指针 b，那么把 a 涂成灰色，或者把 b 涂成灰色，就可以了。增量标记的过程中，需要编译器做配合往生成的目标代码中插入读屏障（Read Barrier）和写屏障（Write Barrier）的代码。也就是在程序读写对象的时候，要执行一些逻辑，保证三色的正确性。比如Write Barrier 主要做这样一件事情，<strong>修改原先的写逻辑，当白色节点交由黑色节点引用时， 立刻对被引用节点进行着色，并且着色为”灰色“，并加入到work pool</strong>。因此打开了 Write Barrier 可以保证了三色标记法在并发下安全正确地运行。</p>
<h3 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a>整体实现</h3><ol>
<li><p>什么时候触发下一次GC？</p>
<p>目前触发 GC 的条件使用的是从 Go 1.5 时提出的调步（Pacing）算法，调步算法包含四个部分：</p>
<ol>
<li><p>GC 周期所需的扫描估计器</p>
</li>
<li><p>为用户代码根据堆分配到目标堆大小的时间估计扫描工作量的机制</p>
</li>
<li><p>用户代码为未充分利用 CPU 预算时进行后台扫描的调度程序</p>
</li>
<li><p>GC 触发比率的控制器</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx3ib8z6g4j30uo0nrjsl.jpg" alt="img"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">回收器阶段</th>
<th align="left">说明</th>
<th align="left">mutator状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">清扫终止</td>
<td align="left">为下一个阶段的并发标记做准备工作，启动写屏障</td>
<td align="left">STW</td>
</tr>
<tr>
<td align="left">标记</td>
<td align="left">与mutator并发执行，写屏障处于开启状态</td>
<td align="left">并发</td>
</tr>
<tr>
<td align="left">标记终止</td>
<td align="left">保证一个周期内标记任务完成，停止写屏障</td>
<td align="left">STW</td>
</tr>
<tr>
<td align="left">内存清扫</td>
<td align="left">将需要回收的内存归还到堆中，写屏障处于关闭状态</td>
<td align="left">并发</td>
</tr>
<tr>
<td align="left">内存归还</td>
<td align="left">将过多的内存归还给操作系统，写屏障处于关闭状态</td>
<td align="left">并发</td>
</tr>
</tbody></table>
</li>
<li><p>GC如何标记内存</p>
<p>GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。每个指针被加入到一个 work pool(<code>type gcWork/workbuf struct</code>) 中的队列。后台运行的标记 worker 从这个 work pool 中拿到前面出列的 指针，扫描这个对象然后把在这个对象里找到的指针加入到队列。归功于每一个 span 中的名为 gcmarkBits 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 对象。灰色和黑色在 gcmarkBits 中皆为 1</p>
</li>
<li><p>触发GC的入口</p>
<p>可以调用 runtime.GC来手动的触发 GC。但实际上，触发 GC 的入口一般不会手动调用。正常触发 GC 应该是在申请内存时会调用 <code>runtime.mallocgc</code>或者是 Go 后台的监控线程 sysmon 定时检查调用 <code>runtime.forcegchelper</code></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理 - go栈内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-04 17:56:30" itemprop="dateCreated datePublished" datetime="2021-12-04T17:56:30+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-08 16:50:41" itemprop="dateModified" datetime="2021-12-08T16:50:41+08:00">2021-12-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈空间管理"><a href="#栈空间管理" class="headerlink" title="栈空间管理"></a>栈空间管理</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6iw2lc9sj30hi0bgmxn.jpg" alt="栈"></p>
<h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol>
<li>功能不同：函数调用的参数、返回值以及局部变量都会分配到栈上。</li>
<li>共享性不同：栈是线程私有，堆是共享</li>
<li>栈的空间一般远远小于堆</li>
</ol>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。</p>
<p>栈区的内存由编译器自动分配和释放，其中存储的是函数的入参和局部变量。</p>
<p>总结：Go的栈使用连续栈进行管理，对象或结构体是分配到栈还是堆，由逃逸分析决定，栈是线程私有，Go的栈是以Goroutine作为context，为了高效管理栈，使用了2个寄存器BP,SP来表明其基址和栈顶。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址。BP 和 SP 之间的内存就是当前函数的调用栈。</p>
<p>栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1yjgbzr2j30xj0e6aab.jpg" alt="stack-registers"></p>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><p>创建一个线程时，系统会根据架构不同选择不同的默认栈大小，一般为2~4MB左右，用户程序可以在栈上存储函数参数和局部变量。</p>
<p>对于Go:由于Go设计时以协程实现，所以其再用户态实现Goroutine作为执行上下文。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在手动管理内存的语言中，可以选择将对象或结构体分配到栈或者堆上，但是这样会存在2个问题：</p>
<ul>
<li>不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；</li>
<li>需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；</li>
</ul>
<p>Eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dangling_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 dangling_pointer 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的逃逸分析遵循以下两个不变性：</p>
<ol>
<li>指向栈对象的指针不能存在于堆中；</li>
<li>指向栈对象的指针不能在栈对象回收后存活；</li>
</ol>
<p>Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 <code>new</code>、<code>make</code> 和字面量等方法隐式分配的内存。为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为堆也会被垃圾收集器扫描，所以不会造成内存泄露以及悬挂指针等安全问题。</p>
<p><strong>逃逸分析的实现：</strong></p>
<p>逃逸分析是静态分析的一种，在编译器活动抽象语法树以后，可以通过抽象语法树分析静态的数据流。</p>
<ul>
<li>构建带权重的有向图，其中顶点表示被分配的变量，边表示变量之间的分配关系，权重表示寻址和取地址的次数；</li>
<li>遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么该变量需要分配在堆上；</li>
<li>记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；</li>
</ul>
<h3 id="栈内存空间"><a href="#栈内存空间" class="headerlink" title="栈内存空间"></a>栈内存空间</h3><p>Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多</p>
<p>在1.3版本以后，都是有连续栈，最小栈空间在1.4版本，为2KB</p>
<p>连续栈：</p>
<p>核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。</p>
<p>步骤：</p>
<ol>
<li>在内存空间中分配更大的栈内存空间；</li>
<li>将旧栈中的所有内容复制到新栈中；</li>
<li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li>
<li>销毁并回收旧栈的内存空间；</li>
</ol>
<p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题，即在GC时期合理调整栈的大小。 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。</p>
<h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><h4 id="栈初始化"><a href="#栈初始化" class="headerlink" title="栈初始化"></a>栈初始化</h4><p>运行时使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和线程缓存中的空闲链表分配 32KB 以下的栈内存，使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 和堆内存分配 32KB 以上的栈内存，提高本地分配栈内存的性能。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx263w3xb5j30xc096gma.jpg" alt="stack-memory"></p>
<p>栈空间在运行时中包含两个重要的全局变量，分别是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a>，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：</p>
<p>每一个线程缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 中也都加入了栈缓存减少锁竞争影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackpool [_NumStackOrders]<span class="keyword">struct</span> &#123;</span><br><span class="line">	item stackpoolItem</span><br><span class="line">	_    [cpu.CacheLinePadSize - unsafe.Sizeof(stackpoolItem&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stackpoolItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   mutex</span><br><span class="line">	span mSpanList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackLarge <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock mutex</span><br><span class="line">	free [heapAddrBits - pageShift]mSpanList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的栈内存都是分配到堆上的，运行时初始化会调用<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackinit"><code>runtime.stackinit</code></a> 初始化这些全局变量。</p>
<h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>运行时会在 Goroutine 的初始化函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 中调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配一个大小足够栈内存空间，根据线程缓存和申请栈的大小，该函数会通过三种不同的方法分配栈空间：</p>
<ol>
<li>如果栈空间较小，使用全局栈缓存或者线程缓存上固定大小的空闲链表分配内存；</li>
<li>如果栈空间较大，从全局的大栈缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 中获取内存空间；</li>
<li>如果栈空间较大并且 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 空间不足，在堆上申请一片大小足够内存空间；</li>
</ol>
<h4 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h4><p>编译器会在函数调用中插入运行时检查，检查函数调用当前Goroutine的栈空间是否充足，当需要扩容时，会保存一些栈的信息并调用runtime.newstack创建新栈进行扩容</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newstack"><code>runtime.newstack</code></a> 会先做一些准备工作并检查当前 Goroutine 是否发出了抢占请求。如果当前 Goroutine 不需要被抢占，意味着我们需要新的栈空间来支持函数调用和本地变量的初始化，运行时会先检查目标大小的栈是否会溢出。</p>
<p>如果目标栈的大小没有超出程序的限制，我们会将 Goroutine 切换至 <code>_Gcopystack</code> 状态并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.copystack"><code>runtime.copystack</code></a> 开始栈拷贝。在拷贝栈内存之前，运行时会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配新的栈空间：</p>
<p>分配好以后开始拷贝栈空间</p>
<p>同上的连续栈扩容</p>
<h4 id="栈缩容"><a href="#栈缩容" class="headerlink" title="栈缩容"></a>栈缩容</h4><p>GC时，使用率为1/4时，缩容为之前的一半，也会coptyStack</p>
<h3 id="栈内容扩展"><a href="#栈内容扩展" class="headerlink" title="栈内容扩展"></a>栈内容扩展</h3><h4 id="栈的汇编分析"><a href="#栈的汇编分析" class="headerlink" title="栈的汇编分析"></a>栈的汇编分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = a + b + x;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">.LFB0:</span><br><span class="line">    .file <span class="number">1</span> <span class="string">&quot;call_no_stack.c&quot;</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp             <span class="comment">//rbp入栈 （rsp-8）</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp       <span class="comment">//rsp 赋值给 rbp，这里rsp并没有移动，可能是因为这里是最后一个函数调用，所以不需要移动rsp</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)  <span class="comment">//这里通过rbp来访问栈，将main函数中的实参2放入rbp-20内存</span></span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)  <span class="comment">//这里表示栈空间分配了24字节，猜测：函数中的参数值从栈顶开始存储</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    movb    $<span class="number">1</span>, <span class="number">-5</span>(%rbp)     <span class="comment">//局部变量x入栈，x占用1个字节，相当于x后入栈：栈的地址是向下减少的</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)     <span class="comment">//局部变量c入栈，放在rbp-4处</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">7</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx   </span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %eax, %edx      <span class="comment">//相加操作</span></span><br><span class="line">    movsbl    <span class="number">-5</span>(%rbp), %eax </span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">8</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax  <span class="comment">//将c变量的结果保存到eax寄存器，以便函数返回</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">    popq    %rbp            <span class="comment">//将堆栈pop，此时栈顶保存着调用函数的rbp值，将栈顶元素赋予rbp寄存器（恢复rbp寄存器）</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                     <span class="comment">//跳转回上一层处继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size    foo, .-foo</span><br><span class="line">    .globl    main</span><br><span class="line">    .type    main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">12</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp              <span class="comment">//rbp：64位寄存器——指向栈底，将rbp寄存器内的值入栈-pushq操作会改变rsp的值</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp         <span class="comment">//rsp：64位堆栈指针寄存器——指向栈顶，将rsp值存入rbp寄存器内</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp          <span class="comment">//rsp-16，这里讲栈顶指针向下移动16字节，相当于为main函数预留了16字节的栈空间-保存局部变量包括实参</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">13</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)       <span class="comment">//对应局部变量ret = 0</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">14</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">3</span>, %esi           <span class="comment">//这里直接将实参存入esi寄存器而不是放入堆栈，可加快访问速度</span></span><br><span class="line">    movl    $<span class="number">2</span>, %edi</span><br><span class="line">    call    foo                <span class="comment">//调用foo函数:call指令有另个作用：1，将call指令的下一条指令入栈-并改变rsp 2，修改程序计数器eip，跳转到foo函数的开头执行</span></span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)     <span class="comment">//eax寄存器保存着返回值，这里将eax赋值给rbp-4的位置，也就是ret</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">15</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">16</span> <span class="number">0</span></span><br><span class="line">    leave                     <span class="comment">//leave指令是函数开头的pushq %rbp和movq %rsp,%rbp的逆操作,　　　　　　　　　　　　　　　　　　//有两个作用：1，把rbp赋值给rsp 2,然后把该函数栈栈顶保存的rbp值恢复到rbp寄存器中,同时rsp+4(第二部的操作相当于pop栈顶元素)</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                       <span class="comment">//现在栈顶元素保存的是下一条执行的指令，ret的作用就是pop栈顶元素，并将栈顶元素赋值给程序计数器bip，然后程序跳转回bip所在地址继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size    main, .-main</span><br></pre></td></tr></table></figure>

<ol>
<li>变量存储会按照会根据类型，在汇编的得出其偏移量来操作</li>
<li>只有两个寄存器bp,sp来管理当前栈帧，之前已经入栈的栈帧的相关信息，会存储到其上下文中</li>
</ol>
<h4 id="栈空间对齐"><a href="#栈空间对齐" class="headerlink" title="栈空间对齐"></a>栈空间对齐</h4><p>栈的字节对齐，实际是指栈顶指针必须是16字节的整数倍，栈对齐是为了尽可能少的内存访问周期读取数据，保证性能 - 任何内存分配函数(alloca, malloc, calloc)生成的块的起始地址必须为16的整数倍。大多数函数的栈帧的边界必须为16的整数倍。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>C语言函数栈帧实例：<a target="_blank" rel="noopener" href="https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html">https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/" class="post-title-link" itemprop="url">Go多线程编程2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-28 16:09:04 / Modified: 18:11:35" itemprop="dateCreated datePublished" datetime="2021-11-28T16:09:04+08:00">2021-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go多线程编程"><a href="#Go多线程编程" class="headerlink" title="Go多线程编程"></a>Go多线程编程</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul>
<li>Timer：时间到了，执行只执行1次</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 使用</span><br><span class="line">timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">t2 := &lt;-timer1.C</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 延时</span><br><span class="line">(<span class="number">1</span>)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"> timer3 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"> &lt;-timer3.C</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">&lt;-time.After(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 停止</span><br><span class="line">timer4 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">timer4.Stop()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 重置定时器</span><br><span class="line">timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">timer5.Reset(<span class="number">1</span> * time.Second)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.timer基本使用</span></span><br><span class="line">   <span class="comment">//timer1 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//t1 := time.Now()</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t1:%v\n&quot;, t1)</span></span><br><span class="line">   <span class="comment">//t2 := &lt;-timer1.C</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t2:%v\n&quot;, t2)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.验证timer只能响应1次</span></span><br><span class="line">   <span class="comment">//timer2 := time.NewTimer(time.Second)</span></span><br><span class="line">   <span class="comment">//for &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer2.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;时间到&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.timer实现延时的功能</span></span><br><span class="line">   <span class="comment">//(1)</span></span><br><span class="line">   <span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">   <span class="comment">//(2)</span></span><br><span class="line">   <span class="comment">//timer3 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//&lt;-timer3.C</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line">   <span class="comment">//(3)</span></span><br><span class="line">   <span class="comment">//&lt;-time.After(2*time.Second)</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.停止定时器</span></span><br><span class="line">   <span class="comment">//timer4 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//go func() &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer4.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;定时器执行了&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;()</span></span><br><span class="line">   <span class="comment">//b := timer4.Stop()</span></span><br><span class="line">   <span class="comment">//if b &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;timer4已经关闭&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.重置定时器</span></span><br><span class="line">   timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">   timer5.Reset(<span class="number">1</span> * time.Second)</span><br><span class="line">   fmt.Println(time.Now())</span><br><span class="line">   fmt.Println(&lt;-timer5.C)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ticker：时间到了，多次执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取ticker对象</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;-ticker.C</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(&lt;-ticker.C)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                ticker.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>用法类似与Socket里的select</p>
<p>作用：select关键字，可以同时响应多个通道的操作。</p>
<ul>
<li>select可以同时监听一个或多个channel，直到其中一个channel ready</li>
<li>如果多个channel同时ready，则随机选择一个执行</li>
<li>可以用于判断管道是否存满</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">       <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">       <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断管道是否存满</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发安全与锁"><a href="#并发安全与锁" class="headerlink" title="并发安全与锁"></a>并发安全与锁</h2><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>注意：sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>实现单例和资源只加载一次的方法</p>
<p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<p>sync.Once只有一个Do方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>map不是线程安全的，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<p><strong>猜测实现类似于Java中的ConcurrentHashMap，待研究</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>
<p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
<h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func LoadInt32(addr *int32) (val int32) func LoadInt64(addr <code>*int64</code>) (val int64)<br>func LoadUint32(addr<code>*uint32</code>) (val uint32)<br>func LoadUint64(addr<code>*uint64</code>) (val uint64)<br>func LoadUintptr(addr<code>*uintptr</code>) (val uintptr)<br>func LoadPointer(addr<code>*unsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td>func StoreInt32(addr <code>*int32</code>, val int32) func StoreInt64(addr <code>*int64</code>, val int64) func StoreUint32(addr <code>*uint32</code>, val uint32) func StoreUint64(addr <code>*uint64</code>, val uint64) func StoreUintptr(addr <code>*uintptr</code>, val uintptr) func StorePointer(addr <code>*unsafe.Pointer</code>, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td>func AddInt32(addr <code>*int32</code>, delta int32) (new int32) func AddInt64(addr <code>*int64</code>, delta int64) (new int64) func AddUint32(addr <code>*uint32</code>, delta uint32) (new uint32) func AddUint64(addr <code>*uint64</code>, delta uint64) (new uint64) func AddUintptr(addr <code>*uintptr</code>, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td>func SwapInt32(addr <code>*int32</code>, new int32) (old int32) func SwapInt64(addr <code>*int64</code>, new int64) (old int64) func SwapUint32(addr <code>*uint32</code>, new uint32) (old uint32) func SwapUint64(addr <code>*uint64</code>, new uint64) (old uint64) func SwapUintptr(addr <code>*uintptr</code>, new uintptr) (old uintptr) func SwapPointer(addr <code>*unsafe.Pointer</code>, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td>func CompareAndSwapInt32(addr <code>*int32</code>, old, new int32) (swapped bool) func CompareAndSwapInt64(addr <code>*int64</code>, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <code>*uint32</code>, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr <code>*uint64</code>, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <code>*uintptr</code>, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr <code>*unsafe.Pointer</code>, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody></table>
<h3 id="原子操作和互斥锁的性能比较"><a href="#原子操作和互斥锁的性能比较" class="headerlink" title="原子操作和互斥锁的性能比较"></a>原子操作和互斥锁的性能比较</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// x = x + 1</span></span><br><span class="line">    x++ <span class="comment">// 等价于上面的操作</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l.Lock()</span><br><span class="line">    x++</span><br><span class="line">    l.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;x, <span class="number">1</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// go add()       // 普通版add函数 不是并发安全的</span></span><br><span class="line">        <span class="comment">// go mutexAdd()  // 加锁版add函数 是并发安全的，但是加锁性能开销大</span></span><br><span class="line">        <span class="keyword">go</span> atomicAdd() <span class="comment">// 原子操作版add函数 是并发安全，性能优于加锁版</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">go</span> mutexAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.672672</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> atomicAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.63377</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="number">9171</span></span><br><span class="line"><span class="number">5.170112</span>ms</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zhongsongzhi97.github.io/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/zhongsongzhi97.github.io/">1</a><a class="page-number" href="/zhongsongzhi97.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="page-number" href="/zhongsongzhi97.github.io/page/5/">5</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
