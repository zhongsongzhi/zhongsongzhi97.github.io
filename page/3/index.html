<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/zhongsongzhi97.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/zhongsongzhi97.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/zhongsongzhi97.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/zhongsongzhi97.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/zhongsongzhi97.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongsongzhi.github.io","root":"/zhongsongzhi97.github.io/","images":"/zhongsongzhi97.github.io/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/zhongsongzhi97.github.io/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Zhong&#96;s Blog">
<meta property="og:url" content="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/3/index.html">
<meta property="og:site_name" content="Dylan Zhong&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dylan Zhong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dylan Zhong`s Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/zhongsongzhi97.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/zhongsongzhi97.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dylan Zhong`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">对对对</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/zhongsongzhi97.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-标签"><a href="/zhongsongzhi97.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-分类"><a href="/zhongsongzhi97.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-归档"><a href="/zhongsongzhi97.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dylan Zhong"
      src="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dylan Zhong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/zhongsongzhi97.github.io/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/zhongsongzhi97.github.io/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/zhongsongzhi97.github.io/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/12/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理 - go栈内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-04 17:56:30" itemprop="dateCreated datePublished" datetime="2021-12-04T17:56:30+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-08 16:50:41" itemprop="dateModified" datetime="2021-12-08T16:50:41+08:00">2021-12-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="栈空间管理"><a href="#栈空间管理" class="headerlink" title="栈空间管理"></a>栈空间管理</h1><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx6iw2lc9sj30hi0bgmxn.jpg" alt="栈"></p>
<h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol>
<li>功能不同：函数调用的参数、返回值以及局部变量都会分配到栈上。</li>
<li>共享性不同：栈是线程私有，堆是共享</li>
<li>栈的空间一般远远小于堆</li>
</ol>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>应用程序的内存一般会分成堆区和栈区，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。</p>
<p>栈区的内存由编译器自动分配和释放，其中存储的是函数的入参和局部变量。</p>
<p>总结：Go的栈使用连续栈进行管理，对象或结构体是分配到栈还是堆，由逃逸分析决定，栈是线程私有，Go的栈是以Goroutine作为context，为了高效管理栈，使用了2个寄存器BP,SP来表明其基址和栈顶。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>栈寄存器是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈，Go 语言的汇编代码包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址。BP 和 SP 之间的内存就是当前函数的调用栈。</p>
<p>栈区内存都是从高地址向低地址扩展的，当应用程序申请或者释放栈内存时只需要修改 SP 寄存器的值，这种线性的内存分配方式与堆内存相比更加快速，仅会带来极少的额外开销。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx1yjgbzr2j30xj0e6aab.jpg" alt="stack-registers"></p>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><p>创建一个线程时，系统会根据架构不同选择不同的默认栈大小，一般为2~4MB左右，用户程序可以在栈上存储函数参数和局部变量。</p>
<p>对于Go:由于Go设计时以协程实现，所以其再用户态实现Goroutine作为执行上下文。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在手动管理内存的语言中，可以选择将对象或结构体分配到栈或者堆上，但是这样会存在2个问题：</p>
<ul>
<li>不需要分配到堆上的对象分配到了堆上 — 浪费内存空间；</li>
<li>需要分配到堆上的对象分配到了栈上 — 悬挂指针、影响内存安全；</li>
</ul>
<p>Eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dangling_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当 dangling_pointer 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的逃逸分析遵循以下两个不变性：</p>
<ol>
<li>指向栈对象的指针不能存在于堆中；</li>
<li>指向栈对象的指针不能在栈对象回收后存活；</li>
</ol>
<p>Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 <code>new</code>、<code>make</code> 和字面量等方法隐式分配的内存。为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为堆也会被垃圾收集器扫描，所以不会造成内存泄露以及悬挂指针等安全问题。</p>
<p><strong>逃逸分析的实现：</strong></p>
<p>逃逸分析是静态分析的一种，在编译器活动抽象语法树以后，可以通过抽象语法树分析静态的数据流。</p>
<ul>
<li>构建带权重的有向图，其中顶点表示被分配的变量，边表示变量之间的分配关系，权重表示寻址和取地址的次数；</li>
<li>遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么该变量需要分配在堆上；</li>
<li>记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；</li>
</ul>
<h3 id="栈内存空间"><a href="#栈内存空间" class="headerlink" title="栈内存空间"></a>栈内存空间</h3><p>Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多</p>
<p>在1.3版本以后，都是有连续栈，最小栈空间在1.4版本，为2KB</p>
<p>连续栈：</p>
<p>核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。</p>
<p>步骤：</p>
<ol>
<li>在内存空间中分配更大的栈内存空间；</li>
<li>将旧栈中的所有内容复制到新栈中；</li>
<li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li>
<li>销毁并回收旧栈的内存空间；</li>
</ol>
<p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题，即在GC时期合理调整栈的大小。 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。</p>
<h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><h4 id="栈初始化"><a href="#栈初始化" class="headerlink" title="栈初始化"></a>栈初始化</h4><p>运行时使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和线程缓存中的空闲链表分配 32KB 以下的栈内存，使用全局的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 和堆内存分配 32KB 以上的栈内存，提高本地分配栈内存的性能。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx263w3xb5j30xc096gma.jpg" alt="stack-memory"></p>
<p>栈空间在运行时中包含两个重要的全局变量，分别是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackpool"><code>runtime.stackpool</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a>，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间：</p>
<p>每一个线程缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a> 中也都加入了栈缓存减少锁竞争影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackpool [_NumStackOrders]<span class="keyword">struct</span> &#123;</span><br><span class="line">	item stackpoolItem</span><br><span class="line">	_    [cpu.CacheLinePadSize - unsafe.Sizeof(stackpoolItem&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stackpoolItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   mutex</span><br><span class="line">	span mSpanList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackLarge <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock mutex</span><br><span class="line">	free [heapAddrBits - pageShift]mSpanList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言的栈内存都是分配到堆上的，运行时初始化会调用<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackinit"><code>runtime.stackinit</code></a> 初始化这些全局变量。</p>
<h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>运行时会在 Goroutine 的初始化函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 中调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配一个大小足够栈内存空间，根据线程缓存和申请栈的大小，该函数会通过三种不同的方法分配栈空间：</p>
<ol>
<li>如果栈空间较小，使用全局栈缓存或者线程缓存上固定大小的空闲链表分配内存；</li>
<li>如果栈空间较大，从全局的大栈缓存 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 中获取内存空间；</li>
<li>如果栈空间较大并且 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackLarge"><code>runtime.stackLarge</code></a> 空间不足，在堆上申请一片大小足够内存空间；</li>
</ol>
<h4 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h4><p>编译器会在函数调用中插入运行时检查，检查函数调用当前Goroutine的栈空间是否充足，当需要扩容时，会保存一些栈的信息并调用runtime.newstack创建新栈进行扩容</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newstack"><code>runtime.newstack</code></a> 会先做一些准备工作并检查当前 Goroutine 是否发出了抢占请求。如果当前 Goroutine 不需要被抢占，意味着我们需要新的栈空间来支持函数调用和本地变量的初始化，运行时会先检查目标大小的栈是否会溢出。</p>
<p>如果目标栈的大小没有超出程序的限制，我们会将 Goroutine 切换至 <code>_Gcopystack</code> 状态并调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.copystack"><code>runtime.copystack</code></a> 开始栈拷贝。在拷贝栈内存之前，运行时会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配新的栈空间：</p>
<p>分配好以后开始拷贝栈空间</p>
<p>同上的连续栈扩容</p>
<h4 id="栈缩容"><a href="#栈缩容" class="headerlink" title="栈缩容"></a>栈缩容</h4><p>GC时，使用率为1/4时，缩容为之前的一半，也会coptyStack</p>
<h3 id="栈内容扩展"><a href="#栈内容扩展" class="headerlink" title="栈内容扩展"></a>栈内容扩展</h3><h4 id="栈的汇编分析"><a href="#栈的汇编分析" class="headerlink" title="栈的汇编分析"></a>栈的汇编分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = a + b + x;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line">.LFB0:</span><br><span class="line">    .file <span class="number">1</span> <span class="string">&quot;call_no_stack.c&quot;</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp             <span class="comment">//rbp入栈 （rsp-8）</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp       <span class="comment">//rsp 赋值给 rbp，这里rsp并没有移动，可能是因为这里是最后一个函数调用，所以不需要移动rsp</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)  <span class="comment">//这里通过rbp来访问栈，将main函数中的实参2放入rbp-20内存</span></span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)  <span class="comment">//这里表示栈空间分配了24字节，猜测：函数中的参数值从栈顶开始存储</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">5</span> <span class="number">0</span></span><br><span class="line">    movb    $<span class="number">1</span>, <span class="number">-5</span>(%rbp)     <span class="comment">//局部变量x入栈，x占用1个字节，相当于x后入栈：栈的地址是向下减少的</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)     <span class="comment">//局部变量c入栈，放在rbp-4处</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">7</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx   </span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %eax, %edx      <span class="comment">//相加操作</span></span><br><span class="line">    movsbl    <span class="number">-5</span>(%rbp), %eax </span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">8</span> <span class="number">0</span></span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax  <span class="comment">//将c变量的结果保存到eax寄存器，以便函数返回</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">    popq    %rbp            <span class="comment">//将堆栈pop，此时栈顶保存着调用函数的rbp值，将栈顶元素赋予rbp寄存器（恢复rbp寄存器）</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                     <span class="comment">//跳转回上一层处继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size    foo, .-foo</span><br><span class="line">    .globl    main</span><br><span class="line">    .type    main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">12</span> <span class="number">0</span></span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq    %rbp              <span class="comment">//rbp：64位寄存器——指向栈底，将rbp寄存器内的值入栈-pushq操作会改变rsp的值</span></span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp         <span class="comment">//rsp：64位堆栈指针寄存器——指向栈顶，将rsp值存入rbp寄存器内</span></span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp          <span class="comment">//rsp-16，这里讲栈顶指针向下移动16字节，相当于为main函数预留了16字节的栈空间-保存局部变量包括实参</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">13</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)       <span class="comment">//对应局部变量ret = 0</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">14</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">3</span>, %esi           <span class="comment">//这里直接将实参存入esi寄存器而不是放入堆栈，可加快访问速度</span></span><br><span class="line">    movl    $<span class="number">2</span>, %edi</span><br><span class="line">    call    foo                <span class="comment">//调用foo函数:call指令有另个作用：1，将call指令的下一条指令入栈-并改变rsp 2，修改程序计数器eip，跳转到foo函数的开头执行</span></span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)     <span class="comment">//eax寄存器保存着返回值，这里将eax赋值给rbp-4的位置，也就是ret</span></span><br><span class="line">    .loc <span class="number">1</span> <span class="number">15</span> <span class="number">0</span></span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    .loc <span class="number">1</span> <span class="number">16</span> <span class="number">0</span></span><br><span class="line">    leave                     <span class="comment">//leave指令是函数开头的pushq %rbp和movq %rsp,%rbp的逆操作,　　　　　　　　　　　　　　　　　　//有两个作用：1，把rbp赋值给rsp 2,然后把该函数栈栈顶保存的rbp值恢复到rbp寄存器中,同时rsp+4(第二部的操作相当于pop栈顶元素)</span></span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret                       <span class="comment">//现在栈顶元素保存的是下一条执行的指令，ret的作用就是pop栈顶元素，并将栈顶元素赋值给程序计数器bip，然后程序跳转回bip所在地址继续执行</span></span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size    main, .-main</span><br></pre></td></tr></table></figure>

<ol>
<li>变量存储会按照会根据类型，在汇编的得出其偏移量来操作</li>
<li>只有两个寄存器bp,sp来管理当前栈帧，之前已经入栈的栈帧的相关信息，会存储到其上下文中</li>
</ol>
<h4 id="栈空间对齐"><a href="#栈空间对齐" class="headerlink" title="栈空间对齐"></a>栈空间对齐</h4><p>栈的字节对齐，实际是指栈顶指针必须是16字节的整数倍，栈对齐是为了尽可能少的内存访问周期读取数据，保证性能 - 任何内存分配函数(alloca, malloc, calloc)生成的块的起始地址必须为16的整数倍。大多数函数的栈帧的边界必须为16的整数倍。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>C语言函数栈帧实例：<a target="_blank" rel="noopener" href="https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html">https://gitbook.coder.cat/function-call-principle/content/c-stack-frame-example.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/28/Go%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B2/" class="post-title-link" itemprop="url">Go多线程编程2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-28 16:09:04 / Modified: 18:11:35" itemprop="dateCreated datePublished" datetime="2021-11-28T16:09:04+08:00">2021-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go多线程编程"><a href="#Go多线程编程" class="headerlink" title="Go多线程编程"></a>Go多线程编程</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul>
<li>Timer：时间到了，执行只执行1次</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 使用</span><br><span class="line">timer1 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">t2 := &lt;-timer1.C</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 延时</span><br><span class="line">(<span class="number">1</span>)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"> timer3 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line"> &lt;-timer3.C</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">&lt;-time.After(<span class="number">2</span>*time.Second)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 停止</span><br><span class="line">timer4 := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">timer4.Stop()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 重置定时器</span><br><span class="line">timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">timer5.Reset(<span class="number">1</span> * time.Second)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.timer基本使用</span></span><br><span class="line">   <span class="comment">//timer1 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//t1 := time.Now()</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t1:%v\n&quot;, t1)</span></span><br><span class="line">   <span class="comment">//t2 := &lt;-timer1.C</span></span><br><span class="line">   <span class="comment">//fmt.Printf(&quot;t2:%v\n&quot;, t2)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.验证timer只能响应1次</span></span><br><span class="line">   <span class="comment">//timer2 := time.NewTimer(time.Second)</span></span><br><span class="line">   <span class="comment">//for &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer2.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;时间到&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3.timer实现延时的功能</span></span><br><span class="line">   <span class="comment">//(1)</span></span><br><span class="line">   <span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">   <span class="comment">//(2)</span></span><br><span class="line">   <span class="comment">//timer3 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//&lt;-timer3.C</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line">   <span class="comment">//(3)</span></span><br><span class="line">   <span class="comment">//&lt;-time.After(2*time.Second)</span></span><br><span class="line">   <span class="comment">//fmt.Println(&quot;2秒到&quot;)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.停止定时器</span></span><br><span class="line">   <span class="comment">//timer4 := time.NewTimer(2 * time.Second)</span></span><br><span class="line">   <span class="comment">//go func() &#123;</span></span><br><span class="line">   <span class="comment">// &lt;-timer4.C</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;定时器执行了&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;()</span></span><br><span class="line">   <span class="comment">//b := timer4.Stop()</span></span><br><span class="line">   <span class="comment">//if b &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;timer4已经关闭&quot;)</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5.重置定时器</span></span><br><span class="line">   timer5 := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">   timer5.Reset(<span class="number">1</span> * time.Second)</span><br><span class="line">   fmt.Println(time.Now())</span><br><span class="line">   fmt.Println(&lt;-timer5.C)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ticker：时间到了，多次执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取ticker对象</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;-ticker.C</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(&lt;-ticker.C)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">//停止</span></span><br><span class="line">                ticker.Stop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>用法类似与Socket里的select</p>
<p>作用：select关键字，可以同时响应多个通道的操作。</p>
<ul>
<li>select可以同时监听一个或多个channel，直到其中一个channel ready</li>
<li>如果多个channel同时ready，则随机选择一个执行</li>
<li>可以用于判断管道是否存满</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">       <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">       <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断管道是否存满</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建管道</span></span><br><span class="line">   output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">// 子协程写数据</span></span><br><span class="line">   <span class="keyword">go</span> write(output1)</span><br><span class="line">   <span class="comment">// 取数据</span></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发安全与锁"><a href="#并发安全与锁" class="headerlink" title="并发安全与锁"></a>并发安全与锁</h2><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(wg * WaitGroup) Add(delta int)</td>
<td>计数器+delta</td>
</tr>
<tr>
<td>(wg *WaitGroup) Done()</td>
<td>计数器-1</td>
</tr>
<tr>
<td>(wg *WaitGroup) Wait()</td>
<td>阻塞直到计数器变为0</td>
</tr>
</tbody></table>
<p>sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>注意：sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>实现单例和资源只加载一次的方法</p>
<p>sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<p>sync.Once只有一个Do方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">        <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>map不是线程安全的，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<p><strong>猜测实现类似于Java中的ConcurrentHashMap，待研究</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m.Store(key, n)</span><br><span class="line">            value, _ := m.Load(key)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。</p>
<p>atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
<h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>func LoadInt32(addr *int32) (val int32) func LoadInt64(addr <code>*int64</code>) (val int64)<br>func LoadUint32(addr<code>*uint32</code>) (val uint32)<br>func LoadUint64(addr<code>*uint64</code>) (val uint64)<br>func LoadUintptr(addr<code>*uintptr</code>) (val uintptr)<br>func LoadPointer(addr<code>*unsafe.Pointer</code>) (val unsafe.Pointer)</td>
<td>读取操作</td>
</tr>
<tr>
<td>func StoreInt32(addr <code>*int32</code>, val int32) func StoreInt64(addr <code>*int64</code>, val int64) func StoreUint32(addr <code>*uint32</code>, val uint32) func StoreUint64(addr <code>*uint64</code>, val uint64) func StoreUintptr(addr <code>*uintptr</code>, val uintptr) func StorePointer(addr <code>*unsafe.Pointer</code>, val unsafe.Pointer)</td>
<td>写入操作</td>
</tr>
<tr>
<td>func AddInt32(addr <code>*int32</code>, delta int32) (new int32) func AddInt64(addr <code>*int64</code>, delta int64) (new int64) func AddUint32(addr <code>*uint32</code>, delta uint32) (new uint32) func AddUint64(addr <code>*uint64</code>, delta uint64) (new uint64) func AddUintptr(addr <code>*uintptr</code>, delta uintptr) (new uintptr)</td>
<td>修改操作</td>
</tr>
<tr>
<td>func SwapInt32(addr <code>*int32</code>, new int32) (old int32) func SwapInt64(addr <code>*int64</code>, new int64) (old int64) func SwapUint32(addr <code>*uint32</code>, new uint32) (old uint32) func SwapUint64(addr <code>*uint64</code>, new uint64) (old uint64) func SwapUintptr(addr <code>*uintptr</code>, new uintptr) (old uintptr) func SwapPointer(addr <code>*unsafe.Pointer</code>, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td>交换操作</td>
</tr>
<tr>
<td>func CompareAndSwapInt32(addr <code>*int32</code>, old, new int32) (swapped bool) func CompareAndSwapInt64(addr <code>*int64</code>, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <code>*uint32</code>, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr <code>*uint64</code>, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <code>*uintptr</code>, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr <code>*unsafe.Pointer</code>, old, new unsafe.Pointer) (swapped bool)</td>
<td>比较并交换操作</td>
</tr>
</tbody></table>
<h3 id="原子操作和互斥锁的性能比较"><a href="#原子操作和互斥锁的性能比较" class="headerlink" title="原子操作和互斥锁的性能比较"></a>原子操作和互斥锁的性能比较</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// x = x + 1</span></span><br><span class="line">    x++ <span class="comment">// 等价于上面的操作</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l.Lock()</span><br><span class="line">    x++</span><br><span class="line">    l.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版加函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;x, <span class="number">1</span>)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// go add()       // 普通版add函数 不是并发安全的</span></span><br><span class="line">        <span class="comment">// go mutexAdd()  // 加锁版add函数 是并发安全的，但是加锁性能开销大</span></span><br><span class="line">        <span class="keyword">go</span> atomicAdd() <span class="comment">// 原子操作版add函数 是并发安全，性能优于加锁版</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    end := time.Now()</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">go</span> mutexAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.672672</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> atomicAdd()</span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">4.63377</span>ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="number">9171</span></span><br><span class="line"><span class="number">5.170112</span>ms</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/27/go%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/27/go%E5%9F%BA%E7%A1%80-%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">go基础 - 方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-27 16:43:49 / Modified: 23:56:07" itemprop="dateCreated datePublished" datetime="2021-11-27T16:43:49+08:00">2021-11-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。</p>
<p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>
<p>所有给定类型的方法属于该类型的方法集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 只能为当前包内命名类型定义方法。</span><br><span class="line">• 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。</span><br><span class="line">• 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。 </span><br><span class="line">• 不支持方法重载，receiver 只是参数签名的组成部分。</span><br><span class="line">• 可用实例 value 或 pointer 调用全部方法，编译器自动转换。</span><br></pre></td></tr></table></figure>

<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">参数和返回值可以省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型调用方法</span></span><br><span class="line">    u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;golang@golang.com&quot;</span>&#125;</span><br><span class="line">    u1.Notify()</span><br><span class="line">    <span class="comment">// 指针类型调用方法</span></span><br><span class="line">    u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.com&quot;</span>&#125;</span><br><span class="line">    u3 := &amp;u2</span><br><span class="line">    u3.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</span></span><br></pre></td></tr></table></figure>

<p>指针类型接收者和值类型接收者：当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self Data)</span> <span class="title">ValueTest</span><span class="params">()</span></span> &#123; <span class="comment">// func ValueTest(self Data);</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Value: %p\n&quot;</span>, &amp;self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Data)</span> <span class="title">PointerTest</span><span class="params">()</span></span> &#123; <span class="comment">// func PointerTest(self *Data);</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Pointer: %p\n&quot;</span>, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Data&#123;&#125;</span><br><span class="line">    p := &amp;d</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Data: %p\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    d.ValueTest()   <span class="comment">// ValueTest(d)</span></span><br><span class="line">    d.PointerTest() <span class="comment">// PointerTest(&amp;d)</span></span><br><span class="line"></span><br><span class="line">    p.ValueTest()   <span class="comment">// ValueTest(*p)</span></span><br><span class="line">    p.PointerTest() <span class="comment">// PointerTest(p)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">Data: <span class="number">0xc42007c008</span></span><br><span class="line">Value: <span class="number">0xc42007c018</span></span><br><span class="line">Pointer: <span class="number">0xc42007c008</span></span><br><span class="line">Value: <span class="number">0xc42007c020</span></span><br><span class="line">Pointer: <span class="number">0xc42007c008</span></span><br></pre></td></tr></table></figure>

<h2 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h2><p>1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。</p>
<p>2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。但是值类型的接受者，使用指针类型的变量调用方法也是值拷贝的形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.普通函数</span></span><br><span class="line"><span class="comment">//接收值类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valueIntTest</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收指针类型参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerIntTest</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;valueIntTest:&quot;</span>, valueIntTest(a))</span><br><span class="line">    <span class="comment">//函数的参数为值类型，则不能直接将指针作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))</span></span><br><span class="line">    <span class="comment">//compile error: cannot use &amp;a (type *int) as type int in function argument</span></span><br><span class="line"></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;pointerIntTest:&quot;</span>, pointerIntTest(&amp;b))</span><br><span class="line">    <span class="comment">//同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))</span></span><br><span class="line">    <span class="comment">//compile error:cannot use b (type int) as type *int in function argument</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法</span></span><br><span class="line"><span class="keyword">type</span> PersonD <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PersonD)</span> <span class="title">valueShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者为指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PersonD)</span> <span class="title">pointShowName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//值类型调用方法</span></span><br><span class="line">    personValue := PersonD&#123;<span class="number">101</span>, <span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">    personValue.valueShowName()</span><br><span class="line">    personValue.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针类型调用方法</span></span><br><span class="line">    personPointer := &amp;PersonD&#123;<span class="number">102</span>, <span class="string">&quot;hello golang&quot;</span>&#125;</span><br><span class="line">    personPointer.valueShowName()</span><br><span class="line">    personPointer.pointShowName()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structTestValue()</span><br><span class="line">    structTestFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">valueIntTest: <span class="number">12</span></span><br><span class="line">pointerIntTest: <span class="number">15</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello golang</span><br><span class="line">hello golang</span><br></pre></td></tr></table></figure>

<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>可以像字段成员那样访问匿名字段方法，编译器负责查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>,u,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Manager&#123;User&#123;id: <span class="number">1</span>,name: <span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Manager: %p\n&quot;</span>, &amp;m)</span><br><span class="line">	fmt.Println(m.ToString())</span><br><span class="line">	u := User&#123;</span><br><span class="line">		id: <span class="number">2</span>,</span><br><span class="line">		name: <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;User: %p\n&quot;</span>,&amp;u)</span><br><span class="line">	fmt.Println(u.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;User: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Manager: %p, %v&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;, <span class="string">&quot;Administrator&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.ToString())</span><br><span class="line"></span><br><span class="line">    fmt.Println(m.User.ToString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">Manager: <span class="number">0xc420074180</span>, &amp;&#123;&#123;<span class="number">1</span> Tom&#125; Administrator&#125;</span><br><span class="line">User: <span class="number">0xc420074180</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 类型 T 方法集包含全部 receiver T 方法。</span><br><span class="line">• 类型 *T 方法集包含全部 receiver T + *T 方法。</span><br><span class="line">• 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 </span><br><span class="line">• 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 </span><br><span class="line">• 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。</span><br></pre></td></tr></table></figure>

<p>用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。</p>
<p>方法集对接口的影响：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Sending user email to %s&lt;%s&gt;\n&quot;</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;bill@email.com&quot;</span>&#125;</span><br><span class="line">    sendNotificatioin(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotificatioin</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">20</span>: cannot use u (<span class="keyword">type</span> user) as <span class="keyword">type</span> notifier in argument to sendNotificatioin:</span><br><span class="line">        user does not implement notifier (notify method has pointer receiver)</span><br></pre></td></tr></table></figure>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...) ---&gt; &lt;type&gt;.func(instance, args...)</span><br><span class="line">前者称为 method value，后者 method expression。</span><br><span class="line">两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">    u.Test()</span><br><span class="line"></span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line">    mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">    mExpression := (*User).Test</span><br><span class="line">    mExpression(&amp;u) <span class="comment">// 显式传递 receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法“还原”成函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Data)</span> <span class="title">TestValue</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Data)</span> <span class="title">TestPointer</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *Data = <span class="literal">nil</span></span><br><span class="line">    p.TestPointer()</span><br><span class="line"></span><br><span class="line">    (*Data)(<span class="literal">nil</span>).TestPointer() <span class="comment">// method value</span></span><br><span class="line">    (*Data).TestPointer(<span class="literal">nil</span>)   <span class="comment">// method expression</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p.TestValue()            // invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Data)(nil).TestValue()  // cannot convert nil to type Data</span></span><br><span class="line">    <span class="comment">// Data.TestValue(nil)      // cannot use nil as type Data in function argument</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/27/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/27/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">go并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-27 16:43:27" itemprop="dateCreated datePublished" datetime="2021-11-27T16:43:27+08:00">2021-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-11-28 16:08:18" itemprop="dateModified" datetime="2021-11-28T16:08:18+08:00">2021-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Go多线程编程"><a href="#Go多线程编程" class="headerlink" title="Go多线程编程"></a>Go多线程编程</h1><h2 id="并发介绍"><a href="#并发介绍" class="headerlink" title="并发介绍"></a>并发介绍</h2><p>协程和线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。</span><br><span class="line">线程：一个线程上可以跑多个协程，协程是轻量级的线程。</span><br></pre></td></tr></table></figure>

<h4 id="goroutine-只是由官方实现的超级”线程池”。"><a href="#goroutine-只是由官方实现的超级”线程池”。" class="headerlink" title="goroutine 只是由官方实现的超级”线程池”。"></a>goroutine 只是由官方实现的超级”线程池”。</h4><p>每个实力<code>4~5KB</code>的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p>
<h4 id="并发不是并行："><a href="#并发不是并行：" class="headerlink" title="并发不是并行："></a>并发不是并行：</h4><p>并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p>
<h4 id="goroutine-奉行通过通信来共享内存，而不是共享内存来通信。"><a href="#goroutine-奉行通过通信来共享内存，而不是共享内存来通信。" class="headerlink" title="goroutine 奉行通过通信来共享内存，而不是共享内存来通信。"></a>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</h4><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>Goroutine的使用类似于OC中一样，开发者只需要定义很多任务，由系统去帮助我们把这些任务并发执行。</p>
<p><strong>使用goroutine</strong></p>
<p>在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。</p>
<p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<p>使用：</p>
<ol>
<li><p>启动单个goroutine, 主协程退出其他协程也会退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里执行只会打印 main goroutine done</span></span><br><span class="line"><span class="comment">//在程序启动的时候，Go程序会为main函数创建一个默认的goroutine，main返回时goroutine会结束，所有在main中启动的goroutine会一同结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动多个goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>goroutine与线程</p>
<ul>
<li><p>可增长的栈</p>
<p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
</li>
<li><p>goroutine调度</p>
<p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
</li>
</ul>
</li>
</ol>
<h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>让出CPU时间片，重新等待安排任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">            fmt.Println(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="comment">// 主协程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 切一下，再次分配任务</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不注释，使用了runtime.Gosched()</span></span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line"><span class="comment">//不使用runtime.Gosched()</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            <span class="comment">// 结束协程</span></span><br><span class="line">            runtime.Goexit()</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C.defer&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">B.<span class="keyword">defer</span></span><br><span class="line">A.<span class="keyword">defer</span></span><br></pre></td></tr></table></figure>

<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>) <span class="comment">//runtime.GOMAXPROCS(2)</span></span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ul>
<li>1.一个操作系统线程对应用户态多个goroutine。</li>
<li>2.go程序可以同时使用多个操作系统线程。</li>
<li>3.goroutine和OS线程是多对多的关系，即m:n。</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
<p>如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p>channel是一种类型，一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 通道是引用类型，通道类型的空值是nil。</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>

<h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用&lt;-符号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">x := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="comment">//关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>注：关闭后的通道有以下特定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.对一个关闭的通道再发送值就会导致panic。</span><br><span class="line">2.对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class="line">3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class="line">4.关闭一个已经关闭的通道会导致panic。</span><br></pre></td></tr></table></figure>

<h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuwtw5gcjj30nx0m6abz.jpg" alt="img"></p>
<p>无缓冲的通道又称为阻塞的通道</p>
<p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;-c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuwvuil1tj30m70ewgn1.jpg" alt="img"></p>
<p>在使用make函数初始化通道的时候为其指定通道的容量</p>
<p>可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><ol>
<li><p>从通道循环取值</p>
<p>当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            ch1 &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch1)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ch2 &lt;- i * i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch2)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单向通道</p>
<p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了单向通道来处理这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">chan</span>&lt;- <span class="keyword">int</span>是一个只能发送的通道，可以发送但是不能接收；</span><br><span class="line"><span class="number">2.</span>&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>是一个只能接收的通道，可以接收但是不能发送。</span><br><span class="line"><span class="number">3.</span>函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的</span><br></pre></td></tr></table></figure></li>
<li><p>通道总结</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwuxccpcroj31bs0iidkx.jpg" alt="通道总结"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		ch1&lt;-i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch1)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i,ok := &lt;-ch1;ok &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;read over&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">read over</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/27/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/27/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">go语言基础 - 函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-27 13:22:16 / Modified: 16:07:32" itemprop="dateCreated datePublished" datetime="2021-11-27T13:22:16+08:00">2021-11-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="函数特点"><a href="#函数特点" class="headerlink" title="函数特点"></a>函数特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">• 无需声明原型。</span><br><span class="line">• 支持不定 变参。</span><br><span class="line">• 支持多返回值。</span><br><span class="line">• 支持命名返回参数。 </span><br><span class="line">• 支持匿名函数和闭包。</span><br><span class="line">• 函数也是一种类型，一个函数可以赋值给变量。</span><br><span class="line"></span><br><span class="line">• 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。</span><br><span class="line">• 不支持 重载 (overload) </span><br><span class="line">• 不支持 默认参数 (default parameter)。</span><br></pre></td></tr></table></figure>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。</span></span><br><span class="line">    n := x + y          </span><br><span class="line">    <span class="keyword">return</span> n, fmt.Sprintf(s, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数是第一类对象，可作为参数传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数类型。</span></span><br><span class="line"><span class="keyword">type</span> FormatFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(s, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := test(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">100</span> &#125;) <span class="comment">// 直接将匿名函数当参数。</span></span><br><span class="line"></span><br><span class="line">    s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(s, x, y)</span><br><span class="line">    &#125;, <span class="string">&quot;%d, %d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h2><ol>
<li><p>函数参数</p>
<p>当函数调用时，函数的形参放到栈帧里一起被压栈，调用完成后会出栈，使用上类似局部变量。</p>
<p>map、slice、chan、指针、interface默认以引用的方式传递，拷贝的是地址，其他基本都是值传递</p>
</li>
<li><p>可变参数</p>
<p>Golang的可变参数本质是一个slice（可变数组），只能有一个且必须为最后一个</p>
<p>在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;    <span class="comment">//0个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, args…<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//1个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, args…<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//2个或多个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>任意类型的不定参数，使用interface{}传递任意参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="keyword">string</span>, n ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(test(<span class="string">&quot;sum: %d&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">//使用 slice 对象做变参时，必须展开。（slice...）</span></span><br><span class="line">    res := test(<span class="string">&quot;sum: %d&quot;</span>, s...)    <span class="comment">// slice... 展开slice</span></span><br><span class="line">    <span class="built_in">println</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>&quot;_&quot;</code>标识符，用来忽略函数的某个返回值</p>
<p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。</p>
<p>返回值的名称应当具有一定的意义，可以作为文档使用。</p>
<p>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。</p>
<p>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<ol>
<li><p>直接返回语句.命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。</p>
<p>命名返回参数可被同名局部变量遮蔽，此时需要显式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>, avg <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum = a + b</span><br><span class="line">    avg = (a + b) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    c := add(a, b)</span><br><span class="line">    sum, avg := calc(a, b)</span><br><span class="line">    fmt.Println(a, b, c, sum, avg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out </span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 <code>&quot;_&quot;</code> 忽略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// s := make([]int, 2)</span></span><br><span class="line">    <span class="comment">// s = test()   // Error: multiple-value test() in single-value context</span></span><br><span class="line"></span><br><span class="line">    x, _ := test()</span><br><span class="line">    <span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多返回值可直接作为其他函数调用实参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(test()))</span><br><span class="line">    <span class="built_in">println</span>(sum(test()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>命名返回参数允许 defer 延迟调用通过闭包读取和修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        z += <span class="number">100</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out </span></span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure></li>
<li><p>显式 return 返回前，会先修改命名返回参数。</p>
<p>执行顺序:return先执行，return负责将结果写入返回值，defer做收尾工作，最后函数携带当前返回值退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(z) <span class="comment">// 输出: 203</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z + <span class="number">200</span> <span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 输出: 203</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line">    <span class="number">203</span></span><br><span class="line">    <span class="number">203</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是指不需要定义函数名的一种函数实现方式。1958年LISP首先采用匿名函数。</p>
<p>在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。(猜测是匿名函数的结构体里捕获了变量)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(a)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(getSqrt(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// --- function variable ---</span></span><br><span class="line">    fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>) &#125;</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function collection ---</span></span><br><span class="line">    fns := [](<span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x + <span class="number">2</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(fns[<span class="number">0</span>](<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- function as field ---</span></span><br><span class="line">    d := <span class="keyword">struct</span> &#123;</span><br><span class="line">        fn <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(d.fn())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- channel of function ---</span></span><br><span class="line">    fc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span>, 2)</span></span><br><span class="line">    fc &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span> &#125;</span><br><span class="line">    <span class="built_in">println</span>((&lt;-fc)())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">Hello, World!</span><br><span class="line"><span class="number">101</span></span><br><span class="line">Hello, World!</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。</p>
<p>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>Go的闭包：</p>
<p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x (%p) = %d\n&quot;</span>, &amp;x, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test()</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    x (<span class="number">0xc42007c008</span>) = <span class="number">100</span></span><br><span class="line">    x (<span class="number">0xc42007c008</span>) = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。</span><br><span class="line"> FuncVal &#123; func_address, closure_var_pointer ... &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回2个函数类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义2个函数，并返回</span></span><br><span class="line">    <span class="comment">// 相加</span></span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        base += i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相减</span></span><br><span class="line">    sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        base -= i</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f1, f2 := test01(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// base一直是没有消</span></span><br><span class="line">    fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// 此时base是9</span></span><br><span class="line">    fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="number">11</span> <span class="number">9</span></span><br><span class="line"><span class="number">12</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="延迟调用Defer"><a href="#延迟调用Defer" class="headerlink" title="延迟调用Defer"></a>延迟调用Defer</h2><ol>
<li><p>defer特性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 关键字 defer 用于注册延迟调用。</span><br><span class="line">2. 这些调用直到 return 前才被执。因此，可以用来做资源清理。</span><br><span class="line">3. 多个defer语句，按先进后出的方式执行。</span><br><span class="line">4. defer语句中的变量，在defer声明时就决定了。</span><br></pre></td></tr></table></figure></li>
<li><p>defer用途</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 关闭文件句柄</span><br><span class="line">2. 锁资源释放</span><br><span class="line">3. 数据库连接释放</span><br></pre></td></tr></table></figure></li>
<li><p>defer先进后出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>defer和闭包</p>
<p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked.</p>
<p>也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> whatever &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(i) &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>常见错误defer f.Close</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> t.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    c  closed</span><br><span class="line">    c  closed</span><br><span class="line">    c  closed</span><br></pre></td></tr></table></figure>

<p>处理:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.name, <span class="string">&quot; closed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">(t Test)</span></span> &#123;</span><br><span class="line">    t.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ts := []Test&#123;&#123;<span class="string">&quot;a&quot;</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">        <span class="keyword">defer</span> Close(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">c  closed</span><br><span class="line">b  closed</span><br><span class="line">a  closed</span><br></pre></td></tr></table></figure>

<p>或者：使用forr</p>
<p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。</p>
</li>
<li><p>多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="number">100</span> / x) <span class="comment">// div0 异常未被捕获，逐步往外传递，最终终止进程。</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line"><span class="built_in">panic</span>: runtime error: integer divide by zero</span><br></pre></td></tr></table></figure></li>
<li><p>defer会存在性能问题，在循环中要慎重使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock.Lock()</span><br><span class="line">    lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testdefer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t1 := time.Now()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">            test()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.Since(t1)</span><br><span class="line">        fmt.Println(<span class="string">&quot;test elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t1 := time.Now()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">            testdefer()</span><br><span class="line">        &#125;</span><br><span class="line">        elapsed := time.Since(t1)</span><br><span class="line">        fmt.Println(<span class="string">&quot;testdefer elapsed: &quot;</span>, elapsed)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">test elapsed:  <span class="number">223.162</span>µs</span><br><span class="line">testdefer elapsed:  <span class="number">781.304</span>µs</span><br></pre></td></tr></table></figure></li>
<li><p>defer使用常见陷阱</p>
<ul>
<li>如果 defer 后面跟的不是一个 closure 最后执行的时候我们得到的并不是最新的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;first defer err %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123; fmt.Printf(<span class="string">&quot;second defer err %v\n&quot;</span>, err) &#125;(err)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;third defer err %v\n&quot;</span>, err) &#125;()</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        err = errors.New(<span class="string">&quot;divided by zero!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = a / b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">third <span class="keyword">defer</span> err divided by zero!</span><br><span class="line">second <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">first <span class="keyword">defer</span> err &lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="defer-与-return"><a href="#defer-与-return" class="headerlink" title="defer 与 return"></a>defer 与 return</h4><p>解释：在有具名返回值的函数中（这里具名返回值为 i），执行 return 2 的时候实际上已经将 i 的值重新赋值为 2。所以defer closure 输出结果为 2 而不是 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="defer-nil-函数"><a href="#defer-nil-函数" class="headerlink" title="defer nil 函数"></a>defer nil 函数</h4><p>解释：名为 test 的函数一直运行至结束，然后 defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> run <span class="function"><span class="keyword">func</span><span class="params">()</span> = <span class="title">nil</span></span></span><br><span class="line">    <span class="keyword">defer</span> run()</span><br><span class="line">    fmt.Println(<span class="string">&quot;runs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">runs</span><br><span class="line">runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>defer处理资源的常见写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123; <span class="comment">//需要先判断是否成功再进行defer</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123; <span class="comment">//在defer要处理error</span></span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ..code...</span></span><br><span class="line"></span><br><span class="line">    f, err = os.Open(<span class="string">&quot;another-book.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(f io.Closer)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;defer close another-book.txt err %v\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(f) <span class="comment">//直接使用闭包捕获变量，可能会导致使用的是最终的f，需要作为参数传入保证使用的f正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<ul>
<li><p>panic</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、内置函数</span><br><span class="line">2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</span><br><span class="line">3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</span><br><span class="line">4、直到goroutine整个退出，并报告错误</span><br></pre></td></tr></table></figure></li>
<li><p>recover</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、内置函数</span><br><span class="line">2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</span><br><span class="line">3、一般的调用建议</span><br><span class="line">  a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行</span><br><span class="line">  b). 可以获取通过panic传递的error</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。</span><br><span class="line">2.recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。</span><br><span class="line">3.多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。</span><br></pre></td></tr></table></figure></li>
<li><p>使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(err.(<span class="keyword">string</span>)) <span class="comment">// 将 interface&#123;&#125; 转型为具体类型。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="built_in">panic</span> error!</span><br></pre></td></tr></table></figure>

<p>向已关闭的通道发送数据会引发panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">send on closed channel</span><br></pre></td></tr></table></figure></li>
<li><p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">panic</span></span><br></pre></td></tr></table></figure></li>
<li><p>捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//有效</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>()              <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>()) <span class="comment">//无效！</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">            <span class="built_in">recover</span>() <span class="comment">//无效！</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">defer</span> inner</span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line">test <span class="built_in">panic</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用延迟匿名函数或下面这样都是有效的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> except()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    test <span class="built_in">panic</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果需要保护代码 段，可将代码块重构成匿名函数，如此可确保后续代码被执 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">                z = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">        z = x / y</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;x / y = %d\n&quot;</span>, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">x / y = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrDivByZero = errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> y == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrDivByZero</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x / y, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">switch</span> z, err := div(<span class="number">10</span>, <span class="number">0</span>); err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="built_in">println</span>(z)</span><br><span class="line">    <span class="keyword">case</span> ErrDivByZero:</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure></li>
<li><p>Go实现类似Java try-Catch的异常处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span>, <span class="title">handler</span> <span class="title">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            handler(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>panic和error两种方式的使用区别:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/25/goyu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/25/goyu/" class="post-title-link" itemprop="url">go语言基础 - 流程控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-25 01:06:47 / Modified: 02:11:19" itemprop="dateCreated datePublished" datetime="2021-11-25T01:06:47+08:00">2021-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件语句if"><a href="#条件语句if" class="headerlink" title="条件语句if"></a>条件语句if</h2><p>不支持三元运算操作符 a &gt; b ? a : b</p>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• 可省略条件表达式括号。</span><br><span class="line">    • 持初始化语句，可定义代码块局部变量。 </span><br><span class="line">    • 代码块左 括号必须在条件表达式尾部。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">    <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n := <span class="string">&quot;abc&quot;</span>; x &gt; <span class="number">0</span> &#123;     <span class="comment">// 初始化语句未必就是定义变量， 如 println(&quot;init&quot;) 也是可以的。</span></span><br><span class="line">    <span class="built_in">println</span>(n[<span class="number">2</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;    <span class="comment">// 注意 else if 和 else 左大括号位置。</span></span><br><span class="line">    <span class="built_in">println</span>(n[<span class="number">1</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(n[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件语句switch"><a href="#条件语句switch" class="headerlink" title="条件语句switch"></a>条件语句switch</h2><p>语法: 可省略break</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</span></span><br><span class="line"><span class="comment">            而如果switch没有表达式，它会匹配true。</span></span><br><span class="line"><span class="comment">            Go里面switch默认相当于每个case最后带有break，</span></span><br><span class="line"><span class="comment">            匹配成功后不会自动向下执行其他case，而是跳出整个switch,</span></span><br><span class="line"><span class="comment">            但是可以使用fallthrough强制执行后面的case代码。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Type Switch使用：switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s)</span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写法一：</span></span><br><span class="line">    <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123; <span class="comment">// 带初始化语句</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot; x 的类型 :%T\r\n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 int 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 float64 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">float64</span>:</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 func(int) 型&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;x 是 bool 或 string 型&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;未知型&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法二</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> j &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;fallthrough&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；</span></span><br><span class="line"><span class="comment">            而如果switch没有表达式，它会匹配true。</span></span><br><span class="line"><span class="comment">            Go里面switch默认相当于每个case最后带有break，</span></span><br><span class="line"><span class="comment">            匹配成功后不会自动向下执行其他case，而是跳出整个switch,</span></span><br><span class="line"><span class="comment">            但是可以使用fallthrough强制执行后面的case代码。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法三</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> m &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写法四</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">//省略条件表达式，可当 if...else if...else</span></span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 0 and i &lt; 10&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> n &gt; <span class="number">10</span> &amp;&amp; n &lt; <span class="number">20</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;i &gt; 10 and i &lt; 20&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//out</span></span><br><span class="line">x 的类型 :&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">def</span><br></pre></td></tr></table></figure>

<h2 id="条件语句select"><a href="#条件语句select" class="headerlink" title="条件语句select"></a>条件语句select</h2><p>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p>
<p>select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每个<span class="keyword">case</span>都必须是一个通信</span><br><span class="line">所有channel表达式都会被求值</span><br><span class="line">所有被发送的表达式都会被求值</span><br><span class="line">如果任意某个通信可以进行，它就执行；其他被忽略。</span><br><span class="line">如果有多个<span class="keyword">case</span>都可以运行，Select会随机公平地选出一个执行。其他不会执行。</span><br><span class="line">否则：</span><br><span class="line">如果有<span class="keyword">default</span>子句，则执行该语句。</span><br><span class="line">如果没有<span class="keyword">default</span>字句，<span class="keyword">select</span>将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用和典型用法：</p>
<p>select是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。 select中的case语句必须是一个channel操作</p>
<p>select中的default子句总是可运行的。</p>
<p>如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。</p>
<p>如果没有可运行的case语句，且有default语句，那么就会执行default的动作。</p>
<p>如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行</p>
<ol>
<li><p>正常使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：no communication</span></span><br></pre></td></tr></table></figure></li>
<li><p>超时判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行</span></span><br><span class="line"><span class="keyword">var</span> resChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// do request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-resChan:</span><br><span class="line">        doData(data)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;request time out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doData</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程（协程）中如下：</span></span><br><span class="line"><span class="keyword">var</span> shouldQuit=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">fun main()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//loop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...out of the loop</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-c.shouldQuit:</span><br><span class="line">            cleanUp()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行</span></span><br><span class="line"><span class="built_in">close</span>(shouldQuit)</span><br></pre></td></tr></table></figure></li>
<li><p>判断channel是否阻塞</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断</span></span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">data：=<span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- data:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//做相应操作，比如丢弃data。视需求而定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>语法：没有while，go的for同时承担for和while的职责</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line"><span class="keyword">for</span>语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止<span class="keyword">for</span>循环，执行循环体外语句。</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, n := <span class="number">0</span>, <span class="built_in">len</span>(s); i &lt; n; i++ &#123; <span class="comment">// 常见的 for 循环，支持初始化语句。</span></span><br><span class="line">    <span class="built_in">println</span>(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;                <span class="comment">// 替代 while (n &gt; 0) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s[n])        <span class="comment">// 替代 for (; n &gt; 0;) &#123;&#125;</span></span><br><span class="line">    n-- </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;                    <span class="comment">// 替代 while (true) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println</span>(s)            <span class="comment">// 替代 for (;;) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：在初始化语句中计算出全部结果比较合适，编译器不一定能优化到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;abcd&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, n := <span class="number">0</span>, length(s); i &lt; n; i++ &#123;     <span class="comment">// 避免多次调用 length 函数。</span></span><br><span class="line">		<span class="comment">//println(i, s[i])</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;next out&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length(s); i++ &#123;</span><br><span class="line">		<span class="comment">//println(i, s[i])</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">call length.</span><br><span class="line">next out</span><br><span class="line">call length.</span><br><span class="line">call length.</span><br><span class="line">call length.</span><br><span class="line">call length.</span><br><span class="line">call length.</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">numbers := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for 循环 */</span></span><br><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>; a &lt; <span class="number">10</span>; a++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a &lt; b &#123;</span><br><span class="line">  a++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a 的值为: %d\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;这是无限循环。\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环语句range"><a href="#循环语句range" class="headerlink" title="循环语句range"></a>循环语句range</h2><p>语法：</p>
<p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 忽略 2nd value，支持 string/array/slice/map。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">  <span class="built_in">println</span>(s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略 index。</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">  <span class="built_in">println</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 忽略全部返回值，仅迭代。</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// 返回 (key, value)。</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">  <span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：range遍历时会拷贝对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123; <span class="comment">// index、value 都是从复制品中取出。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123; <span class="comment">// 在修改前，我们先修改原数组。</span></span><br><span class="line">            a[<span class="number">1</span>], a[<span class="number">2</span>] = <span class="number">999</span>, <span class="number">999</span></span><br><span class="line">            fmt.Println(a) <span class="comment">// 确认修改有效，输出 [0, 999, 999]。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[i] = v + <span class="number">100</span> <span class="comment">// 使用复制品中取出的 value 修改原数组。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 [100, 101, 102]。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">[<span class="number">0</span> <span class="number">999</span> <span class="number">999</span>]</span><br><span class="line">[<span class="number">100</span> <span class="number">101</span> <span class="number">102</span>]</span><br><span class="line">修改时，使用a[index]来修改</span><br></pre></td></tr></table></figure>

<p>for和for range的区别：</p>
<p>for可以</p>
<p>遍历array和slice</p>
<p>遍历key为整型递增的map</p>
<p>遍历string</p>
<p>for range可以完成所有for可以做的事情，却能做到for不能做的，包括</p>
<p>遍历key为string类型的map并同时获取key和value</p>
<p>遍历channel</p>
<h2 id="循环控制Goto-Break-Continue"><a href="#循环控制Goto-Break-Continue" class="headerlink" title="循环控制Goto,Break,Continue"></a>循环控制Goto,Break,Continue</h2><ol>
<li>三个语句都可以配合标签（label）使用</li>
<li>标签名区分大小写，定以后不使用会造成编译错误</li>
<li>Continue, Break可以配合标签（label）用于多层循环的跳出</li>
<li>Goto是调整执行的位置</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/24/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/24/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">go语言基础 - 结构体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-24 00:43:48 / Modified: 02:23:31" itemprop="dateCreated datePublished" datetime="2021-11-24T00:43:48+08:00">2021-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口实现类似面向对象的效果</p>
<h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>Go语言中可以使用type关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本类型rune和byte就是类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义类型与类型别名的区别"><a href="#自定义类型与类型别名的区别" class="headerlink" title="自定义类型与类型别名的区别"></a>自定义类型与类型别名的区别</h3><p>自定义类型是真正的类型，类型别名之后再代码中存在，编译完成不会再有</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">        字段名 字段类型</span><br><span class="line">        字段名 字段类型</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1.</span>类型名：标识自定义结构体的名称，在同一个包内不能重复。</span><br><span class="line"><span class="number">2.</span>字段名：表示结构体字段名。结构体中的字段名必须唯一。</span><br><span class="line"><span class="number">3.</span>字段类型：表示结构体字段的具体类型。</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">  city <span class="keyword">string</span></span><br><span class="line">  age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同种类型可以写在同一行</span></span><br><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">  name, city <span class="keyword">string</span></span><br><span class="line">  age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<ol>
<li><p>声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br><span class="line">结构体本身也是一种类型，我们可以像声明内置类型一样使用<span class="keyword">var</span>关键字声明结构体类型</span><br></pre></td></tr></table></figure></li>
<li><p>基本实例化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">    p1.age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过.来访问结构体字段</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时的数据结构场景下可以使用匿名结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">user.Name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">user.Age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="实例化和初始化"><a href="#实例化和初始化" class="headerlink" title="实例化和初始化"></a>实例化和初始化</h3><ol>
<li><p>创建指针类型结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用new关键字对结构体进行实例化，得到结构体的地址</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Go语言中支持对结构体指针直接使用.来访问结构体的成员</span></span><br><span class="line"><span class="comment">//p2.name = &quot;测试&quot; 在底层实现为(*p2).name = &quot;测试&quot;，这里是Go实现的语法糖</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;测试&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>取结构体的地址实例化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作</span></span><br><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;博客&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;博客&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">结构体初始化：</span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 person <span class="comment">//什么后初始化值默认为各类型的0</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">键值对初始化：</span><br><span class="line">p5 := person&#123; <span class="comment">//结构体键值对初始化</span></span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p6 := &amp;person&#123; <span class="comment">//结构体指针键值对初始化</span></span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">p7 := &amp;person&#123; <span class="comment">//只对指定key初始化，其他字段默认0值</span></span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">使用值的列表初始化：</span><br><span class="line"></span><br><span class="line">注意：<span class="number">1.</span> 必须初始化结构体的所有字段。<span class="number">2.</span> 初始值的填充顺序必须与字段在结构体中的声明顺序一致。<span class="number">3.</span> 该方式不能和键值初始化方式混用。</span><br><span class="line"></span><br><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结构体内存布局：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int8</span></span><br><span class="line">    b <span class="keyword">int8</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">n.a <span class="number">0xc0000a0060</span></span><br><span class="line">n.b <span class="number">0xc0000a0061</span></span><br><span class="line">n.c <span class="number">0xc0000a0062</span></span><br><span class="line">n.d <span class="number">0xc0000a0063</span></span><br><span class="line"></span><br><span class="line">为连续的内存地址</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数:</p>
<p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use</span></span><br><span class="line">p9 := newPerson(<span class="string">&quot;pprof.cn&quot;</span>, <span class="string">&quot;测试&quot;</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用的问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structInit</span><span class="params">( )</span></span>  &#123;</span><br><span class="line">	<span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">		age <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">	studs := []student&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;a&quot;</span>,age: <span class="number">18</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;b&quot;</span>,age: <span class="number">19</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;c&quot;</span>,age: <span class="number">20</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> studs &#123;</span><br><span class="line">		<span class="comment">//因为stu是值拷贝的形式，所有最终的value都是拷贝的地址，即最后的value</span></span><br><span class="line">		m[stu.name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k,<span class="string">&quot;=&gt;&quot;</span>,v.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">map</span>[a:<span class="number">0xc00000c060</span> b:<span class="number">0xc00000c060</span> c:<span class="number">0xc00000c060</span>]</span><br><span class="line">a =&gt; c</span><br><span class="line">b =&gt; c</span><br><span class="line">c =&gt; c</span><br><span class="line"><span class="comment">//正确使用</span></span><br><span class="line"><span class="keyword">for</span> i, stu := <span class="keyword">range</span> studs &#123;</span><br><span class="line">		<span class="comment">//因为stu是值拷贝的形式，所有最终的value都是拷贝的地址，即最后的value</span></span><br><span class="line">		m[stu.name] = &amp;studs[i]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法和接受者"><a href="#方法和接受者" class="headerlink" title="方法和接受者"></a>方法和接受者</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p>
<p>方法与函数的区别：函数不属于任何类型，方法属于特定的类型</p>
<p><strong>基本定义和使用：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意事项</span></span><br><span class="line"><span class="number">1.</span>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</span><br><span class="line"><span class="number">2.</span>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span><br><span class="line"><span class="number">3.</span>方法名、参数列表、返回参数：具体格式与函数定义相同。</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针类型的接受者和值类型的接受者</strong></p>
<p>区别：</p>
<ol>
<li>指针类型：指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。</li>
<li>值类型：当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针类型接受者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">        p.age = newAge</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//值类型接受者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">什么时候选择指针类型接收者:</span><br><span class="line">    <span class="number">1.</span>需要修改接收者中的值</span><br><span class="line">    <span class="number">2.</span>接收者是拷贝代价比较大的大对象</span><br><span class="line">    <span class="number">3.</span>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span><br></pre></td></tr></table></figure>

<p><strong>任意类型添加方法：</strong></p>
<p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。</p>
<p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 MyInt</span><br><span class="line">    m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体其他特性"><a href="#结构体其他特性" class="headerlink" title="结构体其他特性"></a>结构体其他特性</h3><h4 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 := Person&#123;</span><br><span class="line">  <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//pprof.cn 18</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := User&#123;</span><br><span class="line">        Name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            Province: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">            City:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//嵌套匿名结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user2 User</span><br><span class="line">    user2.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;黑龙江&quot;</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">    user2.City = <span class="string">&quot;哈尔滨&quot;</span>                <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h4><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province   <span class="keyword">string</span></span><br><span class="line">    City       <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account    <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    <span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体中的“继承”"><a href="#结构体中的“继承”" class="headerlink" title="结构体中的“继承”"></a>结构体中的“继承”</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="keyword">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体的可见性"><a href="#结构体的可见性" class="headerlink" title="结构体的可见性"></a>结构体的可见性</h4><p><strong>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</strong></p>
<h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title    <span class="keyword">string</span></span><br><span class="line">    Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;Class&#123;</span><br><span class="line">        Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;Student&#123;</span><br><span class="line">            Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            ID:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">    data, err := json.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">    <span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">    str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">    c1 := &amp;Class&#123;&#125;</span><br><span class="line">    err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体Tag"><a href="#结构体Tag" class="headerlink" title="结构体Tag"></a>结构体Tag</h4><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p>
<p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span><br></pre></td></tr></table></figure>

<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">    Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">    name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/22/go%E5%9F%BA%E7%A1%80-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/22/go%E5%9F%BA%E7%A1%80-Map/" class="post-title-link" itemprop="url">go基础 - Map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-22 01:26:01" itemprop="dateCreated datePublished" datetime="2021-11-22T01:26:01+08:00">2021-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-11 20:31:32" itemprop="dateModified" datetime="2022-01-11T20:31:32+08:00">2022-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Map及其底层实现"><a href="#Map及其底层实现" class="headerlink" title="Map及其底层实现"></a>Map及其底层实现</h1><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<p>实现是一种hashmap。</p>
<h3 id="map定义："><a href="#map定义：" class="headerlink" title="map定义："></a>map定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br><span class="line"></span><br><span class="line">KeyType:表示键的类型。</span><br><span class="line"></span><br><span class="line">ValueType:表示键对应的值的类型。</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>类型的变量默认初始值为<span class="literal">nil</span>，需要使用<span class="built_in">make</span>()函数来分配内存。</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>

<h3 id="map基本使用："><a href="#map基本使用：" class="headerlink" title="map基本使用："></a>map基本使用：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断某个key是否存在"><a href="#判断某个key是否存在" class="headerlink" title="判断某个key是否存在"></a>判断某个key是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure>

<h3 id="Go中Map的实现原理："><a href="#Go中Map的实现原理：" class="headerlink" title="Go中Map的实现原理："></a>Go中Map的实现原理：</h3><p>map是通过数组存储，数组下标出存储的是一个bucket,每个bucket可以存储8个kv对，当存满8个以后，会通过overflow指针指向一个新的bucket，形成一个链表</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwnb2ndaawj30xx0e5adm.jpg" alt="img"></p>
<p>tophash用于快速查找key值是否在该bucket，存储结构为kkk vvv是因为，比如map[int64]int8，由于kv的长度不同，如果按照kv存储，考虑到内存对齐，v也需要int64，但是按照kkkvvv，则8个v刚好占用一个int64</p>
<p>overflow是链表法解决key的hash冲突问题</p>
<p>具体情况：</p>
<p>当往map存储一个kv对时，通过k获取hash值，hash值的低八位与bucket数组长度取余，定位到数组的下标，hash值的高八位存储在bucket的tophash中，快速判断是否存在key，kv的具体值则是通过指针运算存储，当bucket满时会自动通过overflow链接到下一个bucket</p>
<p>补充：在运行期间，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a> 结构体其实不止包含 <code>tophash</code> 字段，因为哈希表中可能存储不同类型的键值对，而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导。<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.bmap"><code>runtime.bmap</code></a> 中的其他字段在运行时也都是通过计算内存地址的方式访问的，所以它的定义中就不包含这些字段，不过我们能根据编译期间的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/gc.bmap"><code>cmd/compile/internal/gc.bmap</code></a> 函数重建它的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p>
<p>go的map源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">//获取hash算法</span></span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">    <span class="comment">//如果bucket数组一开始为空，则初始化</span></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 定位存储在哪一个bucket中</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">//得到bucket的结构体</span></span><br><span class="line">    b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) +bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">//获取高八位hash值</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="keyword">var</span> inserti *<span class="keyword">uint8</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">    <span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//循环bucket中的tophash数组</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">//如果hash不相等</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">             <span class="comment">//判断是否为空，为空则插入</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                    val = add( unsafe.Pointer(b), </span><br><span class="line">                    dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize) )</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//插入成功，终止最外层循环</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到这里说明高八位hash一样，获取已存在的key</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断两个key是否相等，不相等就循环下一个</span></span><br><span class="line">            <span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果相等则更新</span></span><br><span class="line">            <span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">                typedmemmove(t.key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取已存在的value</span></span><br><span class="line">            val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">            <span class="keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上一个bucket没能插入，则通过overflow获取链表上的下一个bucket</span></span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">        newb := h.newoverflow(t, b)</span><br><span class="line">        inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        val = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store new key/value at insert position</span></span><br><span class="line">    <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">        kmem := newobject(t.key)</span><br><span class="line">        *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">        insertk = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">        vmem := newobject(t.elem)</span><br><span class="line">        *(*unsafe.Pointer)(val) = vmem</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(t.key, insertk, key)</span><br><span class="line">    <span class="comment">//将高八位hash值存储</span></span><br><span class="line">    *inserti = top</span><br><span class="line">    h.count++</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/22/go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/22/go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">go基础 - 指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-11-22 01:07:25 / Modified: 01:25:16" itemprop="dateCreated datePublished" datetime="2021-11-22T01:07:25+08:00">2021-11-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go中的指针类似Java中的指针，不能进行偏移和运算。</p>
<p>使用：&amp;（取地址）和 *（根据地址取值）</p>
<h2 id="取变量指针："><a href="#取变量指针：" class="headerlink" title="取变量指针："></a>取变量指针：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br><span class="line">v:代表被取地址的变量，类型为T</span><br><span class="line">ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//指针取值</span></span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b)</span><br><span class="line">    c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value of c:%v\n&quot;</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line"><span class="keyword">type</span> of b:*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="keyword">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</span><br><span class="line"><span class="number">2.</span>指针变量的值是指针地址。</span><br><span class="line"><span class="number">3.</span>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    modify1(a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">    modify2(&amp;a)</span><br><span class="line">    fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><ul>
<li>当一个指针被定义后没有分配到任何变量时，它的值为 nil</li>
<li>空指针的判断 p == nil</li>
</ul>
<h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><ol>
<li><p>new - 用于分配内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Type表示类型，<span class="built_in">new</span>函数只接受一个参数，这个参数是一个类型</span><br><span class="line"><span class="number">2.</span>*Type表示类型指针，<span class="built_in">new</span>函数返回一个指向该类型内存地址的指针。</span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span>函数不太常用，使用<span class="built_in">new</span>函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">    fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">    fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Make - 用于分配内存</p>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">&quot;测试&quot;</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对比：</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>二者都是用来做内存分配的。</span><br><span class="line"><span class="number">2.</span><span class="built_in">make</span>只用于slice、<span class="keyword">map</span>以及channel的初始化，返回的还是这三个引用类型本身；</span><br><span class="line"><span class="number">3.</span>而<span class="built_in">new</span>用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongsongzhi.github.io/zhongsongzhi97.github.io/2021/11/21/go%E5%9F%BA%E7%A1%80-Slice%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/37136639?s=400&u=6e2ba0de05f1020daf278189f1ffe69c5ac946af&v=4#/images/avatar.gif">
      <meta itemprop="name" content="Dylan Zhong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dylan Zhong`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zhongsongzhi97.github.io/2021/11/21/go%E5%9F%BA%E7%A1%80-Slice%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">go基础 - Slice实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-21 22:09:57" itemprop="dateCreated datePublished" datetime="2021-11-21T22:09:57+08:00">2021-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-11-22 01:06:51" itemprop="dateModified" datetime="2021-11-22T01:06:51+08:00">2021-11-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Slice底层实现"><a href="#Slice底层实现" class="headerlink" title="Slice底层实现"></a>Slice底层实现</h1><h2 id="切片与数组的对比"><a href="#切片与数组的对比" class="headerlink" title="切片与数组的对比"></a>切片与数组的对比</h2><p>切片是引用类型，数组是值类型，大数组的传递会消耗较多的内存，且性能差，这种场景下使用切片更合适。</p>
<p>反例：</p>
<p>因为切片底层数组可能会在堆上分配内存，小数组在栈上拷贝的消耗不一定比make大</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go test -bench . -benchmem -gcflags &quot;-N -l&quot;</span></span><br><span class="line"><span class="comment">// 禁用内联和优化</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">()</span> [1024]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x [<span class="number">1024</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">        x[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">        x[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkArray</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        array()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSlice</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        slice()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">在测试 Array 的时候，用的是4核，循环次数是500000，平均每次执行时间是3637 ns，每次执行堆上分配内存总量是0，分配次数也是0 。</span><br><span class="line"></span><br><span class="line">而切片的结果就“差”一点，同样也是用的是4核，循环次数是300000，平均每次执行时间是4055 ns，但是每次执行一次，堆上分配内存总量是8192，分配次数也是1 。</span><br></pre></td></tr></table></figure>

<h2 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切片是对数组的一个连续片段的引用</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">//指向一个数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">//当前切片长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">//当前切片容量 cap &gt;= len</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">s := make([]byte, 200)</span><br><span class="line">	ptr := unsafe.Pointer(&amp;s[0]) //从slice获取到一块内存地址</span><br><span class="line">	fmt.Println(ptr)</span><br><span class="line"></span><br><span class="line">	//从go的内存地址构造一个slice</span><br><span class="line">	var ptr1 unsafe.Pointer</span><br><span class="line">	length := 10</span><br><span class="line">	var s1 = struct &#123;</span><br><span class="line">		addr unsafe.Pointer</span><br><span class="line">		len int</span><br><span class="line">		cap int</span><br><span class="line">	&#125;&#123;ptr1, length,length&#125;</span><br><span class="line">	s2 := *(*[]byte)(unsafe.Pointer(&amp;s1))</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	//使用反射构造一个slice</span><br><span class="line">	 a  := [...]int&#123;1,2,3&#125;</span><br><span class="line">	var o []byte</span><br><span class="line">	sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;o))</span><br><span class="line">	sliceHeader.Cap = length</span><br><span class="line">	sliceHeader.Len = length</span><br><span class="line">	sliceHeader.Data = uintptr(o)</span><br><span class="line">	fmt.Println(sliceHeader)</span><br></pre></td></tr></table></figure>

<h2 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h2><p>make和切片字面量创建切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据切片的数据类型，获取切片的最大容量</span></span><br><span class="line">    maxElements := maxSliceCap(et.size)</span><br><span class="line">    <span class="comment">// 比较切片的长度，长度值域应该在[0,maxElements]之间</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="keyword">uintptr</span>(<span class="built_in">len</span>) &gt; maxElements &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: len out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较切片的容量，容量值域应该在[len,maxElements]之间</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &lt; <span class="built_in">len</span> || <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &gt; maxElements &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: cap out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据切片的容量申请内存</span></span><br><span class="line">    p := mallocgc(et.size*<span class="keyword">uintptr</span>(<span class="built_in">cap</span>), et, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 返回申请好内存的切片的首地址</span></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, <span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn96wm5gwj317e0k0t9m.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn97gztd6j317e0k0t9q.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn97nii2oj319e0rumyq.jpg" alt="img"></p>
<h2 id="nil和空切片"><a href="#nil和空切片" class="headerlink" title="nil和空切片"></a>nil和空切片</h2><p>nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</p>
<p>空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</p>
<p>区别：空切片指向的地址不是nil，而是指向一个内存地址，但是没有分配内存空间</p>
<p>但是无法nil还是空切片，使用append，len，cap的效果是一样的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn98nlhb1j30sb0ecq31.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn98vhvktj30sb0ec0t2.jpg" alt="img"></p>
<h2 id="切片的扩容策略："><a href="#切片的扩容策略：" class="headerlink" title="切片的扩容策略："></a>切片的扩容策略：</h2><ol>
<li><p>切片如果容量小于1024个元素，会在扩容是翻倍增加容量，超过1024个时，会每次增加1/4。</p>
</li>
<li><p>扩容都是对当前容量来说。</p>
</li>
<li><p>新数组还是老数组：如果原数组还有容量可以扩容，执行append以后会直接在原数组执行</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc(unsafe.Pointer(&amp;et))</span><br><span class="line">        racereadrangepc(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(old.array, <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>*<span class="keyword">int</span>(et.size)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报panic了。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前切片的大小为0，还调用了扩容方法，那么就新生成一个新的容量的切片返回。</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里就是扩容的策略</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的切片的容量，长度。</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line">    <span class="keyword">const</span> ptrSize = unsafe.Sizeof((*<span class="keyword">byte</span>)(<span class="literal">nil</span>))</span><br><span class="line">    <span class="keyword">switch</span> et.size &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line">    <span class="keyword">case</span> ptrSize:</span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * ptrSize</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * ptrSize</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / ptrSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">        newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * et.size)</span><br><span class="line">        newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断非法的值，保证容量是在增加，并且容量不超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> || <span class="keyword">uintptr</span>(newcap) &gt; maxSliceCap(et.size) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 在老的切片后面继续扩充容量</span></span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 将 lenmem 这个多个 bytes 从 old.array地址 拷贝到 p 的地址处</span></span><br><span class="line">        memmove(p, old.array, lenmem)</span><br><span class="line">        <span class="comment">// 先将 P 地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的 capmem-newlenmem 个 bytes 这块内存初始化。为之后继续 append() 操作腾出空间。</span></span><br><span class="line">        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 重新申请新的数组给新切片</span></span><br><span class="line">        <span class="comment">// 重新申请 capmen 这个大的内存地址，并且初始化为0值</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !writeBarrier.enabled &#123;</span><br><span class="line">            <span class="comment">// 如果还不能打开写锁，那么只能把 lenmem 大小的 bytes 字节从 old.array 拷贝到 p 的地址处</span></span><br><span class="line">            memmove(p, old.array, lenmem)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 循环拷贝老的切片的值</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; lenmem; i += et.size &#123;</span><br><span class="line">                typedmemmove(et, add(p, i), add(old.array, i))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最终新切片，容量更新为最新扩容之后的容量</span></span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字面常量创建切片时，cap不等于执行数组的总容量时，通常可能会发生在原数组上扩容的情况：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn9hcf926j31d20u040j.jpg" alt="img"></p>
<p>在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。</p>
<h2 id="切片拷贝："><a href="#切片拷贝：" class="headerlink" title="切片拷贝："></a>切片拷贝：</h2><p>Slice的拷贝方法有两个：</p>
<ol>
<li>在slicecopy中，会把源切片值中的元素复制到目标切片，并返回复制的元素个数，copy类型必须一致，长度取决于较短的那个。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">    <span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">    n := fm.<span class="built_in">len</span></span><br><span class="line">    <span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">        n = to.<span class="built_in">len</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度</span></span><br><span class="line">    <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">        pc := funcPC(slicecopy)</span><br><span class="line">        racewriterangepc(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">        racereadrangepc(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanwrite(to.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">        msanread(fm.array, <span class="keyword">uintptr</span>(n*<span class="keyword">int</span>(width)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span> &#123; </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">        <span class="comment">// 如果只有一个元素，那么指针直接转换即可</span></span><br><span class="line">        *(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后</span></span><br><span class="line">        memmove(to.array, fm.array, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn9lneksyj31940u00v0.jpg" alt="img"></p>
<ol start="2">
<li>Slicestringcopy</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(to []<span class="keyword">byte</span>, fm <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || <span class="built_in">len</span>(to) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n 记录下源切片或者目标切片较短的那一个的长度</span></span><br><span class="line">    n := <span class="built_in">len</span>(fm)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(to) &lt; n &#123;</span><br><span class="line">        n = <span class="built_in">len</span>(to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了竞争检测</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc(unsafe.Pointer(&amp;to))</span><br><span class="line">        pc := funcPC(slicestringcopy)</span><br><span class="line">        racewriterangepc(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="keyword">uintptr</span>(n), callerpc, pc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了 The memory sanitizer (msan)</span></span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanwrite(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="keyword">uintptr</span>(n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝字符串至字节数组</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;to[<span class="number">0</span>]), stringStructOf(&amp;fm).str, <span class="keyword">uintptr</span>(n))</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用range去遍历一个切片时"><a href="#使用range去遍历一个切片时" class="headerlink" title="使用range去遍历一个切片时"></a>使用range去遍历一个切片时</h2><p>如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &amp;slice[index] 获取真实的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;value = %d , value-addr = %x , slice-addr = %x\n&quot;</span>, value, &amp;value, &amp;slice[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//out</span></span><br><span class="line">    value = <span class="number">10</span> , value-addr = c4200aedf8 , slice-addr = c4200b0320</span><br><span class="line">    value = <span class="number">20</span> , value-addr = c4200aedf8 , slice-addr = c4200b0328</span><br><span class="line">    value = <span class="number">30</span> , value-addr = c4200aedf8 , slice-addr = c4200b0330</span><br><span class="line">    value = <span class="number">40</span> , value-addr = c4200aedf8 , slice-addr = c4200b0338</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwn9p0ndlij314a0u0wh6.jpg" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/zhongsongzhi97.github.io/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/zhongsongzhi97.github.io/">1</a><a class="page-number" href="/zhongsongzhi97.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/zhongsongzhi97.github.io/page/4/">4</a><a class="extend next" rel="next" href="/zhongsongzhi97.github.io/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Zhong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/zhongsongzhi97.github.io/js/comments.js"></script><script src="/zhongsongzhi97.github.io/js/utils.js"></script><script src="/zhongsongzhi97.github.io/js/motion.js"></script><script src="/zhongsongzhi97.github.io/js/next-boot.js"></script>

  





  





</body>
</html>
